{
    "apci_uvm_seqr": {
        "prefix": "apci_uvm_seqr",
        "body": [
            "apci_uvm_seqr  ${0:name_class};"
        ],
        "description": "class apci_uvm_seqr extends uvm_sequencer #(avery_data_base);\n"
    },
    "apci_uvm_seqr :: new": {
        "prefix": [
            "new",
            "function:new -> apci_uvm_seqr"
        ],
        "body": [
            "new(${1:name}, ${2:parent});"
        ],
        "description": "[Class:apci_uvm_seqr]\n     function new(string name = \"apci_uvm_seqr\",\n uvm_component parent = null);    "
    },
    "apci_port_status": {
        "prefix": "apci_port_status",
        "body": [
            "apci_port_status  ${0:name_class};"
        ],
        "description": "class apci_port_status extends apci_data_base;\n"
    },
    "apci_port_status :: new": {
        "prefix": [
            "new",
            "function:new -> apci_port_status"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_port_status]\n     function new(string name=\"\");    "
    },
    "acxl_callbacks": {
        "prefix": "acxl_callbacks",
        "body": [
            "acxl_callbacks  ${0:name_class};"
        ],
        "description": "virtual class acxl_callbacks extends apci_callbacks_base;\n"
    },
    "acxl_callbacks :: tx_create_cxl_msg": {
        "prefix": [
            "tx_create_cxl_msg",
            "function:tx_create_cxl_msg -> acxl_callbacks"
        ],
        "body": [
            "tx_create_cxl_msg(${1:bfm}, ${2:msg});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_create_cxl_msg(    input apci_device   bfm,\n    input acxl_msg      msg);    "
    },
    "acxl_callbacks :: tx_cxl_msg_exit_tl": {
        "prefix": [
            "tx_cxl_msg_exit_tl",
            "function:tx_cxl_msg_exit_tl -> acxl_callbacks"
        ],
        "body": [
            "tx_cxl_msg_exit_tl(${1:bfm}, ${2:msg});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_cxl_msg_exit_tl(    input apci_device      bfm,\n    input acxl_msg         msg );return;    "
    },
    "acxl_callbacks :: tx_flit_before_encrypt": {
        "prefix": [
            "tx_flit_before_encrypt",
            "function:tx_flit_before_encrypt -> acxl_callbacks"
        ],
        "body": [
            "tx_flit_before_encrypt(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_flit_before_encrypt(    apci_device   bfm,\n    acxl_flit     flit );    "
    },
    "acxl_callbacks :: tx_ide_mac_epoch_created": {
        "prefix": [
            "tx_ide_mac_epoch_created",
            "function:tx_ide_mac_epoch_created -> acxl_callbacks"
        ],
        "body": [
            "tx_ide_mac_epoch_created(${1:bfm}, ${2:last_flit}, ${3:truncated});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_ide_mac_epoch_created(    apci_device   bfm,\n    acxl_flit     last_flit,\n    bit           truncated);    "
    },
    "acxl_callbacks :: tx_flit_exit_dll": {
        "prefix": [
            "tx_flit_exit_dll",
            "function:tx_flit_exit_dll -> acxl_callbacks"
        ],
        "body": [
            "tx_flit_exit_dll(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_flit_exit_dll(    apci_device   bfm,\n    acxl_flit     flit );    "
    },
    "acxl_callbacks :: tx_flit_exit_arbmux": {
        "prefix": [
            "tx_flit_exit_arbmux",
            "function:tx_flit_exit_arbmux -> acxl_callbacks"
        ],
        "body": [
            "tx_flit_exit_arbmux(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_flit_exit_arbmux(    apci_device   bfm,\n    acxl_flit     flit );    "
    },
    "acxl_callbacks :: tx_flit_exit_mac": {
        "prefix": [
            "tx_flit_exit_mac",
            "function:tx_flit_exit_mac -> acxl_callbacks"
        ],
        "body": [
            "tx_flit_exit_mac(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void tx_flit_exit_mac(    apci_device   bfm,\n    acxl_flit     flit );    "
    },
    "acxl_callbacks :: rx_flit_enter_mac": {
        "prefix": [
            "rx_flit_enter_mac",
            "function:rx_flit_enter_mac -> acxl_callbacks"
        ],
        "body": [
            "rx_flit_enter_mac(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void rx_flit_enter_mac(    apci_device  bfm,\n    acxl_flit    flit);    "
    },
    "acxl_callbacks :: rx_flit_enter_arbmux": {
        "prefix": [
            "rx_flit_enter_arbmux",
            "function:rx_flit_enter_arbmux -> acxl_callbacks"
        ],
        "body": [
            "rx_flit_enter_arbmux(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void rx_flit_enter_arbmux(    apci_device  bfm,\n    acxl_flit    flit);    "
    },
    "acxl_callbacks :: rx_flit_enter_dll": {
        "prefix": [
            "rx_flit_enter_dll",
            "function:rx_flit_enter_dll -> acxl_callbacks"
        ],
        "body": [
            "rx_flit_enter_dll(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void rx_flit_enter_dll(    apci_device  bfm,\n    acxl_flit    flit);    "
    },
    "acxl_callbacks :: rx_flit_after_decrypt": {
        "prefix": [
            "rx_flit_after_decrypt",
            "function:rx_flit_after_decrypt -> acxl_callbacks"
        ],
        "body": [
            "rx_flit_after_decrypt(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void rx_flit_after_decrypt(    apci_device  bfm,\n    acxl_flit    flit);    "
    },
    "acxl_callbacks :: rx_cxl_msg_enter_tl": {
        "prefix": [
            "rx_cxl_msg_enter_tl",
            "function:rx_cxl_msg_enter_tl -> acxl_callbacks"
        ],
        "body": [
            "rx_cxl_msg_enter_tl(${1:bfm}, ${2:msg});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void rx_cxl_msg_enter_tl(    input apci_device      bfm,\n    input acxl_msg         msg );    "
    },
    "acxl_callbacks :: read_mem_line_cb": {
        "prefix": [
            "read_mem_line_cb",
            "function:read_mem_line_cb -> acxl_callbacks"
        ],
        "body": [
            "read_mem_line_cb(${1:addr}, ${2:bytes}, ${3:src});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void read_mem_line_cb(    input bit               addr        ,\n    ref   bit               bytes           ,\n    input avery_data_base   src = null);    "
    },
    "acxl_callbacks :: write_mem_line_cb": {
        "prefix": [
            "write_mem_line_cb",
            "function:write_mem_line_cb -> acxl_callbacks"
        ],
        "body": [
            "write_mem_line_cb(${1:addr}, ${2:byte_enable}, ${3:bytes}, ${4:src});"
        ],
        "description": "[Class:acxl_callbacks]\n     virtual function void write_mem_line_cb(            input bit               addr        ,\n            input bit               byte_enable ,\n    ref   bit               bytes           ,\n    input avery_data_base   src = null       );    "
    },
    "acxl_msg_callbacks": {
        "prefix": "acxl_msg_callbacks",
        "body": [
            "acxl_msg_callbacks  ${0:name_class};"
        ],
        "description": "virtual class acxl_msg_callbacks extends apci_callbacks_base;\n"
    },
    "force_rcvr_detection": {
        "prefix": [
            "force_rcvr_detection",
            "function:force_rcvr_detection"
        ],
        "body": [
            "force_rcvr_detection(${1:detected}, ${2:is_busA});"
        ],
        "description": "    function void force_rcvr_detection(bit       detected,\n bit is_busA);    "
    },
    "set_timing": {
        "prefix": [
            "set_timing",
            "function:set_timing"
        ],
        "body": [
            "set_timing(${1:entry}, ${2:lane_no}, ${3:n_pclks}, ${4:is_busA});"
        ],
        "description": "    function void set_timing(string entry,\n byte lane_no,\n int n_pclks,\n bit is_busA);    "
    },
    "set_value": {
        "prefix": [
            "set_value",
            "function:set_value"
        ],
        "body": [
            "set_value(${1:entry}, ${2:lane_no}, ${3:value}, ${4:is_busA});"
        ],
        "description": "    function void set_value(string entry,\n byte lane_no,\n int value,\n bit is_busA);    "
    },
    "apci_device_util": {
        "prefix": "apci_device_util",
        "body": [
            "apci_device_util  ${0:name_class};"
        ],
        "description": "class apci_device_util;\n"
    },
    "apci_device_util :: new": {
        "prefix": [
            "new",
            "function:new -> apci_device_util"
        ],
        "body": [
            "new(${1:bfm});"
        ],
        "description": "[Class:apci_device_util]\n function new(apci_device bfm);    "
    },
    "apci_device_util :: wait_tx_msg": {
        "prefix": [
            "wait_tx_msg",
            "task:wait_tx_msg -> apci_device_util"
        ],
        "body": [
            "wait_tx_msg(${1:port_id}, ${2:code}, ${3:timer}, ${4:msg});"
        ],
        "description": "[Class:apci_device_util]\n virtual task wait_tx_msg(int port_id,\n apci_msg_code_e code,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_device_util :: wait_rx_msg": {
        "prefix": [
            "wait_rx_msg",
            "task:wait_rx_msg -> apci_device_util"
        ],
        "body": [
            "wait_rx_msg(${1:port_id}, ${2:code}, ${3:timer}, ${4:msg});"
        ],
        "description": "[Class:apci_device_util]\n virtual task wait_rx_msg(int port_id,\n apci_msg_code_e code,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_device_util :: wait_rx_err_msg": {
        "prefix": [
            "wait_rx_err_msg",
            "task:wait_rx_err_msg -> apci_device_util"
        ],
        "body": [
            "wait_rx_err_msg(${1:port_id}, ${2:timer}, ${3:msg}, ${4:tlp});"
        ],
        "description": "[Class:apci_device_util]\n virtual task wait_rx_err_msg(int port_id,\n time timer = 0,\n string msg = \"\",\n output apci_tlp tlp);    "
    },
    "apci_device_util :: wait_tx_dllp": {
        "prefix": [
            "wait_tx_dllp",
            "task:wait_tx_dllp -> apci_device_util"
        ],
        "body": [
            "wait_tx_dllp(${1:port_id}, ${2:t}, ${3:timer}, ${4:msg});"
        ],
        "description": "[Class:apci_device_util]\n virtual task wait_tx_dllp(int port_id,\n apci_dllp_type t,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_device_util :: wait_rx_dllp": {
        "prefix": [
            "wait_rx_dllp",
            "task:wait_rx_dllp -> apci_device_util"
        ],
        "body": [
            "wait_rx_dllp(${1:port_id}, ${2:t}, ${3:timer}, ${4:msg});"
        ],
        "description": "[Class:apci_device_util]\n virtual task wait_rx_dllp(int port_id,\n apci_dllp_type t,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_device_util :: msix_mask_unmask": {
        "prefix": [
            "msix_mask_unmask",
            "task:msix_mask_unmask -> apci_device_util"
        ],
        "body": [
            "msix_mask_unmask(${1:bdf}, ${2:is_mask}, ${3:int_vector}, ${4:err});"
        ],
        "description": "[Class:apci_device_util]\n virtual task msix_mask_unmask(apci_bdf_t bdf,\n bit is_mask,\n int int_vector,\n output bit err);    "
    },
    "apci_device_util :: get_interrupt_enabled": {
        "prefix": [
            "get_interrupt_enabled",
            "task:get_interrupt_enabled -> apci_device_util"
        ],
        "body": [
            "get_interrupt_enabled(${1:port_id}, ${2:func_id}, ${3:pin_enabled}, ${4:msi_enabled}, ${5:msix_enabled});"
        ],
        "description": "[Class:apci_device_util]\n virtual task get_interrupt_enabled(        input  int port_id     ,\n        input  int func_id     ,\n        output bit pin_enabled ,\n        output bit msi_enabled ,\n        output bit msix_enabled );    "
    },
    "apci_device_util :: clear_reg_interrupt_status": {
        "prefix": [
            "clear_reg_interrupt_status",
            "task:clear_reg_interrupt_status -> apci_device_util"
        ],
        "body": [
            "clear_reg_interrupt_status(${1:port_id}, ${2:func_id});"
        ],
        "description": "[Class:apci_device_util]\n virtual task clear_reg_interrupt_status (        input  int port_id     ,\n        input  int func_id);    "
    },
    "apci_device_util :: check_dev_type": {
        "prefix": [
            "check_dev_type",
            "function:check_dev_type -> apci_device_util"
        ],
        "body": [
            "check_dev_type(${1:dt}, ${2:msg});"
        ],
        "description": "[Class:apci_device_util]\n local function void check_dev_type(apci_device_type dt,\n string msg);    "
    },
    "apci_device_util :: convert_rw_size": {
        "prefix": [
            "convert_rw_size",
            "function:convert_rw_size -> apci_device_util"
        ],
        "body": [
            "convert_rw_size(${1:addr}, ${2:size}, ${3:dw_addr}, ${4:first_be}, ${5:last_be}, ${6:dw_size});"
        ],
        "description": "[Class:apci_device_util]\n virtual function void convert_rw_size(    input  bit       addr,\n             bit       size,\n      output bit       dw_addr,\n           bit       first_be,\n           bit       last_be,\n           int       dw_size    );    "
    },
    "apci_device_util :: dw_to_byte": {
        "prefix": [
            "dw_to_byte",
            "function:dw_to_byte -> apci_device_util"
        ],
        "body": [
            "dw_to_byte(${1:first_be}, ${2:last_be}, ${3:va}, ${4:ba});"
        ],
        "description": "[Class:apci_device_util]\n virtual function void dw_to_byte(    input  bit       first_be,\n           bit       last_be,\n    ref    bit       va      ,\n    output bit       ba          );    "
    },
    "apci_device_util :: byte_to_dw": {
        "prefix": [
            "byte_to_dw",
            "function:byte_to_dw -> apci_device_util"
        ],
        "body": [
            "byte_to_dw(${1:first_be}, ${2:last_be}, ${3:dw_size}, ${4:ba}, ${5:va});"
        ],
        "description": "[Class:apci_device_util]\n virtual function void byte_to_dw(    input  bit       first_be,\n           bit       last_be,\n           int       dw_size,\n           bit       ba      ,\n    ref    bit       va          );    "
    },
    "apci_device_util :: be_trace": {
        "prefix": [
            "be_trace",
            "function:be_trace -> apci_device_util"
        ],
        "body": [
            "be_trace(${1:be}, ${2:start}, ${3:limit});"
        ],
        "description": "[Class:apci_device_util]\n local function void be_trace(    input  bit       be,\n    output int     start,\n   int     limit    );    "
    },
    "apci_device_util :: rc_get_BDF_BAR": {
        "prefix": [
            "rc_get_BDF_BAR",
            "task:rc_get_BDF_BAR -> apci_device_util"
        ],
        "body": [
            "rc_get_BDF_BAR(${1:bdf2}, ${2:pcie_cap2}, ${3:start2}, ${4:total2});"
        ],
        "description": "[Class:apci_device_util]\n task rc_get_BDF_BAR(       input apci_bdf_t bdf2,\n    input apci_cap_type0 pcie_cap2,\n    input int start2= 0,\n       input int total2= 1);       "
    },
    "apci_device_util :: send_doe_data": {
        "prefix": [
            "send_doe_data",
            "task:send_doe_data -> apci_device_util"
        ],
        "body": [
            "send_doe_data(${1:bdf}, ${2:doe_cap}, ${3:dd}, ${4:wait_response});"
        ],
        "description": "[Class:apci_device_util]\n task send_doe_data(apci_bdf_t bdf,\n apci_cap_doe doe_cap,\n apci_doe_data dd,\n bit wait_response = 1);    "
    },
    "apci_device_util :: fetch_doe_data": {
        "prefix": [
            "fetch_doe_data",
            "task:fetch_doe_data -> apci_device_util"
        ],
        "body": [
            "fetch_doe_data(${1:bdf}, ${2:cap}, ${3:req}, ${4:rsp}, ${5:err});"
        ],
        "description": "[Class:apci_device_util]\n task fetch_doe_data(apci_bdf_t bdf,\n apci_cap_doe cap,\n apci_doe_data req,\n output apci_doe_data rsp,\n bit err);    "
    },
    "apci_device_util :: do_doe_discovery": {
        "prefix": [
            "do_doe_discovery",
            "task:do_doe_discovery -> apci_device_util"
        ],
        "body": [
            "do_doe_discovery(${1:bdf}, ${2:doe_cap}, ${3:d_table}, ${4:err});"
        ],
        "description": "[Class:apci_device_util]\n task do_doe_discovery(apci_bdf_t bdf,\n apci_cap_doe doe_cap,\n output apci_doe_discovery_table d_table,\n bit err);    "
    },
    "apci_device_util :: do_doe_cdat_search": {
        "prefix": [
            "do_doe_cdat_search",
            "task:do_doe_cdat_search -> apci_device_util"
        ],
        "body": [
            "do_doe_cdat_search(${1:bdf}, ${2:doe_cap}, ${3:cdat}, ${4:err});"
        ],
        "description": "[Class:apci_device_util]\n task do_doe_cdat_search(apci_bdf_t bdf,\n apci_cap_doe doe_cap,\n output acxl_coh_dev_attr_table cdat,\n bit err);    "
    },
    "apci_device_util :: send_cxl_device_cmd": {
        "prefix": [
            "send_cxl_device_cmd",
            "task:send_cxl_device_cmd -> apci_device_util"
        ],
        "body": [
            "send_cxl_device_cmd(${1:cmd});"
        ],
        "description": "[Class:apci_device_util]\n task send_cxl_device_cmd(acxl_device_cmd cmd);    "
    },
    "apci_device_util :: cfgwr_wait_done": {
        "prefix": [
            "cfgwr_wait_done",
            "task:cfgwr_wait_done -> apci_device_util"
        ],
        "body": [
            "cfgwr_wait_done(${1:bdf}, ${2:offset}, ${3:v}, ${4:err}, ${5:dbg});"
        ],
        "description": "[Class:apci_device_util]\n local task cfgwr_wait_done(apci_bdf_t bdf,\n avery_u16 offset,\n avery_u32 v,\n output bit err,\n input string dbg=\"\");    "
    },
    "apci_device_util :: cfgrd_wait_done": {
        "prefix": [
            "cfgrd_wait_done",
            "task:cfgrd_wait_done -> apci_device_util"
        ],
        "body": [
            "cfgrd_wait_done(${1:bdf}, ${2:offset}, ${3:v}, ${4:err}, ${5:dbg});"
        ],
        "description": "[Class:apci_device_util]\n local task cfgrd_wait_done(apci_bdf_t bdf,\n avery_u16 offset,\n output avery_u32 v,\n output bit err,\n input string dbg=\"\");    "
    },
    "clk_rate_2_period": {
        "prefix": [
            "clk_rate_2_period",
            "function:clk_rate_2_period"
        ],
        "body": [
            "clk_rate_2_period(${1:rate});"
        ],
        "description": "function int clk_rate_2_period(int rate);    "
    },
    "ccix_clk_rate_2_period": {
        "prefix": [
            "ccix_clk_rate_2_period",
            "function:ccix_clk_rate_2_period"
        ],
        "body": [
            "ccix_clk_rate_2_period(${1:rate});"
        ],
        "description": "function int ccix_clk_rate_2_period(int rate);    "
    },
    "to_dataBusWidth": {
        "prefix": [
            "to_dataBusWidth",
            "function:to_dataBusWidth"
        ],
        "body": [
            "to_dataBusWidth(${1:n_bytes});"
        ],
        "description": "function int to_dataBusWidth(int n_bytes);    "
    },
    "a_reset": {
        "prefix": [
            "a_reset",
            "task:a_reset"
        ],
        "body": [
            "a_reset(${0:});"
        ],
        "description": "task a_reset();    "
    },
    "is_start_sos": {
        "prefix": [
            "is_start_sos",
            "function:is_start_sos"
        ],
        "body": [
            "is_start_sos(${1:sym});"
        ],
        "description": "function bit is_start_sos(ebuf_data_t  sym);    "
    },
    "dbg_phy_rx": {
        "prefix": [
            "dbg_phy_rx",
            "task:dbg_phy_rx"
        ],
        "body": [
            "dbg_phy_rx(${0:});"
        ],
        "description": "task dbg_phy_rx();    "
    },
    "apci_test_info": {
        "prefix": "apci_test_info",
        "body": [
            "apci_test_info  ${0:name_class};"
        ],
        "description": "class apci_test_info;\n"
    },
    "apci_test_info :: new": {
        "prefix": [
            "new",
            "function:new -> apci_test_info"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_test_info]\n     function new(string name = \"apci_test_info\");    "
    },
    "apci_test_info :: add_dut": {
        "prefix": [
            "add_dut",
            "function:add_dut -> apci_test_info"
        ],
        "body": [
            "add_dut(${1:vendor_id}, ${2:device_id});"
        ],
        "description": "[Class:apci_test_info]\n     virtual function void add_dut(int vendor_id,\n int device_id);    "
    },
    "apci_test_info :: is_dut": {
        "prefix": [
            "is_dut",
            "function:is_dut -> apci_test_info"
        ],
        "body": [
            "is_dut(${1:vendor_id}, ${2:device_id});"
        ],
        "description": "[Class:apci_test_info]\n     virtual function bit is_dut(int vendor_id,\n int device_id);    "
    },
    "apci_test_info :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_test_info"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_test_info]\n     virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_callbacks": {
        "prefix": "apci_callbacks",
        "body": [
            "apci_callbacks  ${0:name_class};"
        ],
        "description": "virtual class apci_callbacks extends apci_callbacks_base;\n"
    },
    "apci_callbacks :: setup_cfg_space": {
        "prefix": [
            "setup_cfg_space",
            "function:setup_cfg_space -> apci_callbacks"
        ],
        "body": [
            "setup_cfg_space(${1:bfm}, ${2:csp});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void setup_cfg_space(    input apci_device      bfm,\n    input apci_cfg_space   csp);return;    "
    },
    "apci_callbacks :: setup_mmio_reg": {
        "prefix": [
            "setup_mmio_reg",
            "function:setup_mmio_reg -> apci_callbacks"
        ],
        "body": [
            "setup_mmio_reg(${1:bfm}, ${2:mmreg});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void setup_mmio_reg(    input apci_device      bfm,\n    input apci_mmio_reg    mmreg );return;    "
    },
    "apci_callbacks :: pre_enum_wait_user": {
        "prefix": [
            "pre_enum_wait_user",
            "task:pre_enum_wait_user -> apci_callbacks"
        ],
        "body": [
            "pre_enum_wait_user(${1:bfm});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual task pre_enum_wait_user(input apci_device bfm);    "
    },
    "apci_callbacks :: pre_enum_phase0": {
        "prefix": [
            "pre_enum_phase0",
            "function:pre_enum_phase0 -> apci_callbacks"
        ],
        "body": [
            "pre_enum_phase0(${1:bfm}, ${2:bus}, ${3:skip_enum});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void pre_enum_phase0(    input apci_device  bfm,\n    input bit           bus,\n    inout bit          skip_enum   );return;    "
    },
    "apci_callbacks :: pre_enum_phase1": {
        "prefix": [
            "pre_enum_phase1",
            "function:pre_enum_phase1 -> apci_callbacks"
        ],
        "body": [
            "pre_enum_phase1(${1:bfm}, ${2:dmgr}, ${3:bdf}, ${4:skip_enum});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void pre_enum_phase1(    apci_device     bfm,\n    apci_device_mgr dmgr,\n    apci_bdf_t      bdf,\n    inout bit       skip_enum);return;    "
    },
    "apci_callbacks :: enum_done": {
        "prefix": [
            "enum_done",
            "function:enum_done -> apci_callbacks"
        ],
        "body": [
            "enum_done(${1:bfm}, ${2:mgr});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void enum_done(    input apci_device     bfm,\n    input apci_device_mgr mgr);return;    "
    },
    "apci_callbacks :: enum_done_wait_user": {
        "prefix": [
            "enum_done_wait_user",
            "task:enum_done_wait_user -> apci_callbacks"
        ],
        "body": [
            "enum_done_wait_user(${1:bfm}, ${2:mgrs});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual task enum_done_wait_user(    input apci_device     bfm,\n    input apci_device_mgr mgrs      );return;    "
    },
    "apci_callbacks :: read_mem_cb": {
        "prefix": [
            "read_mem_cb",
            "function:read_mem_cb -> apci_callbacks"
        ],
        "body": [
            "read_mem_cb(${1:is_host_mem}, ${2:addr}, ${3:ndw}, ${4:first_be}, ${5:last_be}, ${6:va}, ${7:src});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void read_mem_cb(    input bit             is_host_mem,\n    input bit             addr    ,\n    input bit             ndw     ,\n    input bit              first_be,\n    input bit              last_be ,\n    ref   bit             va      ,\n    input avery_data_base src);    "
    },
    "apci_callbacks :: write_mem_cb": {
        "prefix": [
            "write_mem_cb",
            "function:write_mem_cb -> apci_callbacks"
        ],
        "body": [
            "write_mem_cb(${1:is_host_mem}, ${2:addr}, ${3:first_be}, ${4:last_be}, ${5:va}, ${6:src});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void write_mem_cb(            input bit             is_host_mem,\n            input bit             addr       ,\n            input bit              first_be   ,\n            input bit              last_be    ,\n    ref   bit             va             ,\n    input avery_data_base src         );    "
    },
    "apci_callbacks :: rx_interrupt": {
        "prefix": [
            "rx_interrupt",
            "function:rx_interrupt -> apci_callbacks"
        ],
        "body": [
            "rx_interrupt(${1:rc}, ${2:irq});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_interrupt(        apci_device  rc,\n    ref apci_irq_t   irq);return;    "
    },
    "apci_callbacks :: tx_transaction_done": {
        "prefix": [
            "tx_transaction_done",
            "function:tx_transaction_done -> apci_callbacks"
        ],
        "body": [
            "tx_transaction_done(${1:bfm}, ${2:tr});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_transaction_done(    apci_device      bfm,\n    apci_transaction tr);return;    "
    },
    "apci_callbacks :: tx_create_cpl": {
        "prefix": [
            "tx_create_cpl",
            "function:tx_create_cpl -> apci_callbacks"
        ],
        "body": [
            "tx_create_cpl(${1:bfm}, ${2:req}, ${3:cpl}, ${4:ith_split}, ${5:mps_dw}, ${6:rcb_dw}, ${7:delay_ns});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_create_cpl(    input apci_device bfm      ,\n    input apci_tlp    req      ,\n    input apci_tlp    cpl      ,\n    input int         ith_split,\n    input int         mps_dw   ,\n    input int         rcb_dw   ,\n    inout int         delay_ns  );return;    "
    },
    "apci_callbacks :: tx_pkt_exit_tl": {
        "prefix": [
            "tx_pkt_exit_tl",
            "function:tx_pkt_exit_tl -> apci_callbacks"
        ],
        "body": [
            "tx_pkt_exit_tl(${1:bfm}, ${2:tlp});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_pkt_exit_tl(    apci_device   bfm,\n    apci_tlp      tlp);return;    "
    },
    "apci_callbacks :: tx_pkt_exit_dll": {
        "prefix": [
            "tx_pkt_exit_dll",
            "function:tx_pkt_exit_dll -> apci_callbacks"
        ],
        "body": [
            "tx_pkt_exit_dll(${1:bfm}, ${2:pkt});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_pkt_exit_dll(    apci_device      bfm,\n    apci_packet      pkt);return;    "
    },
    "apci_callbacks :: tx_pkt_exit_mac": {
        "prefix": [
            "tx_pkt_exit_mac",
            "function:tx_pkt_exit_mac -> apci_callbacks"
        ],
        "body": [
            "tx_pkt_exit_mac(${1:bfm}, ${2:pkt});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_pkt_exit_mac(    apci_device      bfm,\n    apci_packet      pkt);return;    "
    },
    "apci_callbacks :: tx_pkt_enter_lane": {
        "prefix": [
            "tx_pkt_enter_lane",
            "function:tx_pkt_enter_lane -> apci_callbacks"
        ],
        "body": [
            "tx_pkt_enter_lane(${1:bfm}, ${2:port_id}, ${3:pkts}, ${4:syms}, ${5:os_after}, ${6:block128_index});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_pkt_enter_lane(    input apci_device    bfm,\n    input int            port_id,\n    ref   apci_packet    pkts      ,\n    ref   apci_raw_sym_t syms      ,\n    ref   apci_os        os_after,\n           input int            block128_index);return;    "
    },
    "apci_callbacks :: tx_os_enter_lane": {
        "prefix": [
            "tx_os_enter_lane",
            "function:tx_os_enter_lane -> apci_callbacks"
        ],
        "body": [
            "tx_os_enter_lane(${1:bfm}, ${2:port_id}, ${3:active_oses}, ${4:inactive_oses});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_os_enter_lane(    input apci_device   bfm,\n    input int           port_id,\n    ref   apci_os       active_oses      ,\n    ref   apci_os       inactive_oses      );return;    "
    },
    "apci_callbacks :: rx_os_enter_lane": {
        "prefix": [
            "rx_os_enter_lane",
            "function:rx_os_enter_lane -> apci_callbacks"
        ],
        "body": [
            "rx_os_enter_lane(${1:bfm}, ${2:logic_lane_num}, ${3:os});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_os_enter_lane(    apci_device  bfm,\n    int          logic_lane_num,\n    apci_os      os);return;    "
    },
    "apci_callbacks :: rx_pkt_enter_mac": {
        "prefix": [
            "rx_pkt_enter_mac",
            "function:rx_pkt_enter_mac -> apci_callbacks"
        ],
        "body": [
            "rx_pkt_enter_mac(${1:bfm}, ${2:pkt});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_pkt_enter_mac(    apci_device  bfm,\n    apci_packet  pkt );return;    "
    },
    "apci_callbacks :: rx_pkt_enter_dll": {
        "prefix": [
            "rx_pkt_enter_dll",
            "function:rx_pkt_enter_dll -> apci_callbacks"
        ],
        "body": [
            "rx_pkt_enter_dll(${1:bfm}, ${2:pkt});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_pkt_enter_dll(    apci_device  bfm,\n    apci_packet  pkt );return;    "
    },
    "apci_callbacks :: rx_pkt_enter_tl": {
        "prefix": [
            "rx_pkt_enter_tl",
            "function:rx_pkt_enter_tl -> apci_callbacks"
        ],
        "body": [
            "rx_pkt_enter_tl(${1:bfm}, ${2:tlp});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_pkt_enter_tl(    apci_device  bfm,\n    apci_tlp     tlp);return;    "
    },
    "apci_callbacks :: commit_data": {
        "prefix": [
            "commit_data",
            "function:commit_data -> apci_callbacks"
        ],
        "body": [
            "commit_data(${1:host});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void commit_data(    apci_device   host);return;    "
    },
    "apci_callbacks :: tx_sym_before_scramble": {
        "prefix": [
            "tx_sym_before_scramble",
            "function:tx_sym_before_scramble -> apci_callbacks"
        ],
        "body": [
            "tx_sym_before_scramble(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:raw});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_sym_before_scramble(            input apci_device    bfm           ,\n            input int            port_id       ,\n            input int            logic_lane_num,\n            inout apci_raw_sym_t raw            );    "
    },
    "apci_callbacks :: tx_sym_after_scramble": {
        "prefix": [
            "tx_sym_after_scramble",
            "function:tx_sym_after_scramble -> apci_callbacks"
        ],
        "body": [
            "tx_sym_after_scramble(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:raw});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_sym_after_scramble(                  apci_device    bfm           ,\n                  int            port_id       ,\n                  int            logic_lane_num,\n            inout apci_raw_sym_t raw            );    "
    },
    "apci_callbacks :: rx_sym_before_scramble": {
        "prefix": [
            "rx_sym_before_scramble",
            "function:rx_sym_before_scramble -> apci_callbacks"
        ],
        "body": [
            "rx_sym_before_scramble(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:sym}, ${5:os_type}, ${6:os_index});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_sym_before_scramble(            input apci_device    bfm           ,\n            input int            port_id       ,\n            input int            logic_lane_num,\n            inout bit             sym           ,\n    input apci_os_type   os_type       ,\n    input bit             os_index      );    "
    },
    "apci_callbacks :: rx_sym_after_scramble": {
        "prefix": [
            "rx_sym_after_scramble",
            "function:rx_sym_after_scramble -> apci_callbacks"
        ],
        "body": [
            "rx_sym_after_scramble(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:sym}, ${5:os_type}, ${6:os_index});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_sym_after_scramble(            input apci_device    bfm           ,\n            input int            port_id       ,\n            input int            logic_lane_num,\n            inout bit             sym           ,\n    input apci_os_type   os_type       ,\n    input bit             os_index      );    "
    },
    "apci_callbacks :: start_acknak_latency_timer": {
        "prefix": [
            "start_acknak_latency_timer",
            "function:start_acknak_latency_timer -> apci_callbacks"
        ],
        "body": [
            "start_acknak_latency_timer(${1:bfm}, ${2:latency_limit}, ${3:speed}, ${4:mps}, ${5:linkwidth}, ${6:latency});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void start_acknak_latency_timer(                  apci_device bfm    ,\n                  int   latency_limit,\n                  int   speed        ,\n                  int   mps          ,\n                  int   linkwidth    ,\n            inout int   latency               );    "
    },
    "apci_callbacks :: ltssm_transition": {
        "prefix": [
            "ltssm_transition",
            "function:ltssm_transition -> apci_callbacks"
        ],
        "body": [
            "ltssm_transition(${1:bfm}, ${2:port_id}, ${3:from}, ${4:to});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void ltssm_transition (                  apci_device        bfm    ,\n                   int                port_id,\n                   apci_ltssm_state_e from   ,\n                   apci_ltssm_state_e to       );    "
    },
    "apci_callbacks :: equalization_check_coef": {
        "prefix": [
            "equalization_check_coef",
            "function:equalization_check_coef -> apci_callbacks"
        ],
        "body": [
            "equalization_check_coef(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:fs}, ${5:lf}, ${6:use_preset}, ${7:preset}, ${8:postcc}, ${9:cc}, ${10:precc}, ${11:sec_precc}, ${12:reject});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void equalization_check_coef (          apci_device bfm           ,\n          int         port_id       ,\n          int         logic_lane_num,\n          byte        fs            ,\n          byte        lf            ,\n          bit         use_preset    ,\n    inout byte        preset        ,\n    inout bit          postcc        ,\n    inout bit          cc            ,\n    inout bit          precc         ,\n    inout bit          sec_precc     ,\n    inout bit         reject);    "
    },
    "apci_callbacks :: equalization_request_coef": {
        "prefix": [
            "equalization_request_coef",
            "function:equalization_request_coef -> apci_callbacks"
        ],
        "body": [
            "equalization_request_coef(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:fs}, ${5:lf}, ${6:use_preset}, ${7:preset}, ${8:postcc}, ${9:cc}, ${10:precc}, ${11:sec_precc});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void equalization_request_coef (          apci_device bfm           ,\n          int         port_id       ,\n          int         logic_lane_num,\n          byte        fs            ,\n          byte        lf            ,\n    inout bit         use_preset    ,\n    inout byte        preset        ,\n    inout bit          postcc        ,\n    inout bit          cc            ,\n    inout bit          precc         ,\n    inout bit          sec_precc);    "
    },
    "apci_callbacks :: rx_margin_cmd_before_update": {
        "prefix": [
            "rx_margin_cmd_before_update",
            "function:rx_margin_cmd_before_update -> apci_callbacks"
        ],
        "body": [
            "rx_margin_cmd_before_update(${1:bfm}, ${2:logic_lane_num}, ${3:cmd});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_margin_cmd_before_update(            apci_device     bfm,\n            int             logic_lane_num,\n            apci_margin_cmd cmd        );      return;    "
    },
    "apci_callbacks :: mon_tx_os_enter_lane": {
        "prefix": [
            "mon_tx_os_enter_lane",
            "function:mon_tx_os_enter_lane -> apci_callbacks"
        ],
        "body": [
            "mon_tx_os_enter_lane(${1:bfm}, ${2:logic_lane_num}, ${3:os});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void mon_tx_os_enter_lane(    apci_device  bfm,\n    int          logic_lane_num,\n    apci_os      os);return;    "
    },
    "apci_callbacks :: tx_pkt_after_encrypt": {
        "prefix": [
            "tx_pkt_after_encrypt",
            "function:tx_pkt_after_encrypt -> apci_callbacks"
        ],
        "body": [
            "tx_pkt_after_encrypt(${1:bfm}, ${2:tlp});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_pkt_after_encrypt(            apci_device  bfm,\n            apci_tlp     tlp        );      return;    "
    },
    "apci_callbacks :: tx_flit_exit_dll": {
        "prefix": [
            "tx_flit_exit_dll",
            "function:tx_flit_exit_dll -> apci_callbacks"
        ],
        "body": [
            "tx_flit_exit_dll(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_flit_exit_dll(    apci_device   bfm,\n    apci_flit     flit );  return;    "
    },
    "apci_callbacks :: tx_flit_exit_mac": {
        "prefix": [
            "tx_flit_exit_mac",
            "function:tx_flit_exit_mac -> apci_callbacks"
        ],
        "body": [
            "tx_flit_exit_mac(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void tx_flit_exit_mac(    apci_device   bfm,\n    apci_flit     flit );  return;    "
    },
    "apci_callbacks :: rx_flit_enter_mac": {
        "prefix": [
            "rx_flit_enter_mac",
            "function:rx_flit_enter_mac -> apci_callbacks"
        ],
        "body": [
            "rx_flit_enter_mac(${1:bfm}, ${2:flit});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_flit_enter_mac(    apci_device   bfm,\n    apci_flit     flit );  return;    "
    },
    "apci_callbacks :: rx_doe_data": {
        "prefix": [
            "rx_doe_data",
            "function:rx_doe_data -> apci_callbacks"
        ],
        "body": [
            "rx_doe_data(${1:bfm}, ${2:bdf}, ${3:rx_dwords}, ${4:user_tx_dwords});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual function void rx_doe_data(            input apci_device bfm,\n    input apci_bdf_t  bdf,\n            ref   bit         rx_dwords      ,\n            ref   bit         user_tx_dwords              );      return;    "
    },
    "apci_callbacks :: rx_device_cmd": {
        "prefix": [
            "rx_device_cmd",
            "task:rx_device_cmd -> apci_callbacks"
        ],
        "body": [
            "rx_device_cmd(${1:bfm}, ${2:cmd});"
        ],
        "description": "[Class:apci_callbacks]\n     virtual task rx_device_cmd (            input apci_device     bfm,\n    input acxl_device_cmd cmd        );      return;    "
    },
    "get_sym_time": {
        "prefix": [
            "get_sym_time",
            "function:get_sym_time"
        ],
        "body": [
            "get_sym_time(${1:rate});"
        ],
        "description": "function real get_sym_time(byte rate);     "
    },
    "get_total_skew": {
        "prefix": [
            "get_total_skew",
            "function:get_total_skew"
        ],
        "body": [
            "get_total_skew(${1:skew});"
        ],
        "description": "function int get_total_skew(int skew);    "
    },
    "acxl_coverage_sampler": {
        "prefix": "acxl_coverage_sampler",
        "body": [
            "acxl_coverage_sampler  ${0:name_class};"
        ],
        "description": "class acxl_coverage_sampler extends avery_data_base;\n"
    },
    "acxl_coverage_sampler :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_coverage_sampler"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_coverage_sampler]\n     function new(string name = \"acxl_coverage_sampler\");    "
    },
    "acxl_coverage_sampler :: sample_cxl_msg": {
        "prefix": [
            "sample_cxl_msg",
            "function:sample_cxl_msg -> acxl_coverage_sampler"
        ],
        "body": [
            "sample_cxl_msg(${1:m});"
        ],
        "description": "[Class:acxl_coverage_sampler]\n     virtual function void sample_cxl_msg(acxl_msg m);    "
    },
    "acxl_coverage_sampler :: sample_flit": {
        "prefix": [
            "sample_flit",
            "function:sample_flit -> acxl_coverage_sampler"
        ],
        "body": [
            "sample_flit(${1:f}, ${2:cxl_host_tx});"
        ],
        "description": "[Class:acxl_coverage_sampler]\n     virtual function void sample_flit(acxl_flit f,\n bit cxl_host_tx);    "
    },
    "acxl_coverage_sampler :: sample_vlsm_state": {
        "prefix": [
            "sample_vlsm_state",
            "function:sample_vlsm_state -> acxl_coverage_sampler"
        ],
        "body": [
            "sample_vlsm_state(${1:st});"
        ],
        "description": "[Class:acxl_coverage_sampler]\n     virtual function void sample_vlsm_state(acxl_vlsm_state_e st);    "
    },
    "apci_coverage_sampler": {
        "prefix": "apci_coverage_sampler",
        "body": [
            "apci_coverage_sampler  ${0:name_class};"
        ],
        "description": "class apci_coverage_sampler extends avery_data_base;\n"
    },
    "apci_coverage_sampler :: new": {
        "prefix": [
            "new",
            "function:new -> apci_coverage_sampler"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_coverage_sampler]\n     function new(string name = \"apci_coverage_sampler\");    "
    },
    "apci_coverage_sampler :: sample_tlp_at_dll": {
        "prefix": [
            "sample_tlp_at_dll",
            "function:sample_tlp_at_dll -> apci_coverage_sampler"
        ],
        "body": [
            "sample_tlp_at_dll(${1:p});"
        ],
        "description": "[Class:apci_coverage_sampler]\n     virtual function void sample_tlp_at_dll(apci_packet p);    "
    },
    "apci_coverage_sampler :: sample_tlp_dllp": {
        "prefix": [
            "sample_tlp_dllp",
            "function:sample_tlp_dllp -> apci_coverage_sampler"
        ],
        "body": [
            "sample_tlp_dllp(${1:p});"
        ],
        "description": "[Class:apci_coverage_sampler]\n     virtual function void sample_tlp_dllp(apci_packet p);    "
    },
    "apci_coverage_sampler :: sample_os": {
        "prefix": [
            "sample_os",
            "function:sample_os -> apci_coverage_sampler"
        ],
        "body": [
            "sample_os(${1:os}, ${2:ltssm_state}, ${3:link_speed});"
        ],
        "description": "[Class:apci_coverage_sampler]\n     virtual function void sample_os(            apci_os            os         ,\n            apci_ltssm_state_e ltssm_state,\n            byte               link_speed);    "
    },
    "get_lf_fs_from_mac": {
        "prefix": [
            "get_lf_fs_from_mac",
            "task:get_lf_fs_from_mac"
        ],
        "body": [
            "get_lf_fs_from_mac(${0:});"
        ],
        "description": "task get_lf_fs_from_mac();    "
    },
    "random_setting": {
        "prefix": [
            "random_setting",
            "function:random_setting"
        ],
        "body": [
            "random_setting(${1:is_preset}, ${2:coef});"
        ],
        "description": "function void random_setting(bit is_preset,\n inout pset_coef_t coef);    "
    },
    "test_summary_register": {
        "prefix": [
            "test_summary_register",
            "function:test_summary_register"
        ],
        "body": [
            "test_summary_register(${1:c});"
        ],
        "description": "function void test_summary_register(avery_component c);    "
    },
    "test_summary": {
        "prefix": [
            "test_summary",
            "task:test_summary"
        ],
        "body": [
            "test_summary(${1:s}, ${2:reason}, ${3:test_name});"
        ],
        "description": "task test_summary( string s = \"UNKNOWN\",\n string reason=\"\",\n string test_name = \"\");    "
    },
    "apci_test_severity_register": {
        "prefix": [
            "apci_test_severity_register",
            "function:apci_test_severity_register"
        ],
        "body": [
            "apci_test_severity_register(${1:l});"
        ],
        "description": "function void apci_test_severity_register(apci_log l);    "
    },
    "apci_test_set_severity": {
        "prefix": [
            "apci_test_set_severity",
            "function:apci_test_set_severity"
        ],
        "body": [
            "apci_test_set_severity(${1:id}, ${2:v});"
        ],
        "description": "function void apci_test_set_severity(string id,\n avery_severity v);    "
    },
    "apci_test_report_register": {
        "prefix": [
            "apci_test_report_register",
            "function:apci_test_report_register"
        ],
        "body": [
            "apci_test_report_register(${1:b});"
        ],
        "description": "function void apci_test_report_register(apci_device b);    "
    },
    "apci_seq_report_register": {
        "prefix": [
            "apci_seq_report_register",
            "function:apci_seq_report_register"
        ],
        "body": [
            "apci_seq_report_register(${1:b});"
        ],
        "description": "function void apci_seq_report_register(apci_seq_common b);    "
    },
    "apci_test_report": {
        "prefix": [
            "apci_test_report",
            "task:apci_test_report"
        ],
        "body": [
            "apci_test_report(${1:t});"
        ],
        "description": "task apci_test_report(apci_testcase_base t);    "
    },
    "apci_test_select": {
        "prefix": [
            "apci_test_select",
            "task:apci_test_select"
        ],
        "body": [
            "apci_test_select(${1:test_name});"
        ],
        "description": "task automatic apci_test_select( string test_name = \"\");    "
    },
    "apci_test_select2": {
        "prefix": [
            "apci_test_select2",
            "function:apci_test_select2"
        ],
        "body": [
            "apci_test_select2(${1:testname});"
        ],
        "description": "function apci_testcase_base apci_test_select2(string testname);    "
    },
    "apci_test_select_check": {
        "prefix": [
            "apci_test_select_check",
            "task:apci_test_select_check"
        ],
        "body": [
            "apci_test_select_check(${0:});"
        ],
        "description": "task apci_test_select_check();    "
    },
    "apci_seq_common": {
        "prefix": "apci_seq_common",
        "body": [
            "apci_seq_common  ${0:name_class};"
        ],
        "description": "class apci_seq_common extends apci_seq_base;\n"
    },
    "apci_seq_common :: new": {
        "prefix": [
            "new",
            "function:new -> apci_seq_common"
        ],
        "body": [
            "new(${1:bfm}, ${2:rc_app_bfm}, ${3:target}, ${4:scope});"
        ],
        "description": "[Class:apci_seq_common]\n     function new (apci_device bfm    = null,\n   apci_device rc_app_bfm    = null,\n   apci_device target    = null,\n   string scope = \"\");    "
    },
    "apci_seq_common :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_seq_common"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:apci_seq_common]\n     function apci_seq_common copy (apci_seq_common to = null);    "
    },
    "apci_seq_common :: run": {
        "prefix": [
            "run",
            "task:run -> apci_seq_common"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:apci_seq_common]\n     virtual task run();    "
    },
    "apci_seq_common :: before_run": {
        "prefix": [
            "before_run",
            "task:before_run -> apci_seq_common"
        ],
        "body": [
            "before_run(${0:});"
        ],
        "description": "[Class:apci_seq_common]\n     virtual task before_run();    "
    },
    "apci_seq_common :: run_body": {
        "prefix": [
            "run_body",
            "task:run_body -> apci_seq_common"
        ],
        "body": [
            "run_body(${0:});"
        ],
        "description": "[Class:apci_seq_common]\n     virtual task run_body();    "
    },
    "apci_seq_common :: end_messages": {
        "prefix": [
            "end_messages",
            "function:end_messages -> apci_seq_common"
        ],
        "body": [
            "end_messages(${1:s});"
        ],
        "description": "[Class:apci_seq_common]\n     virtual function void end_messages(output string s);    "
    },
    "apci_seq_common :: after_run": {
        "prefix": [
            "after_run",
            "task:after_run -> apci_seq_common"
        ],
        "body": [
            "after_run(${0:});"
        ],
        "description": "[Class:apci_seq_common]\n     virtual task after_run();    "
    },
    "apci_seq_common :: seq_info": {
        "prefix": [
            "seq_info",
            "function:seq_info -> apci_seq_common"
        ],
        "body": [
            "seq_info(${1:s});"
        ],
        "description": "[Class:apci_seq_common]\n     function void seq_info(string s);    "
    },
    "apci_seq_common :: seq_error": {
        "prefix": [
            "seq_error",
            "function:seq_error -> apci_seq_common"
        ],
        "body": [
            "seq_error(${1:s});"
        ],
        "description": "[Class:apci_seq_common]\n     function void seq_error(string s);    "
    },
    "apci_seq_common :: seq_debug": {
        "prefix": [
            "seq_debug",
            "function:seq_debug -> apci_seq_common"
        ],
        "body": [
            "seq_debug(${1:s});"
        ],
        "description": "[Class:apci_seq_common]\n     function void seq_debug(string s);    "
    },
    "apci_seq_common :: seq_warn": {
        "prefix": [
            "seq_warn",
            "function:seq_warn -> apci_seq_common"
        ],
        "body": [
            "seq_warn(${1:s});"
        ],
        "description": "[Class:apci_seq_common]\n     function void seq_warn(string s);    "
    },
    "apci_seq_common :: seq_usage": {
        "prefix": [
            "seq_usage",
            "function:seq_usage -> apci_seq_common"
        ],
        "body": [
            "seq_usage(${1:s});"
        ],
        "description": "[Class:apci_seq_common]\n     function void seq_usage(string s);    "
    },
    "apci_seq_common :: seq_print_history": {
        "prefix": [
            "seq_print_history",
            "function:seq_print_history -> apci_seq_common"
        ],
        "body": [
            "seq_print_history(${0:});"
        ],
        "description": "[Class:apci_seq_common]\n     function void seq_print_history();    "
    },
    "apci_testcase_container": {
        "prefix": "apci_testcase_container",
        "body": [
            "apci_testcase_container  ${0:name_class};"
        ],
        "description": "class apci_testcase_container;\n"
    },
    "apci_testcase_base": {
        "prefix": "apci_testcase_base",
        "body": [
            "apci_testcase_base  ${0:name_class};"
        ],
        "description": "class apci_testcase_base;\n"
    },
    "apci_testcase_base :: new": {
        "prefix": [
            "new",
            "function:new -> apci_testcase_base"
        ],
        "body": [
            "new(${1:test_name});"
        ],
        "description": "[Class:apci_testcase_base]\n     function new(string test_name);    "
    },
    "apci_testcase_base :: grab_test": {
        "prefix": [
            "grab_test",
            "function:grab_test -> apci_testcase_base"
        ],
        "body": [
            "grab_test(${1:t});"
        ],
        "description": "[Class:apci_testcase_base]\n     static function apci_testcase_base grab_test(ref string t);    "
    },
    "apci_testcase_base :: add_rc": {
        "prefix": [
            "add_rc",
            "function:add_rc -> apci_testcase_base"
        ],
        "body": [
            "add_rc(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_rc(apci_device h);    "
    },
    "apci_testcase_base :: add_sw": {
        "prefix": [
            "add_sw",
            "function:add_sw -> apci_testcase_base"
        ],
        "body": [
            "add_sw(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_sw(apci_device h);    "
    },
    "apci_testcase_base :: add_ep": {
        "prefix": [
            "add_ep",
            "function:add_ep -> apci_testcase_base"
        ],
        "body": [
            "add_ep(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_ep(apci_device h);    "
    },
    "apci_testcase_base :: add_bfm": {
        "prefix": [
            "add_bfm",
            "function:add_bfm -> apci_testcase_base"
        ],
        "body": [
            "add_bfm(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_bfm(apci_device h);    "
    },
    "apci_testcase_base :: add_rc_app_bfm": {
        "prefix": [
            "add_rc_app_bfm",
            "function:add_rc_app_bfm -> apci_testcase_base"
        ],
        "body": [
            "add_rc_app_bfm(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_rc_app_bfm(apci_device h);    "
    },
    "apci_testcase_base :: add_dut1_bfm": {
        "prefix": [
            "add_dut1_bfm",
            "function:add_dut1_bfm -> apci_testcase_base"
        ],
        "body": [
            "add_dut1_bfm(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_dut1_bfm(apci_device h);    "
    },
    "apci_testcase_base :: add_dut_pif": {
        "prefix": [
            "add_dut_pif",
            "function:add_dut_pif -> apci_testcase_base"
        ],
        "body": [
            "add_dut_pif(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_dut_pif(virtual apci_pipe_intf h      );    "
    },
    "apci_testcase_base :: add_dut_cxl_seq": {
        "prefix": [
            "add_dut_cxl_seq",
            "function:add_dut_cxl_seq -> apci_testcase_base"
        ],
        "body": [
            "add_dut_cxl_seq(${1:h});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void add_dut_cxl_seq(acxl_dut_seq h);    "
    },
    "apci_testcase_base :: set_severity_except_myself": {
        "prefix": [
            "set_severity_except_myself",
            "function:set_severity_except_myself -> apci_testcase_base"
        ],
        "body": [
            "set_severity_except_myself(${1:bfm}, ${2:id}, ${3:serverity});"
        ],
        "description": "[Class:apci_testcase_base]\n     function void set_severity_except_myself(apci_device bfm,\n apci_chklist_id_e id,\n avery_severity serverity);    "
    },
    "apci_testcase_base :: pre_bfm_started": {
        "prefix": [
            "pre_bfm_started",
            "task:pre_bfm_started -> apci_testcase_base"
        ],
        "body": [
            "pre_bfm_started(${0:});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task pre_bfm_started();    "
    },
    "apci_testcase_base :: run": {
        "prefix": [
            "run",
            "task:run -> apci_testcase_base"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task run();    "
    },
    "apci_testcase_base :: wait_eps": {
        "prefix": [
            "wait_eps",
            "task:wait_eps -> apci_testcase_base"
        ],
        "body": [
            "wait_eps(${1:configured}, ${2:how_many});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task wait_eps(bit configured = 0,\n                          int how_many = 0);    "
    },
    "apci_testcase_base :: test_body": {
        "prefix": [
            "test_body",
            "task:test_body -> apci_testcase_base"
        ],
        "body": [
            "test_body(${0:});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task test_body();    "
    },
    "apci_testcase_base :: test_body_per_bfm_sequential": {
        "prefix": [
            "test_body_per_bfm_sequential",
            "task:test_body_per_bfm_sequential -> apci_testcase_base"
        ],
        "body": [
            "test_body_per_bfm_sequential(${1:bfm});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task test_body_per_bfm_sequential(apci_device bfm);    "
    },
    "apci_testcase_base :: test_body_per_bfm_parallel": {
        "prefix": [
            "test_body_per_bfm_parallel",
            "task:test_body_per_bfm_parallel -> apci_testcase_base"
        ],
        "body": [
            "test_body_per_bfm_parallel(${1:bfm});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task test_body_per_bfm_parallel(apci_device bfm);    "
    },
    "apci_testcase_base :: collect_coverage": {
        "prefix": [
            "collect_coverage",
            "task:collect_coverage -> apci_testcase_base"
        ],
        "body": [
            "collect_coverage(${0:});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task collect_coverage();    "
    },
    "apci_testcase_base :: wrapup": {
        "prefix": [
            "wrapup",
            "task:wrapup -> apci_testcase_base"
        ],
        "body": [
            "wrapup(${0:});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual task wrapup();                                                                           "
    },
    "apci_testcase_base :: find_controller_bfm": {
        "prefix": [
            "find_controller_bfm",
            "function:find_controller_bfm -> apci_testcase_base"
        ],
        "body": [
            "find_controller_bfm(${1:ep_id});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual function apci_device find_controller_bfm(int ep_id);    "
    },
    "apci_testcase_base :: sprint_topology": {
        "prefix": [
            "sprint_topology",
            "function:sprint_topology -> apci_testcase_base"
        ],
        "body": [
            "sprint_topology(${1:prefix});"
        ],
        "description": "[Class:apci_testcase_base]\n     virtual function string sprint_topology(string prefix = \"\\t\");    "
    },
    "apci_cap_null": {
        "prefix": "apci_cap_null",
        "body": [
            "apci_cap_null  ${0:name_class};"
        ],
        "description": "class apci_cap_null extends apci_capability;\n"
    },
    "apci_cap_null :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_null"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_null]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_null :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_null"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_null]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_null :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_null"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_null]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_null :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_null"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_null]\n     function new(string name = \"apci_cap_null\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_null_ext": {
        "prefix": "apci_cap_null_ext",
        "body": [
            "apci_cap_null_ext  ${0:name_class};"
        ],
        "description": "class apci_cap_null_ext extends apci_capability;\n"
    },
    "apci_cap_null_ext :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_null_ext"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_null_ext]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_null_ext :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_null_ext"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_null_ext]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_null_ext :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_null_ext"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_null_ext]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_null_ext :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_null_ext"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_null_ext]\n     function new(string name = \"apci_cap_null_ext\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_null_ext :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_null_ext"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_null_ext]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_type0": {
        "prefix": "apci_cap_type0",
        "body": [
            "apci_cap_type0  ${0:name_class};"
        ],
        "description": "class apci_cap_type0 extends apci_capability;\n"
    },
    "apci_cap_type0 :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_type0"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_type0]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_type0 :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_type0"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_type0]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_type0 :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_type0"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_type0]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_type0 :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_type0"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_type0]\n     function void post_randomize();    "
    },
    "apci_cap_type0 :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_type0"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_type0]\n     function new(string name = \"apci_cap_type0\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_type0 :: collect_bar_ranges": {
        "prefix": [
            "collect_bar_ranges",
            "function:collect_bar_ranges -> apci_cap_type0"
        ],
        "body": [
            "collect_bar_ranges(${1:ranges}, ${2:expansion_rom}, ${3:vga_sup});"
        ],
        "description": "[Class:apci_cap_type0]\n     function void collect_bar_ranges(ref apci_bar_t ranges      ,\n input bit expansion_rom = 1,\n input vga_sup = 0);    "
    },
    "apci_cap_type1": {
        "prefix": "apci_cap_type1",
        "body": [
            "apci_cap_type1  ${0:name_class};"
        ],
        "description": "class apci_cap_type1 extends apci_capability;\n"
    },
    "apci_cap_type1 :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_type1"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_type1]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_type1 :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_type1"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_type1]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_type1 :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_type1"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_type1]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_type1 :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_type1"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_type1]\n     function new(string name = \"apci_cap_type1\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_type1 :: get_behind_io": {
        "prefix": [
            "get_behind_io",
            "function:get_behind_io -> apci_cap_type1"
        ],
        "body": [
            "get_behind_io(${1:base}, ${2:limit}, ${3:log});"
        ],
        "description": "[Class:apci_cap_type1]\n     function void get_behind_io(output avery_u32 base,\n avery_u32 limit,\n input apci_log log);    "
    },
    "apci_cap_type1 :: get_behind_mio": {
        "prefix": [
            "get_behind_mio",
            "function:get_behind_mio -> apci_cap_type1"
        ],
        "body": [
            "get_behind_mio(${1:base}, ${2:limit});"
        ],
        "description": "[Class:apci_cap_type1]\n     function void get_behind_mio(output avery_u32 base,\n avery_u32 limit);    "
    },
    "apci_cap_type1 :: get_behind_pref": {
        "prefix": [
            "get_behind_pref",
            "function:get_behind_pref -> apci_cap_type1"
        ],
        "body": [
            "get_behind_pref(${1:base}, ${2:limit});"
        ],
        "description": "[Class:apci_cap_type1]\n     function void get_behind_pref(output avery_u64 base,\n avery_u64 limit);    "
    },
    "apci_cap_type1 :: collect_bar_ranges": {
        "prefix": [
            "collect_bar_ranges",
            "function:collect_bar_ranges -> apci_cap_type1"
        ],
        "body": [
            "collect_bar_ranges(${1:ranges}, ${2:expansion_rom});"
        ],
        "description": "[Class:apci_cap_type1]\n     function void collect_bar_ranges(ref apci_bar_t ranges      ,\n input bit expansion_rom = 1);    "
    },
    "apci_cap_pcie": {
        "prefix": "apci_cap_pcie",
        "body": [
            "apci_cap_pcie  ${0:name_class};"
        ],
        "description": "class apci_cap_pcie extends apci_capability;\n"
    },
    "apci_cap_pcie :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pcie"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pcie]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pcie :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pcie"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pcie :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pcie"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pcie :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_pcie"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function void post_randomize();    "
    },
    "apci_cap_pcie :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pcie"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function new(string name = \"apci_cap_pcie\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pcie :: get_max_payload_size_sup": {
        "prefix": [
            "get_max_payload_size_sup",
            "function:get_max_payload_size_sup -> apci_cap_pcie"
        ],
        "body": [
            "get_max_payload_size_sup(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u16 get_max_payload_size_sup();    "
    },
    "apci_cap_pcie :: get_max_payload_size": {
        "prefix": [
            "get_max_payload_size",
            "function:get_max_payload_size -> apci_cap_pcie"
        ],
        "body": [
            "get_max_payload_size(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u16 get_max_payload_size();    "
    },
    "apci_cap_pcie :: get_max_payload_size_dw": {
        "prefix": [
            "get_max_payload_size_dw",
            "function:get_max_payload_size_dw -> apci_cap_pcie"
        ],
        "body": [
            "get_max_payload_size_dw(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u16 get_max_payload_size_dw();    "
    },
    "apci_cap_pcie :: get_max_read_req_size": {
        "prefix": [
            "get_max_read_req_size",
            "function:get_max_read_req_size -> apci_cap_pcie"
        ],
        "body": [
            "get_max_read_req_size(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u16 get_max_read_req_size();    "
    },
    "apci_cap_pcie :: get_max_read_req_size_dw": {
        "prefix": [
            "get_max_read_req_size_dw",
            "function:get_max_read_req_size_dw -> apci_cap_pcie"
        ],
        "body": [
            "get_max_read_req_size_dw(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u16 get_max_read_req_size_dw();    "
    },
    "apci_cap_pcie :: get_rcb_dw": {
        "prefix": [
            "get_rcb_dw",
            "function:get_rcb_dw -> apci_cap_pcie"
        ],
        "body": [
            "get_rcb_dw(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u16 get_rcb_dw();    "
    },
    "apci_cap_pcie :: get_cpl_timeout": {
        "prefix": [
            "get_cpl_timeout",
            "function:get_cpl_timeout -> apci_cap_pcie"
        ],
        "body": [
            "get_cpl_timeout(${0:});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function avery_u64 get_cpl_timeout();    "
    },
    "apci_cap_pcie :: dsp_set_link_bandwidth_mgmt_status": {
        "prefix": [
            "dsp_set_link_bandwidth_mgmt_status",
            "function:dsp_set_link_bandwidth_mgmt_status -> apci_cap_pcie"
        ],
        "body": [
            "dsp_set_link_bandwidth_mgmt_status(${1:v});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function void dsp_set_link_bandwidth_mgmt_status(bit v);    "
    },
    "apci_cap_pcie :: dsp_set_link_auto_bandwidth_status": {
        "prefix": [
            "dsp_set_link_auto_bandwidth_status",
            "function:dsp_set_link_auto_bandwidth_status -> apci_cap_pcie"
        ],
        "body": [
            "dsp_set_link_auto_bandwidth_status(${1:v});"
        ],
        "description": "[Class:apci_cap_pcie]\n     function void dsp_set_link_auto_bandwidth_status(bit v);    "
    },
    "apci_cap_device3": {
        "prefix": "apci_cap_device3",
        "body": [
            "apci_cap_device3  ${0:name_class};"
        ],
        "description": "class apci_cap_device3 extends apci_capability;\n"
    },
    "apci_cap_device3 :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_device3"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_device3]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_device3 :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_device3"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_device3]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_device3 :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_device3"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_device3]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_device3 :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_device3"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_device3]\n     function new(string name = \"apci_cap_device3\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_device3 :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_device3"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_device3]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_power_mgmt": {
        "prefix": "apci_cap_power_mgmt",
        "body": [
            "apci_cap_power_mgmt  ${0:name_class};"
        ],
        "description": "class apci_cap_power_mgmt extends apci_capability;\n"
    },
    "apci_cap_power_mgmt :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_power_mgmt"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_power_mgmt]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_power_mgmt :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_power_mgmt"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_power_mgmt]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_power_mgmt :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_power_mgmt"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_power_mgmt]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_power_mgmt :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_power_mgmt"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_power_mgmt]\n     function void post_randomize();    "
    },
    "apci_cap_power_mgmt :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_power_mgmt"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_power_mgmt]\n     function new(string name = \"apci_cap_power_mgmt\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_msi": {
        "prefix": "apci_cap_msi",
        "body": [
            "apci_cap_msi  ${0:name_class};"
        ],
        "description": "class apci_cap_msi extends apci_capability;\n"
    },
    "apci_cap_msi :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_msi"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_msi]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_msi :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_msi"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_msi]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_msi :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_msi"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_msi]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_msi :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_msi"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_msi]\n     function new(string name = \"apci_cap_msi\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_msi :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_msi"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_msi]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_msi :: get_num_vec": {
        "prefix": [
            "get_num_vec",
            "function:get_num_vec -> apci_cap_msi"
        ],
        "body": [
            "get_num_vec(${0:});"
        ],
        "description": "[Class:apci_cap_msi]\n     virtual function int get_num_vec();    "
    },
    "apci_cap_msix": {
        "prefix": "apci_cap_msix",
        "body": [
            "apci_cap_msix  ${0:name_class};"
        ],
        "description": "class apci_cap_msix extends apci_capability;\n"
    },
    "apci_cap_msix :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_msix"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_msix]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_msix :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_msix"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_msix]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_msix :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_msix"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_msix]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_msix :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_msix"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_msix]\n     function new(string name = \"apci_cap_msix\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_msix :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_msix"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_msix]\n     virtual function void reset_cap(apci_rst_e kind);    "
    },
    "apci_cap_vital": {
        "prefix": "apci_cap_vital",
        "body": [
            "apci_cap_vital  ${0:name_class};"
        ],
        "description": "class apci_cap_vital extends apci_capability;\n"
    },
    "apci_cap_vital :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_vital"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_vital]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_vital :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_vital"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_vital]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_vital :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_vital"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_vital]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_vital :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_vital"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_vital]\n     function new(string name = \"apci_cap_vital\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_aer": {
        "prefix": "apci_cap_aer",
        "body": [
            "apci_cap_aer  ${0:name_class};"
        ],
        "description": "class apci_cap_aer extends apci_capability;\n"
    },
    "apci_cap_aer :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_aer"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_aer]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_aer :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_aer"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_aer]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_aer :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_aer"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_aer]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_aer :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_aer"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_aer]\n     function void post_randomize();    "
    },
    "apci_cap_aer :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_aer"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_aer]\n     function new(string name = \"apci_cap_aer\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_aer :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_aer"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_aer]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_aer :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_aer"
        ],
        "body": [
            "get_cap_size(${1:pcie_cap_end2end});"
        ],
        "description": "[Class:apci_cap_aer]\n     virtual function bit       get_cap_size(bit pcie_cap_end2end);    "
    },
    "apci_cap_vc": {
        "prefix": "apci_cap_vc",
        "body": [
            "apci_cap_vc  ${0:name_class};"
        ],
        "description": "class apci_cap_vc extends apci_capability;\n"
    },
    "apci_cap_vc :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_vc"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_vc :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_vc"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_vc :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_vc"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_vc :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_vc"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_vc]\n     function new(string name = \"apci_cap_vc\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_vc :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_vc"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_vc :: tc_2_vc": {
        "prefix": [
            "tc_2_vc",
            "function:tc_2_vc -> apci_cap_vc"
        ],
        "body": [
            "tc_2_vc(${1:tc}, ${2:resource_id});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function int tc_2_vc(bit       tc,\n output int resource_id);    "
    },
    "apci_cap_vc :: sanity_check": {
        "prefix": [
            "sanity_check",
            "function:sanity_check -> apci_cap_vc"
        ],
        "body": [
            "sanity_check(${1:is_fatal});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function void sanity_check(bit is_fatal = 1);    "
    },
    "apci_cap_vc :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_vc"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_vc]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_device_serial": {
        "prefix": "apci_cap_device_serial",
        "body": [
            "apci_cap_device_serial  ${0:name_class};"
        ],
        "description": "class apci_cap_device_serial extends apci_capability;\n"
    },
    "apci_cap_device_serial :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_device_serial"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_device_serial]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_device_serial :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_device_serial"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_device_serial]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_device_serial :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_device_serial"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_device_serial]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_device_serial :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_device_serial"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_device_serial]\n     function new(string name = \"apci_cap_device_serial\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_device_serial :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_device_serial"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_device_serial]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_rc_int_link_ctrl": {
        "prefix": "apci_cap_rc_int_link_ctrl",
        "body": [
            "apci_cap_rc_int_link_ctrl  ${0:name_class};"
        ],
        "description": "class apci_cap_rc_int_link_ctrl extends apci_capability;\n"
    },
    "apci_cap_rc_int_link_ctrl :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_rc_int_link_ctrl"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_rc_int_link_ctrl]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_rc_int_link_ctrl :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_rc_int_link_ctrl"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_rc_int_link_ctrl]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_rc_int_link_ctrl :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_rc_int_link_ctrl"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_rc_int_link_ctrl]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_rc_int_link_ctrl :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_rc_int_link_ctrl"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_rc_int_link_ctrl]\n     function new(string name = \"apci_cap_rc_int_link_ctrl\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_rc_int_link_ctrl :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_rc_int_link_ctrl"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_rc_int_link_ctrl]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_power_budget": {
        "prefix": "apci_cap_power_budget",
        "body": [
            "apci_cap_power_budget  ${0:name_class};"
        ],
        "description": "class apci_cap_power_budget extends apci_capability;\n"
    },
    "apci_cap_power_budget :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_power_budget"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_power_budget]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_power_budget :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_power_budget"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_power_budget]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_power_budget :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_power_budget"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_power_budget]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_power_budget :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_power_budget"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_power_budget]\n     function new(string name = \"apci_cap_power_budget\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_power_budget :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_power_budget"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_power_budget]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_acs": {
        "prefix": "apci_cap_acs",
        "body": [
            "apci_cap_acs  ${0:name_class};"
        ],
        "description": "class apci_cap_acs extends apci_capability;\n"
    },
    "apci_cap_acs :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_acs"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_acs]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_acs :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_acs"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_acs]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_acs :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_acs"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_acs]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_acs :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_acs"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_acs]\n     function new(string name = \"apci_cap_acs\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_acs :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_acs"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_acs]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_acs :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_acs"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_acs]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_mfvc": {
        "prefix": "apci_cap_mfvc",
        "body": [
            "apci_cap_mfvc  ${0:name_class};"
        ],
        "description": "class apci_cap_mfvc extends apci_cap_vc;\n"
    },
    "apci_cap_mfvc :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_mfvc"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_mfvc]\n     function new(string name = \"apci_cap_mfvc\",\napci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_mfvc :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_mfvc"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_mfvc]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_vsec": {
        "prefix": "apci_cap_vsec",
        "body": [
            "apci_cap_vsec  ${0:name_class};"
        ],
        "description": "class apci_cap_vsec extends apci_capability;\n"
    },
    "apci_cap_vsec :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_vsec"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_vsec]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_vsec :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_vsec"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_vsec]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_vsec :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_vsec"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_vsec]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_vsec :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_vsec"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_vsec]\n     function new(string name = \"apci_cap_vsec\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_vsec :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_vsec"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_vsec]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_vsec :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_vsec"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_vsec]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_rcrb": {
        "prefix": "apci_cap_rcrb",
        "body": [
            "apci_cap_rcrb  ${0:name_class};"
        ],
        "description": "class apci_cap_rcrb extends apci_capability;\n"
    },
    "apci_cap_rcrb :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_rcrb"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_rcrb]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_rcrb :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_rcrb"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_rcrb]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_rcrb :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_rcrb"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_rcrb]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_rcrb :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_rcrb"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_rcrb]\n     function new(string name = \"apci_cap_rcrb\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_rcrb :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_rcrb"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_rcrb]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_mc": {
        "prefix": "apci_cap_mc",
        "body": [
            "apci_cap_mc  ${0:name_class};"
        ],
        "description": "class apci_cap_mc extends apci_capability;\n"
    },
    "apci_cap_mc :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_mc"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_mc]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_mc :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_mc"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_mc]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_mc :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_mc"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_mc]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_mc :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_mc"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_mc]\n     function void post_randomize();    "
    },
    "apci_cap_mc :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_mc"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_mc]\n     function new(string name = \"apci_cap_mc\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_mc :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_mc"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_mc]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_resizable_bar": {
        "prefix": "apci_cap_resizable_bar",
        "body": [
            "apci_cap_resizable_bar  ${0:name_class};"
        ],
        "description": "class apci_cap_resizable_bar extends apci_capability;\n"
    },
    "apci_cap_resizable_bar :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_resizable_bar"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_resizable_bar]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_resizable_bar :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_resizable_bar"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_resizable_bar]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_resizable_bar :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_resizable_bar"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_resizable_bar]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_resizable_bar :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_resizable_bar"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_resizable_bar]\n     function new(string name = \"apci_cap_resizable_bar\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_resizable_bar :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_resizable_bar"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_resizable_bar]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_resizable_bar :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_resizable_bar"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_resizable_bar]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_ari": {
        "prefix": "apci_cap_ari",
        "body": [
            "apci_cap_ari  ${0:name_class};"
        ],
        "description": "class apci_cap_ari extends apci_capability;\n"
    },
    "apci_cap_ari :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_ari"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_ari]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_ari :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_ari"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_ari]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_ari :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_ari"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_ari]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_ari :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_ari"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_ari]\n     function new(string name = \"apci_cap_ari\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_ari :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_ari"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_ari]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_dpa": {
        "prefix": "apci_cap_dpa",
        "body": [
            "apci_cap_dpa  ${0:name_class};"
        ],
        "description": "class apci_cap_dpa extends apci_capability;\n"
    },
    "apci_cap_dpa :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_dpa"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_dpa]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_dpa :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_dpa"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_dpa]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_dpa :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_dpa"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_dpa]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_dpa :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dpa"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dpa]\n     function new(string name = \"apci_cap_dpa\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dpa :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_dpa"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_dpa]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_dpa :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_dpa"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_dpa]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_ltr": {
        "prefix": "apci_cap_ltr",
        "body": [
            "apci_cap_ltr  ${0:name_class};"
        ],
        "description": "class apci_cap_ltr extends apci_capability;\n"
    },
    "apci_cap_ltr :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_ltr"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_ltr]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_ltr :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_ltr"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_ltr]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_ltr :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_ltr"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_ltr]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_ltr :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_ltr"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_ltr]\n     function new(string name = \"apci_cap_ltr\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_ltr :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_ltr"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_ltr]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_tph": {
        "prefix": "apci_cap_tph",
        "body": [
            "apci_cap_tph  ${0:name_class};"
        ],
        "description": "class apci_cap_tph extends apci_capability;\n"
    },
    "apci_cap_tph :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_tph"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_tph]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_tph :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_tph"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_tph]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_tph :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_tph"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_tph]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_tph :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_tph"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_tph]\n     function void post_randomize();    "
    },
    "apci_cap_tph :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_tph"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_tph]\n     function new(string name = \"apci_cap_tph\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_tph :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_tph"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_tph]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_tph :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_tph"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_tph]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_secondary_pcie": {
        "prefix": "apci_cap_secondary_pcie",
        "body": [
            "apci_cap_secondary_pcie  ${0:name_class};"
        ],
        "description": "class apci_cap_secondary_pcie extends apci_capability;\n"
    },
    "apci_cap_secondary_pcie :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_secondary_pcie"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_secondary_pcie :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_secondary_pcie"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_secondary_pcie :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_secondary_pcie"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_secondary_pcie :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_cap_secondary_pcie"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     function void post_randomize();    "
    },
    "apci_cap_secondary_pcie :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_secondary_pcie"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     function new(string name = \"apci_cap_secondary_pcie\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_secondary_pcie :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_secondary_pcie"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_secondary_pcie :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_secondary_pcie"
        ],
        "body": [
            "get_cap_size(${1:max_link_width});"
        ],
        "description": "[Class:apci_cap_secondary_pcie]\n     virtual function bit       get_cap_size(int max_link_width);    "
    },
    "apci_cap_mpcie": {
        "prefix": "apci_cap_mpcie",
        "body": [
            "apci_cap_mpcie  ${0:name_class};"
        ],
        "description": "class apci_cap_mpcie extends apci_capability;\n"
    },
    "apci_cap_mpcie :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_mpcie"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_mpcie]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_mpcie :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_mpcie"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_mpcie]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_mpcie :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_mpcie"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_mpcie]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_mpcie :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_mpcie"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_mpcie]\n     function new(string name = \"apci_cap_mpcie\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_mpcie :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_mpcie"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_mpcie]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_sriov": {
        "prefix": "apci_cap_sriov",
        "body": [
            "apci_cap_sriov  ${0:name_class};"
        ],
        "description": "class apci_cap_sriov extends apci_capability;\n"
    },
    "apci_cap_sriov :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_sriov"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_sriov]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_sriov :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_sriov"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_sriov]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_sriov :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_sriov"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_sriov]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_sriov :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_sriov"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_sriov]\n     function new(string name = \"apci_cap_sriov\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_sriov :: collect_bar_ranges": {
        "prefix": [
            "collect_bar_ranges",
            "function:collect_bar_ranges -> apci_cap_sriov"
        ],
        "body": [
            "collect_bar_ranges(${1:ranges});"
        ],
        "description": "[Class:apci_cap_sriov]\n     function void collect_bar_ranges(ref apci_bar_t ranges      );    "
    },
    "apci_cap_sriov :: append_all_ranges": {
        "prefix": [
            "append_all_ranges",
            "function:append_all_ranges -> apci_cap_sriov"
        ],
        "body": [
            "append_all_ranges(${1:ranges});"
        ],
        "description": "[Class:apci_cap_sriov]\n     function void append_all_ranges(ref apci_bar_t ranges      );    "
    },
    "apci_cap_sriov :: get_largest_vf_allocated": {
        "prefix": [
            "get_largest_vf_allocated",
            "function:get_largest_vf_allocated -> apci_cap_sriov"
        ],
        "body": [
            "get_largest_vf_allocated(${1:pf_num});"
        ],
        "description": "[Class:apci_cap_sriov]\n     function int get_largest_vf_allocated(int pf_num);    "
    },
    "apci_cap_sriov :: get_largest_vf_supported": {
        "prefix": [
            "get_largest_vf_supported",
            "function:get_largest_vf_supported -> apci_cap_sriov"
        ],
        "body": [
            "get_largest_vf_supported(${1:pf_num});"
        ],
        "description": "[Class:apci_cap_sriov]\n     function int get_largest_vf_supported(int pf_num);    "
    },
    "apci_cap_sriov :: get_bus_consumed_by_vf": {
        "prefix": [
            "get_bus_consumed_by_vf",
            "function:get_bus_consumed_by_vf -> apci_cap_sriov"
        ],
        "body": [
            "get_bus_consumed_by_vf(${1:pf_num});"
        ],
        "description": "[Class:apci_cap_sriov]\n     function int get_bus_consumed_by_vf(int pf_num);    "
    },
    "apci_cap_sriov :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_sriov"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_sriov]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_ats": {
        "prefix": "apci_cap_ats",
        "body": [
            "apci_cap_ats  ${0:name_class};"
        ],
        "description": "class apci_cap_ats extends apci_capability;\n"
    },
    "apci_cap_ats :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_ats"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_ats]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_ats :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_ats"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_ats]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_ats :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_ats"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_ats]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_ats :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_ats"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_ats]\n     function new(string name = \"apci_cap_ats\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_ats :: get_stu": {
        "prefix": [
            "get_stu",
            "function:get_stu -> apci_cap_ats"
        ],
        "body": [
            "get_stu(${0:});"
        ],
        "description": "[Class:apci_cap_ats]\n     function avery_u64 get_stu();    "
    },
    "apci_cap_ats :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_ats"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_ats]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_pri": {
        "prefix": "apci_cap_pri",
        "body": [
            "apci_cap_pri  ${0:name_class};"
        ],
        "description": "class apci_cap_pri extends apci_capability;\n"
    },
    "apci_cap_pri :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pri"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pri]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pri :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pri"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pri]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pri :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pri"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pri]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pri :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pri"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pri]\n     function new(string name = \"apci_cap_pri\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pri :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_pri"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_pri]\n     virtual function bit       get_cap_size();    "
    },
    "apci_msix_table": {
        "prefix": "apci_msix_table",
        "body": [
            "apci_msix_table  ${0:name_class};"
        ],
        "description": "class apci_msix_table extends avery_reg;\n"
    },
    "apci_msix_table :: new": {
        "prefix": [
            "new",
            "function:new -> apci_msix_table"
        ],
        "body": [
            "new(${1:name}, ${2:num_vectors}, ${3:log});"
        ],
        "description": "[Class:apci_msix_table]\n     function new(string name = \"apci_msix_table\",\n int num_vectors,\n apci_log log = null);    "
    },
    "apci_msix_table :: fwrite_cb": {
        "prefix": [
            "fwrite_cb",
            "function:fwrite_cb -> apci_msix_table"
        ],
        "body": [
            "fwrite_cb(${1:f}, ${2:old_v});"
        ],
        "description": "[Class:apci_msix_table]\n     virtual function void fwrite_cb(avery_reg_field f,\n avery_reg_val_t old_v);    "
    },
    "apci_msix_table :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_msix_table"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_msix_table]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_msix_pba": {
        "prefix": "apci_msix_pba",
        "body": [
            "apci_msix_pba  ${0:name_class};"
        ],
        "description": "class apci_msix_pba extends avery_reg;\n"
    },
    "apci_msix_pba :: new": {
        "prefix": [
            "new",
            "function:new -> apci_msix_pba"
        ],
        "body": [
            "new(${1:name}, ${2:num_vectors}, ${3:log});"
        ],
        "description": "[Class:apci_msix_pba]\n     function new(string name = \"apci_msix_pba\",\n int num_vectors,\n apci_log log = null);    "
    },
    "apci_msix_pba :: fwrite_cb": {
        "prefix": [
            "fwrite_cb",
            "function:fwrite_cb -> apci_msix_pba"
        ],
        "body": [
            "fwrite_cb(${1:f}, ${2:old_v});"
        ],
        "description": "[Class:apci_msix_pba]\n     virtual function void fwrite_cb(avery_reg_field f,\n avery_reg_val_t old_v);    "
    },
    "apci_msix_pba :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_msix_pba"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_msix_pba]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_dpc": {
        "prefix": "apci_cap_dpc",
        "body": [
            "apci_cap_dpc  ${0:name_class};"
        ],
        "description": "class apci_cap_dpc extends apci_capability;\n"
    },
    "apci_cap_dpc :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_dpc"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_dpc]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_dpc :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_dpc"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_dpc]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_dpc :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_dpc"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_dpc]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_dpc :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dpc"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dpc]\n     function new(string name = \"apci_cap_dpc\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dpc :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_dpc"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_dpc]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_dpc :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_dpc"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_dpc]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_l1_pm_sub": {
        "prefix": "apci_cap_l1_pm_sub",
        "body": [
            "apci_cap_l1_pm_sub  ${0:name_class};"
        ],
        "description": "class apci_cap_l1_pm_sub extends apci_capability;\n"
    },
    "apci_cap_l1_pm_sub :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_l1_pm_sub :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_l1_pm_sub :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_l1_pm_sub :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     function new(string name = \"apci_cap_l1_pm_sub\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_l1_pm_sub :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     virtual function void create_dynamic_fields();                                                                                               "
    },
    "apci_cap_l1_pm_sub :: sprint_l1_substates_sup": {
        "prefix": [
            "sprint_l1_substates_sup",
            "function:sprint_l1_substates_sup -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "sprint_l1_substates_sup(${0:});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     function string sprint_l1_substates_sup();    "
    },
    "apci_cap_l1_pm_sub :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_l1_pm_sub"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_l1_pm_sub]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_pl_gen4": {
        "prefix": "apci_cap_pl_gen4",
        "body": [
            "apci_cap_pl_gen4  ${0:name_class};"
        ],
        "description": "class apci_cap_pl_gen4 extends apci_capability;\n"
    },
    "apci_cap_pl_gen4 :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pl_gen4"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pl_gen4]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pl_gen4 :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pl_gen4"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen4]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pl_gen4 :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pl_gen4"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen4]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pl_gen4 :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pl_gen4"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pl_gen4]\n     function new(string name = \"apci_cap_pl_gen4\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pl_gen4 :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_pl_gen4"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen4]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_pl_gen4 :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_pl_gen4"
        ],
        "body": [
            "get_cap_size(${1:max_link_width});"
        ],
        "description": "[Class:apci_cap_pl_gen4]\n     virtual function bit       get_cap_size(int max_link_width);    "
    },
    "apci_cap_pl_gen4_margin": {
        "prefix": "apci_cap_pl_gen4_margin",
        "body": [
            "apci_cap_pl_gen4_margin  ${0:name_class};"
        ],
        "description": "class apci_cap_pl_gen4_margin extends apci_capability;\n"
    },
    "apci_cap_pl_gen4_margin :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pl_gen4_margin"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pl_gen4_margin]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pl_gen4_margin :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pl_gen4_margin"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen4_margin]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pl_gen4_margin :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pl_gen4_margin"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen4_margin]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pl_gen4_margin :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pl_gen4_margin"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pl_gen4_margin]\n     function new(string name = \"apci_cap_pl_gen4_margin\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pl_gen4_margin :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_pl_gen4_margin"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen4_margin]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_pl_gen4_margin :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_pl_gen4_margin"
        ],
        "body": [
            "get_cap_size(${1:max_link_width});"
        ],
        "description": "[Class:apci_cap_pl_gen4_margin]\n     virtual function bit       get_cap_size(int max_link_width);    "
    },
    "apci_cap_dl_feature": {
        "prefix": "apci_cap_dl_feature",
        "body": [
            "apci_cap_dl_feature  ${0:name_class};"
        ],
        "description": "class apci_cap_dl_feature extends apci_capability;\n"
    },
    "apci_cap_dl_feature :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_dl_feature"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_dl_feature]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_dl_feature :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_dl_feature"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_dl_feature]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_dl_feature :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_dl_feature"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_dl_feature]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_dl_feature :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dl_feature"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dl_feature]\n     function new(string name = \"apci_cap_dl_feature\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dl_feature :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_dl_feature"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_dl_feature]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_pasid": {
        "prefix": "apci_cap_pasid",
        "body": [
            "apci_cap_pasid  ${0:name_class};"
        ],
        "description": "class apci_cap_pasid extends apci_capability;\n"
    },
    "apci_cap_pasid :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pasid"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pasid]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pasid :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pasid"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pasid]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pasid :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pasid"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pasid]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pasid :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pasid"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pasid]\n     function new(string name = \"apci_cap_pasid\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pasid :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_pasid"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_pasid]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_lnr": {
        "prefix": "apci_cap_lnr",
        "body": [
            "apci_cap_lnr  ${0:name_class};"
        ],
        "description": "class apci_cap_lnr extends apci_capability;\n"
    },
    "apci_cap_lnr :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_lnr"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_lnr]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_lnr :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_lnr"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_lnr]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_lnr :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_lnr"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_lnr]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_lnr :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_lnr"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_lnr]\n     function new(string name = \"apci_cap_lnr\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_lnr :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_lnr"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_lnr]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_ptm": {
        "prefix": "apci_cap_ptm",
        "body": [
            "apci_cap_ptm  ${0:name_class};"
        ],
        "description": "class apci_cap_ptm extends apci_capability;\n"
    },
    "apci_cap_ptm :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_ptm"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_ptm]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_ptm :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_ptm"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_ptm]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_ptm :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_ptm"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_ptm]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_ptm :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_ptm"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_ptm]\n     function new(string name = \"apci_cap_ptm\",\napci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_ptm :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_ptm"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_ptm]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_rc_link_declaration": {
        "prefix": "apci_cap_rc_link_declaration",
        "body": [
            "apci_cap_rc_link_declaration  ${0:name_class};"
        ],
        "description": "class apci_cap_rc_link_declaration extends apci_capability;\n"
    },
    "apci_cap_rc_link_declaration :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_rc_link_declaration"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_rc_link_declaration]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_rc_link_declaration :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_rc_link_declaration"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_rc_link_declaration]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_rc_link_declaration :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_rc_link_declaration"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_rc_link_declaration]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_rc_link_declaration :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_rc_link_declaration"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_rc_link_declaration]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_rc_link_declaration :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_rc_link_declaration"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_rc_link_declaration]\n     function new(string name = \"apci_cap_rc_link_declaration\",\n        apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_rc_link_declaration :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_rc_link_declaration"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_rc_link_declaration]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_frs_q": {
        "prefix": "apci_cap_frs_q",
        "body": [
            "apci_cap_frs_q  ${0:name_class};"
        ],
        "description": "class apci_cap_frs_q extends apci_capability;\n"
    },
    "apci_cap_frs_q :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_frs_q"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_frs_q]\n     virtual function void set_next_cap_offset(avery_u16 v);                                                                                                                     "
    },
    "apci_cap_frs_q :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_frs_q"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_frs_q]\n     virtual function bit       get_next_cap_offset();      "
    },
    "apci_cap_frs_q :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_frs_q"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_frs_q]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_frs_q :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_frs_q"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_frs_q]\n     function new(string name = \"apci_cap_frs_q\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_frs_q :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_frs_q"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_frs_q]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_mriov": {
        "prefix": "apci_cap_mriov",
        "body": [
            "apci_cap_mriov  ${0:name_class};"
        ],
        "description": "class apci_cap_mriov extends apci_capability;\n"
    },
    "apci_cap_mriov :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_mriov"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_mriov]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_mriov :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_mriov"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_mriov]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_mriov :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_mriov"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_mriov]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_mriov :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_mriov"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_mriov]\n     function new(string name = \"apci_cap_mriov\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec": {
        "prefix": "apci_cap_dvsec",
        "body": [
            "apci_cap_dvsec  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec extends apci_capability;\n"
    },
    "apci_cap_dvsec :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_dvsec"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_dvsec]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_dvsec :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_dvsec"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_dvsec :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_dvsec"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_dvsec :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec]\n     function new(string         name  = \"apci_cap_dvsec\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_dvsec"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_dvsec]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_dvsec_ccix_tp": {
        "prefix": "apci_cap_dvsec_ccix_tp",
        "body": [
            "apci_cap_dvsec_ccix_tp  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_ccix_tp extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_ccix_tp :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_ccix_tp"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_tp]\n     function new(string name = \"apci_cap_dvsec_ccix_tp\",\n            apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_ccix_tp :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_dvsec_ccix_tp"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_tp]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_dvsec_ccix_tp :: get_eq_p2_timeout": {
        "prefix": [
            "get_eq_p2_timeout",
            "function:get_eq_p2_timeout -> apci_cap_dvsec_ccix_tp"
        ],
        "body": [
            "get_eq_p2_timeout(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_tp]\n     function avery_u64 get_eq_p2_timeout();    "
    },
    "apci_cap_dvsec_ccix_tp :: get_eq_p3_timeout": {
        "prefix": [
            "get_eq_p3_timeout",
            "function:get_eq_p3_timeout -> apci_cap_dvsec_ccix_tp"
        ],
        "body": [
            "get_eq_p3_timeout(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_tp]\n     function avery_u64 get_eq_p3_timeout();    "
    },
    "apci_cap_dvsec_ccix_tp :: get_quick_eq_timeout": {
        "prefix": [
            "get_quick_eq_timeout",
            "function:get_quick_eq_timeout -> apci_cap_dvsec_ccix_tp"
        ],
        "body": [
            "get_quick_eq_timeout(${1:is_p2});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_tp]\n     function avery_u64 get_quick_eq_timeout(input bit is_p2);    "
    },
    "apci_cap_dvsec_ccix_tp :: get_calib_time": {
        "prefix": [
            "get_calib_time",
            "function:get_calib_time -> apci_cap_dvsec_ccix_tp"
        ],
        "body": [
            "get_calib_time(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_tp]\n     function avery_u64 get_calib_time();    "
    },
    "apci_cap_dvsec_ccix_prot": {
        "prefix": "apci_cap_dvsec_ccix_prot",
        "body": [
            "apci_cap_dvsec_ccix_prot  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_ccix_prot extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_ccix_prot :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_ccix_prot"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_prot]\n     function new(string name = \"apci_cap_dvsec_ccix_prot\",\n        apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_ccix_prot :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_dvsec_ccix_prot"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_prot]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_dvsec_ccix_app": {
        "prefix": "apci_cap_dvsec_ccix_app",
        "body": [
            "apci_cap_dvsec_ccix_app  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_ccix_app extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_ccix_app :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_ccix_app"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_ccix_app]\n     function new(string name = \"apci_cap_dvsec_ccix_app\",\n            apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_hierarchy_id": {
        "prefix": "apci_cap_hierarchy_id",
        "body": [
            "apci_cap_hierarchy_id  ${0:name_class};"
        ],
        "description": "class apci_cap_hierarchy_id extends apci_capability;\n"
    },
    "apci_cap_hierarchy_id :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_hierarchy_id"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_hierarchy_id]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_hierarchy_id :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_hierarchy_id"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_hierarchy_id]\n     virtual function bit       get_next_cap_offset();       "
    },
    "apci_cap_hierarchy_id :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_hierarchy_id"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_hierarchy_id]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_hierarchy_id :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_hierarchy_id"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_hierarchy_id]\n     function new(string name = \"apci_cap_hierarchy_id\",\n                  apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_hierarchy_id :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_hierarchy_id"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_hierarchy_id]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_rtr": {
        "prefix": "apci_cap_rtr",
        "body": [
            "apci_cap_rtr  ${0:name_class};"
        ],
        "description": "class apci_cap_rtr extends apci_capability;\n"
    },
    "apci_cap_rtr :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_rtr"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_rtr]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_rtr :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_rtr"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_rtr]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_rtr :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_rtr"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_rtr]\n     virtual function bit       get_cap_id();                   "
    },
    "apci_cap_rtr :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_rtr"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_rtr]\n     function new(string name = \"apci_cap_rtr\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_rtr :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_rtr"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_rtr]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_native_pcie": {
        "prefix": "apci_cap_native_pcie",
        "body": [
            "apci_cap_native_pcie  ${0:name_class};"
        ],
        "description": "class apci_cap_native_pcie extends apci_capability;\n"
    },
    "apci_cap_native_pcie :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_native_pcie"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_native_pcie]\n      virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_native_pcie :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_native_pcie"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_native_pcie]\n      virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_native_pcie :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_native_pcie"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_native_pcie]\n      virtual function bit       get_cap_id();    "
    },
    "apci_cap_native_pcie :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_native_pcie"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_native_pcie]\n     function new(string name = \"apci_cap_native_pcie\",\n         apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_native_pcie :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_native_pcie"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_native_pcie]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_vf_resizable_bar": {
        "prefix": "apci_cap_vf_resizable_bar",
        "body": [
            "apci_cap_vf_resizable_bar  ${0:name_class};"
        ],
        "description": "class apci_cap_vf_resizable_bar extends apci_capability;\n"
    },
    "apci_cap_vf_resizable_bar :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_vf_resizable_bar"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_vf_resizable_bar]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_vf_resizable_bar :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_vf_resizable_bar"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_vf_resizable_bar]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_vf_resizable_bar :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_vf_resizable_bar"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_vf_resizable_bar]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_vf_resizable_bar :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_vf_resizable_bar"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_vf_resizable_bar]\n     function new(string name = \"apci_cap_resizable_bar\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_vf_resizable_bar :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_vf_resizable_bar"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_vf_resizable_bar]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_vf_resizable_bar :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_vf_resizable_bar"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_vf_resizable_bar]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_pl_gen5": {
        "prefix": "apci_cap_pl_gen5",
        "body": [
            "apci_cap_pl_gen5  ${0:name_class};"
        ],
        "description": "class apci_cap_pl_gen5 extends apci_capability;\n"
    },
    "apci_cap_pl_gen5 :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pl_gen5"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pl_gen5]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pl_gen5 :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pl_gen5"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen5]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pl_gen5 :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pl_gen5"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen5]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pl_gen5 :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pl_gen5"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pl_gen5]\n     function new(string name = \"apci_cap_pl_gen5\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pl_gen5 :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_pl_gen5"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen5]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_pl_gen5 :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_pl_gen5"
        ],
        "body": [
            "get_cap_size(${1:max_link_width});"
        ],
        "description": "[Class:apci_cap_pl_gen5]\n     virtual function bit       get_cap_size(int max_link_width);    "
    },
    "apci_cap_pl_gen6": {
        "prefix": "apci_cap_pl_gen6",
        "body": [
            "apci_cap_pl_gen6  ${0:name_class};"
        ],
        "description": "class apci_cap_pl_gen6 extends apci_capability;\n"
    },
    "apci_cap_pl_gen6 :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_pl_gen6"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_pl_gen6]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_pl_gen6 :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_pl_gen6"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen6]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_pl_gen6 :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_pl_gen6"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen6]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_pl_gen6 :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_pl_gen6"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_pl_gen6]\n     function new(string name = \"apci_cap_pl_gen6\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_pl_gen6 :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_pl_gen6"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_pl_gen6]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_pl_gen6 :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_pl_gen6"
        ],
        "body": [
            "get_cap_size(${1:max_link_width});"
        ],
        "description": "[Class:apci_cap_pl_gen6]\n     virtual function bit       get_cap_size(int max_link_width);    "
    },
    "apci_cap_shadow_func": {
        "prefix": "apci_cap_shadow_func",
        "body": [
            "apci_cap_shadow_func  ${0:name_class};"
        ],
        "description": "class apci_cap_shadow_func extends apci_capability;\n"
    },
    "apci_cap_shadow_func :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_shadow_func"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_shadow_func]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_shadow_func :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_shadow_func"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_shadow_func]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_shadow_func :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_shadow_func"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_shadow_func]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_shadow_func :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_shadow_func"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_shadow_func]\n     function new(string name = \"apci_cap_shadow_func\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_shadow_func :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_shadow_func"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_shadow_func]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_shadow_func :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_shadow_func"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_shadow_func]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_flit_log": {
        "prefix": "apci_cap_flit_log",
        "body": [
            "apci_cap_flit_log  ${0:name_class};"
        ],
        "description": "class apci_cap_flit_log extends apci_capability;\n"
    },
    "apci_cap_flit_log :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_flit_log"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_flit_log]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_flit_log :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_flit_log"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_flit_log]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_flit_log :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_flit_log"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_flit_log]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_flit_log :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_flit_log"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_flit_log]\n     function new(string name = \"apci_cap_flit_log\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_flit_log :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_flit_log"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_flit_log]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_flit_performance_measure": {
        "prefix": "apci_cap_flit_performance_measure",
        "body": [
            "apci_cap_flit_performance_measure  ${0:name_class};"
        ],
        "description": "class apci_cap_flit_performance_measure extends apci_capability;\n"
    },
    "apci_cap_flit_performance_measure :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_flit_performance_measure"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_flit_performance_measure]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_flit_performance_measure :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_flit_performance_measure"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_flit_performance_measure]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_flit_performance_measure :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_flit_performance_measure"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_flit_performance_measure]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_flit_performance_measure :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_flit_performance_measure"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_flit_performance_measure]\n     function new(string name = \"apci_cap_flit_performance_measure\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_flit_performance_measure :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_flit_performance_measure"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_flit_performance_measure]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_flit_err_inject": {
        "prefix": "apci_cap_flit_err_inject",
        "body": [
            "apci_cap_flit_err_inject  ${0:name_class};"
        ],
        "description": "class apci_cap_flit_err_inject extends apci_capability;\n"
    },
    "apci_cap_flit_err_inject :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_flit_err_inject"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_flit_err_inject]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_flit_err_inject :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_flit_err_inject"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_flit_err_inject]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_flit_err_inject :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_flit_err_inject"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_flit_err_inject]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_flit_err_inject :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_flit_err_inject"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_flit_err_inject]\n     function new(string name = \"apci_cap_flit_err_inject\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_flit_err_inject :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_flit_err_inject"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_flit_err_inject]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_alt_protocol": {
        "prefix": "apci_cap_alt_protocol",
        "body": [
            "apci_cap_alt_protocol  ${0:name_class};"
        ],
        "description": "class apci_cap_alt_protocol extends apci_capability;\n"
    },
    "apci_cap_alt_protocol :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_alt_protocol"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_alt_protocol]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_alt_protocol :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_alt_protocol"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_alt_protocol]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_alt_protocol :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_alt_protocol"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_alt_protocol]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_alt_protocol :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_alt_protocol"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_alt_protocol]\n     function new(string name = \"apci_cap_alt_protocol\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_alt_protocol :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_alt_protocol"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_alt_protocol]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_alt_protocol :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_alt_protocol"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_alt_protocol]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_fpb": {
        "prefix": "apci_cap_fpb",
        "body": [
            "apci_cap_fpb  ${0:name_class};"
        ],
        "description": "class apci_cap_fpb extends apci_capability;\n"
    },
    "apci_cap_fpb :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_fpb"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_fpb]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_fpb :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_fpb"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_fpb]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_fpb :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_fpb"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_fpb]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_fpb :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_fpb"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_fpb]\n     function new(string name = \"apci_cap_fpb\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_fpb :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_fpb"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_fpb]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_af": {
        "prefix": "apci_cap_af",
        "body": [
            "apci_cap_af  ${0:name_class};"
        ],
        "description": "class apci_cap_af extends apci_capability;\n"
    },
    "apci_cap_af :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_af"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_af]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_af :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_af"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_af]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_af :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_af"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_af]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_af :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_af"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_af]\n     function new(string name = \"apci_cap_af\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_af :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_af"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_af]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_sfi": {
        "prefix": "apci_cap_sfi",
        "body": [
            "apci_cap_sfi  ${0:name_class};"
        ],
        "description": "class apci_cap_sfi extends apci_capability;\n"
    },
    "apci_cap_sfi :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_sfi"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_sfi]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_sfi :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_sfi"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_sfi]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_sfi :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_sfi"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_sfi]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_sfi :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_sfi"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_sfi]\n     function new(string name = \"apci_cap_sfi\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_sfi :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_sfi"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_sfi]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_dvsec_cxl_device": {
        "prefix": "apci_cap_dvsec_cxl_device",
        "body": [
            "apci_cap_dvsec_cxl_device  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_cxl_device extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_cxl_device :: collect_hdm_ranges": {
        "prefix": [
            "collect_hdm_ranges",
            "function:collect_hdm_ranges -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "collect_hdm_ranges(${1:ranges});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function void collect_hdm_ranges(ref apci_addr_range_t ranges      );    "
    },
    "apci_cap_dvsec_cxl_device :: get_mem_size_range1": {
        "prefix": [
            "get_mem_size_range1",
            "function:get_mem_size_range1 -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "get_mem_size_range1(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function bit       get_mem_size_range1();    "
    },
    "apci_cap_dvsec_cxl_device :: get_mem_size_range2": {
        "prefix": [
            "get_mem_size_range2",
            "function:get_mem_size_range2 -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "get_mem_size_range2(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function bit       get_mem_size_range2();    "
    },
    "apci_cap_dvsec_cxl_device :: get_mem_base_range1": {
        "prefix": [
            "get_mem_base_range1",
            "function:get_mem_base_range1 -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "get_mem_base_range1(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function bit       get_mem_base_range1();    "
    },
    "apci_cap_dvsec_cxl_device :: get_mem_base_range2": {
        "prefix": [
            "get_mem_base_range2",
            "function:get_mem_base_range2 -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "get_mem_base_range2(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function bit       get_mem_base_range2();    "
    },
    "apci_cap_dvsec_cxl_device :: get_cxl_reset_timeout_ms": {
        "prefix": [
            "get_cxl_reset_timeout_ms",
            "function:get_cxl_reset_timeout_ms -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "get_cxl_reset_timeout_ms(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function bit       get_cxl_reset_timeout_ms();    "
    },
    "apci_cap_dvsec_cxl_device :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_cxl_device"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device]\n     function new(string name = \"apci_cap_dvsec_cxl_device\",\n            apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_noncxl_func_map": {
        "prefix": "apci_cap_dvsec_noncxl_func_map",
        "body": [
            "apci_cap_dvsec_noncxl_func_map  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_noncxl_func_map extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_noncxl_func_map :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_noncxl_func_map"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_noncxl_func_map]\n     function new(string name = \"apci_cap_dvsec_noncxl_func_map\",\n             apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_flexbus_port": {
        "prefix": "apci_cap_dvsec_flexbus_port",
        "body": [
            "apci_cap_dvsec_flexbus_port  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_flexbus_port extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_flexbus_port :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_flexbus_port"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_flexbus_port]\n     function new(string name = \"apci_cap_dvsec_flexbus_port\",\n apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_cxl_port_ext": {
        "prefix": "apci_cap_dvsec_cxl_port_ext",
        "body": [
            "apci_cap_dvsec_cxl_port_ext  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_cxl_port_ext extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_cxl_port_ext :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_cxl_port_ext"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_port_ext]\n     function new(string name = \"apci_cap_dvsec_cxl_port_ext\",\n apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_cxl_port_ext :: add_alt_ranges": {
        "prefix": [
            "add_alt_ranges",
            "function:add_alt_ranges -> apci_cap_dvsec_cxl_port_ext"
        ],
        "body": [
            "add_alt_ranges(${1:q});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_port_ext]\n     function void add_alt_ranges(ref apci_bar_t q      );    "
    },
    "apci_cap_dvsec_cxl_port_ext :: get_local_rcrb": {
        "prefix": [
            "get_local_rcrb",
            "function:get_local_rcrb -> apci_cap_dvsec_cxl_port_ext"
        ],
        "body": [
            "get_local_rcrb(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_port_ext]\n     function apci_bar_t get_local_rcrb();    "
    },
    "apci_cap_dvsec_cxl_port_ext :: get_rcrb_base": {
        "prefix": [
            "get_rcrb_base",
            "function:get_rcrb_base -> apci_cap_dvsec_cxl_port_ext"
        ],
        "body": [
            "get_rcrb_base(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_port_ext]\n     function avery_u64 get_rcrb_base();    "
    },
    "apci_cap_dvsec_cxl_port_ext :: add_rcrb_range": {
        "prefix": [
            "add_rcrb_range",
            "function:add_rcrb_range -> apci_cap_dvsec_cxl_port_ext"
        ],
        "body": [
            "add_rcrb_range(${1:q});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_port_ext]\n     function void add_rcrb_range(ref apci_bar_t q      );    "
    },
    "apci_cap_dvsec_gpf_cxl_port": {
        "prefix": "apci_cap_dvsec_gpf_cxl_port",
        "body": [
            "apci_cap_dvsec_gpf_cxl_port  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_gpf_cxl_port extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_gpf_cxl_port :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_gpf_cxl_port"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_gpf_cxl_port]\n     function new(string name = \"apci_cap_dvsec_gpf_cxl_port\",\n            apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_gpf_cxl_port :: get_phase1_timeout": {
        "prefix": [
            "get_phase1_timeout",
            "function:get_phase1_timeout -> apci_cap_dvsec_gpf_cxl_port"
        ],
        "body": [
            "get_phase1_timeout(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_gpf_cxl_port]\n     function time get_phase1_timeout();    "
    },
    "apci_cap_dvsec_gpf_cxl_port :: get_phase2_timeout": {
        "prefix": [
            "get_phase2_timeout",
            "function:get_phase2_timeout -> apci_cap_dvsec_gpf_cxl_port"
        ],
        "body": [
            "get_phase2_timeout(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_gpf_cxl_port]\n     function time get_phase2_timeout();    "
    },
    "apci_cap_dvsec_gpf_cxl_device": {
        "prefix": "apci_cap_dvsec_gpf_cxl_device",
        "body": [
            "apci_cap_dvsec_gpf_cxl_device  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_gpf_cxl_device extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_gpf_cxl_device :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_gpf_cxl_device"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_gpf_cxl_device]\n     function new(string name = \"apci_cap_dvsec_gpf_cxl_device\",\n            apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_cxl_reg_locator": {
        "prefix": "apci_cap_dvsec_cxl_reg_locator",
        "body": [
            "apci_cap_dvsec_cxl_reg_locator  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_cxl_reg_locator extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_cxl_reg_locator :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_cxl_reg_locator"
        ],
        "body": [
            "new(${1:name}, ${2:num_vectors}, ${3:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_reg_locator]\n     function new(string name = \"apci_cap_dvsec_cxl_reg_locator\",\n int num_vectors = 3,\n apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_dvsec_cxl_reg_locator :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_dvsec_cxl_reg_locator"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_reg_locator]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cap_dvsec_cxl_mld": {
        "prefix": "apci_cap_dvsec_cxl_mld",
        "body": [
            "apci_cap_dvsec_cxl_mld  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_cxl_mld extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_cxl_mld :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_cxl_mld"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_mld]\n     function new(string name = \"apci_cap_dvsec_cxl_mld\",\n apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_mmio_cap": {
        "prefix": "apci_mmio_cap",
        "body": [
            "apci_mmio_cap  ${0:name_class};"
        ],
        "description": "class apci_mmio_cap extends apci_capability;\n"
    },
    "apci_mmio_cap :: new": {
        "prefix": [
            "new",
            "function:new -> apci_mmio_cap"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_mmio_cap]\n     function new(string name);    "
    },
    "apci_mmio_cap :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_mmio_cap"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_mmio_cap]\n     virtual function bit       get_cap_id();                                                                                                                                    "
    },
    "apci_mmio_cap :: get_avery_cap_id": {
        "prefix": [
            "get_avery_cap_id",
            "function:get_avery_cap_id -> apci_mmio_cap"
        ],
        "body": [
            "get_avery_cap_id(${0:});"
        ],
        "description": "[Class:apci_mmio_cap]\n     virtual function int get_avery_cap_id();                                                                                                                                    "
    },
    "apci_mmio_cap :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_mmio_cap"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_mmio_cap]\n     virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_cap_cxl_cm_reg": {
        "prefix": "apci_cap_cxl_cm_reg",
        "body": [
            "apci_cap_cxl_cm_reg  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_cm_reg extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_cm_reg :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_cm_reg"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:cxl_sup});"
        ],
        "description": "[Class:apci_cap_cxl_cm_reg]\n     function new(string name = \"apci_cap_cxl_cm_reg\",\n apci_log log = null,\n byte cxl_sup = 1);    "
    },
    "apci_cap_cxl_cm_reg :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_cm_reg"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_cm_reg]\n     virtual function bit       get_cap_id();                                                                                                                                    "
    },
    "apci_cap_cxl_cm_reg :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_cxl_cm_reg"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_cm_reg]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_cxl_cm_reg :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_cm_reg"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_cm_reg]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_ras": {
        "prefix": "apci_cap_cxl_ras",
        "body": [
            "apci_cap_cxl_ras  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_ras extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_ras :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_ras"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_ras]\n     function new(string name = \"apci_cap_cxl_ras\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_ras :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_ras"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_ras]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_ras :: get_mask": {
        "prefix": [
            "get_mask",
            "function:get_mask -> apci_cap_cxl_ras"
        ],
        "body": [
            "get_mask(${1:t});"
        ],
        "description": "[Class:apci_cap_cxl_ras]\n     function bit get_mask(acxl_ras_err_type_e t);    "
    },
    "apci_cap_cxl_ras :: get_severity": {
        "prefix": [
            "get_severity",
            "function:get_severity -> apci_cap_cxl_ras"
        ],
        "body": [
            "get_severity(${1:t});"
        ],
        "description": "[Class:apci_cap_cxl_ras]\n     function bit get_severity(acxl_ras_err_type_e t);    "
    },
    "apci_cap_cxl_ras :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_ras"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_ras]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_security": {
        "prefix": "apci_cap_cxl_security",
        "body": [
            "apci_cap_cxl_security  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_security extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_security :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_security"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_security]\n     function new(string name = \"apci_cap_cxl_security\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_security :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_security"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_security]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_security :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_security"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_security]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_link": {
        "prefix": "apci_cap_cxl_link",
        "body": [
            "apci_cap_cxl_link  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_link extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_link :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_link"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:cxl_sup});"
        ],
        "description": "[Class:apci_cap_cxl_link]\n     function new(string name = \"apci_cap_cxl_link\",\n apci_log log = null,\n byte cxl_sup = 1);    "
    },
    "apci_cap_cxl_link :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_link"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_link]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_link :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_link"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_link]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_hdm_decoder": {
        "prefix": "apci_cap_cxl_hdm_decoder",
        "body": [
            "apci_cap_cxl_hdm_decoder  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_hdm_decoder extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_hdm_decoder :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cap_cxl_hdm_decoder :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:ptype});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     function new(string name = \"apci_cap_cxl_hdm_decoder\",\n apci_log log = null,\n apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_hdm_decoder :: get_interleave_granularity": {
        "prefix": [
            "get_interleave_granularity",
            "function:get_interleave_granularity -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_interleave_granularity(${1:decoder_id});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function int get_interleave_granularity(int decoder_id);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_interleave_ways": {
        "prefix": [
            "get_interleave_ways",
            "function:get_interleave_ways -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_interleave_ways(${1:decoder_id});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function avery_u16 get_interleave_ways(int decoder_id);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_il_mask": {
        "prefix": [
            "get_il_mask",
            "function:get_il_mask -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_il_mask(${1:decoder_id});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_il_mask(int decoder_id);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_tgt_pid": {
        "prefix": [
            "get_tgt_pid",
            "function:get_tgt_pid -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_tgt_pid(${1:addr}, ${2:decoder_id});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function int get_tgt_pid(bit       addr,\n int decoder_id);    "
    },
    "apci_cap_cxl_hdm_decoder :: sprint_decoded_ranges": {
        "prefix": [
            "sprint_decoded_ranges",
            "function:sprint_decoded_ranges -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "sprint_decoded_ranges(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function string sprint_decoded_ranges();    "
    },
    "apci_cap_cxl_hdm_decoder :: get_decoder_cnt": {
        "prefix": [
            "get_decoder_cnt",
            "function:get_decoder_cnt -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_decoder_cnt(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function int get_decoder_cnt();    "
    },
    "apci_cap_cxl_hdm_decoder :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_hdm_decoder :: get_decoder_hpa_mem_base": {
        "prefix": [
            "get_decoder_hpa_mem_base",
            "function:get_decoder_hpa_mem_base -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_decoder_hpa_mem_base(${1:decoder});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_decoder_hpa_mem_base(int decoder);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_decoder_hpa_mem_size": {
        "prefix": [
            "get_decoder_hpa_mem_size",
            "function:get_decoder_hpa_mem_size -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_decoder_hpa_mem_size(${1:decoder});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_decoder_hpa_mem_size(int decoder);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_decoder_dpa_skip": {
        "prefix": [
            "get_decoder_dpa_skip",
            "function:get_decoder_dpa_skip -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_decoder_dpa_skip(${1:decoder});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_decoder_dpa_skip(int decoder);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_decoder_dpa_size": {
        "prefix": [
            "get_decoder_dpa_size",
            "function:get_decoder_dpa_size -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_decoder_dpa_size(${1:decoder});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_decoder_dpa_size(int decoder);    "
    },
    "apci_cap_cxl_hdm_decoder :: get_decoder_dpa_base": {
        "prefix": [
            "get_decoder_dpa_base",
            "function:get_decoder_dpa_base -> apci_cap_cxl_hdm_decoder"
        ],
        "body": [
            "get_decoder_dpa_base(${1:decoder});"
        ],
        "description": "[Class:apci_cap_cxl_hdm_decoder]\n     virtual function bit       get_decoder_dpa_base(int decoder);     "
    },
    "apci_cap_cxl_ext_security": {
        "prefix": "apci_cap_cxl_ext_security",
        "body": [
            "apci_cap_cxl_ext_security  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_ext_security extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_ext_security :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_ext_security"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_ext_security]\n     function new(string name = \"apci_cap_cxl_ext_security\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_ext_security :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_cxl_ext_security"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_ext_security]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cap_cxl_ext_security :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_ext_security"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_ext_security]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_ext_security :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_ext_security"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_ext_security]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_ide": {
        "prefix": "apci_cap_cxl_ide",
        "body": [
            "apci_cap_cxl_ide  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_ide extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_ide :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_ide"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_ide]\n     function new(string name = \"apci_cap_cxl_ide\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_ide :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_ide"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_ide]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_ide :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_ide"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_ide]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_snoop_filter": {
        "prefix": "apci_cap_cxl_snoop_filter",
        "body": [
            "apci_cap_cxl_snoop_filter  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_snoop_filter extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_snoop_filter :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_snoop_filter"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_snoop_filter]\n     function new(string name = \"apci_cap_cxl_snoop_filter\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_snoop_filter :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_snoop_filter"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_snoop_filter]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_snoop_filter :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_snoop_filter"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_snoop_filter]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_arb_mux": {
        "prefix": "apci_cap_cxl_arb_mux",
        "body": [
            "apci_cap_cxl_arb_mux  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_arb_mux extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_arb_mux :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_arb_mux"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_arb_mux]\n     function new(string name = \"apci_cap_cxl_arb_mux\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_arb_mux :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_arb_mux"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_arb_mux]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_arb_mux :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_arb_mux"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_arb_mux]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_bar_virt_acl": {
        "prefix": "apci_cap_cxl_bar_virt_acl",
        "body": [
            "apci_cap_cxl_bar_virt_acl  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_bar_virt_acl extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_bar_virt_acl :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_bar_virt_acl"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_bar_virt_acl]\n     function new(string name = \"apci_cap_cxl_bar_virt_acl\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_bar_virt_acl :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_bar_virt_acl"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_bar_virt_acl]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_bar_virt_acl :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_cxl_bar_virt_acl"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_bar_virt_acl]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cap_cxl_bar_virt_acl :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_bar_virt_acl"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_bar_virt_acl]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_dev_reg_if": {
        "prefix": "apci_cap_cxl_dev_reg_if",
        "body": [
            "apci_cap_cxl_dev_reg_if  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_dev_reg_if extends apci_mmio_cap; \n"
    },
    "apci_cap_cxl_dev_reg_if :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_dev_reg_if"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:array_size});"
        ],
        "description": "[Class:apci_cap_cxl_dev_reg_if]\n     function new(string name = \"apci_cap_cxl_dev_reg_if\",\n apci_log log = null,\n int array_size = 1);     "
    },
    "apci_cap_cxl_dev_reg_if :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_dev_reg_if"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_dev_reg_if]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_dev_reg_if :: get_avery_cap_id": {
        "prefix": [
            "get_avery_cap_id",
            "function:get_avery_cap_id -> apci_cap_cxl_dev_reg_if"
        ],
        "body": [
            "get_avery_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_dev_reg_if]\n         virtual function int get_avery_cap_id();    "
    },
    "apci_cap_cxl_dev_reg_if :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_cxl_dev_reg_if"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_dev_reg_if]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cap_cxl_dev_reg_if :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_dev_reg_if"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_dev_reg_if]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_dev_status": {
        "prefix": "apci_cap_cxl_dev_status",
        "body": [
            "apci_cap_cxl_dev_status  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_dev_status extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_dev_status :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_dev_status"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_dev_status]\n     function new(string name = \"apci_cap_cxl_dev_status\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_dev_status :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_dev_status"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_dev_status]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_dev_status :: get_avery_cap_id": {
        "prefix": [
            "get_avery_cap_id",
            "function:get_avery_cap_id -> apci_cap_cxl_dev_status"
        ],
        "body": [
            "get_avery_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_dev_status]\n     virtual function int get_avery_cap_id();    "
    },
    "apci_cap_cxl_dev_status :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_dev_status"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_dev_status]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_mailbox_base": {
        "prefix": "apci_cap_cxl_mailbox_base",
        "body": [
            "apci_cap_cxl_mailbox_base  ${0:name_class};"
        ],
        "description": "virtual class apci_cap_cxl_mailbox_base extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_mailbox_base :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_mailbox_base"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_mailbox_base]\n     function new(string name = \"apci_cap_cxl_mailbox_base\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_mailbox_base :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_cxl_mailbox_base"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_mailbox_base]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cap_cxl_mailbox_base :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_mailbox_base"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_mailbox_base]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_mailbox_base :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_mailbox_base"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_mailbox_base]\n     virtual function bit       get_cap_id();                                                                                                                                    "
    },
    "apci_cap_cxl_pri_mailbox": {
        "prefix": "apci_cap_cxl_pri_mailbox",
        "body": [
            "apci_cap_cxl_pri_mailbox  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_pri_mailbox extends apci_cap_cxl_mailbox_base;\n"
    },
    "apci_cap_cxl_pri_mailbox :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_pri_mailbox"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_pri_mailbox]\n     function new(string name = \"apci_cap_cxl_pri_mailbox\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_pri_mailbox :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_pri_mailbox"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_pri_mailbox]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_pri_mailbox :: get_avery_cap_id": {
        "prefix": [
            "get_avery_cap_id",
            "function:get_avery_cap_id -> apci_cap_cxl_pri_mailbox"
        ],
        "body": [
            "get_avery_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_pri_mailbox]\n     virtual function int get_avery_cap_id();    "
    },
    "apci_cap_cxl_sec_mailbox": {
        "prefix": "apci_cap_cxl_sec_mailbox",
        "body": [
            "apci_cap_cxl_sec_mailbox  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_sec_mailbox extends apci_cap_cxl_mailbox_base;\n"
    },
    "apci_cap_cxl_sec_mailbox :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_sec_mailbox"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_sec_mailbox]\n     function new(string name = \"apci_cap_cxl_sec_mailbox\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_sec_mailbox :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_sec_mailbox"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_sec_mailbox]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_sec_mailbox :: get_avery_cap_id": {
        "prefix": [
            "get_avery_cap_id",
            "function:get_avery_cap_id -> apci_cap_cxl_sec_mailbox"
        ],
        "body": [
            "get_avery_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_sec_mailbox]\n     virtual function int get_avery_cap_id();    "
    },
    "apci_cap_cxl_mem_dev": {
        "prefix": "apci_cap_cxl_mem_dev",
        "body": [
            "apci_cap_cxl_mem_dev  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_mem_dev extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_mem_dev :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_mem_dev"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_mem_dev]\n     function new(string name = \"apci_cap_cxl_mem_dev\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_mem_dev :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_mem_dev"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_mem_dev]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_cxl_mem_dev :: get_avery_cap_id": {
        "prefix": [
            "get_avery_cap_id",
            "function:get_avery_cap_id -> apci_cap_cxl_mem_dev"
        ],
        "body": [
            "get_avery_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_mem_dev]\n     virtual function int get_avery_cap_id();    "
    },
    "apci_cap_cxl_mem_dev :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_mem_dev"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_mem_dev]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_cxl_dev_cmd_if": {
        "prefix": "apci_cap_cxl_dev_cmd_if",
        "body": [
            "apci_cap_cxl_dev_cmd_if  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_dev_cmd_if extends apci_mmio_cap;\n"
    },
    "apci_cap_cxl_dev_cmd_if :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_dev_cmd_if"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_cap_cxl_dev_cmd_if]\n     function new(string name = \"apci_cap_cxl_dev_cmd_if\",\n apci_log log = null);    "
    },
    "apci_cap_cxl_dev_cmd_if :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_dev_cmd_if"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_dev_cmd_if]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_dvsec_cxl_device_test": {
        "prefix": "apci_cap_dvsec_cxl_device_test",
        "body": [
            "apci_cap_dvsec_cxl_device_test  ${0:name_class};"
        ],
        "description": "class apci_cap_dvsec_cxl_device_test extends apci_cap_dvsec;\n"
    },
    "apci_cap_dvsec_cxl_device_test :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_dvsec_cxl_device_test"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_dvsec_cxl_device_test]\n     function new(string name = \"apci_cap_dvsec_cxl_device_test\",\n apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_cxl_test_alg": {
        "prefix": "apci_cap_cxl_test_alg",
        "body": [
            "apci_cap_cxl_test_alg  ${0:name_class};"
        ],
        "description": "class apci_cap_cxl_test_alg extends apci_capability;\n"
    },
    "apci_cap_cxl_test_alg :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_cxl_test_alg"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_cap_cxl_test_alg]\n     function new(string name = \"apci_cap_cxl_test_alg\");    "
    },
    "apci_cap_cxl_test_alg :: fwrite_cb": {
        "prefix": [
            "fwrite_cb",
            "function:fwrite_cb -> apci_cap_cxl_test_alg"
        ],
        "body": [
            "fwrite_cb(${1:f}, ${2:old_v});"
        ],
        "description": "[Class:apci_cap_cxl_test_alg]\n     virtual function void fwrite_cb(avery_reg_field f,\n avery_reg_val_t old_v);    "
    },
    "apci_cap_cxl_test_alg :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_cxl_test_alg"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_cxl_test_alg]\n     virtual function bit       get_cap_id();                                                                                                                                    "
    },
    "apci_cap_cxl_test_alg :: reset_cap": {
        "prefix": [
            "reset_cap",
            "function:reset_cap -> apci_cap_cxl_test_alg"
        ],
        "body": [
            "reset_cap(${1:kind});"
        ],
        "description": "[Class:apci_cap_cxl_test_alg]\n     virtual function void reset_cap(apci_rst_e kind);                                                                                                                        "
    },
    "apci_cap_doe": {
        "prefix": "apci_cap_doe",
        "body": [
            "apci_cap_doe  ${0:name_class};"
        ],
        "description": "class apci_cap_doe extends apci_capability;\n"
    },
    "apci_cap_doe :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_doe"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_doe]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_doe :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_doe"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_doe]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_doe :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_doe"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_doe]\n     virtual function bit       get_cap_id();    "
    },
    "apci_cap_doe :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_doe"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_doe]\n     function new(string name = \"apci_cap_doe\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_doe :: get_cap_size": {
        "prefix": [
            "get_cap_size",
            "function:get_cap_size -> apci_cap_doe"
        ],
        "body": [
            "get_cap_size(${0:});"
        ],
        "description": "[Class:apci_cap_doe]\n     virtual function bit       get_cap_size();    "
    },
    "apci_cap_doe :: fwrite_cb": {
        "prefix": [
            "fwrite_cb",
            "function:fwrite_cb -> apci_cap_doe"
        ],
        "body": [
            "fwrite_cb(${1:f}, ${2:old_v});"
        ],
        "description": "[Class:apci_cap_doe]\n     virtual function void fwrite_cb(avery_reg_field f,\n avery_reg_val_t old_v);    "
    },
    "apci_cap_doe_err_log_access": {
        "prefix": "apci_cap_doe_err_log_access",
        "body": [
            "apci_cap_doe_err_log_access  ${0:name_class};"
        ],
        "description": "class apci_cap_doe_err_log_access extends apci_cap_doe;\n"
    },
    "apci_cap_doe_table_access": {
        "prefix": "apci_cap_doe_table_access",
        "body": [
            "apci_cap_doe_table_access  ${0:name_class};"
        ],
        "description": "class apci_cap_doe_table_access extends apci_cap_doe;\n"
    },
    "apci_cap_ide": {
        "prefix": "apci_cap_ide",
        "body": [
            "apci_cap_ide  ${0:name_class};"
        ],
        "description": "class apci_cap_ide extends apci_capability;\n"
    },
    "apci_cap_ide :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_cap_ide"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function void set_next_cap_offset(avery_u16 v);    "
    },
    "apci_cap_ide :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_cap_ide"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_cap_ide :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_cap_ide"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function bit       get_cap_id();                                                                                                                                    "
    },
    "apci_cap_ide :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cap_ide"
        ],
        "body": [
            "new(${1:name}, ${2:ptype});"
        ],
        "description": "[Class:apci_cap_ide]\n     function new(string name = \"apci_cap_ide\",\n                 apci_port_type ptype = APCI_PORT_unknown);    "
    },
    "apci_cap_ide :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> apci_cap_ide"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function void create_dynamic_fields();    "
    },
    "apci_cap_ide :: create_sec_dynamic_fields": {
        "prefix": [
            "create_sec_dynamic_fields",
            "function:create_sec_dynamic_fields -> apci_cap_ide"
        ],
        "body": [
            "create_sec_dynamic_fields(${0:});"
        ],
        "description": "[Class:apci_cap_ide]\n     function void create_sec_dynamic_fields();    "
    },
    "apci_cap_ide :: is_id_exist": {
        "prefix": [
            "is_id_exist",
            "function:is_id_exist -> apci_cap_ide"
        ],
        "body": [
            "is_id_exist(${1:id});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function int is_id_exist(bit       id);    "
    },
    "apci_cap_ide :: is_stream_enable": {
        "prefix": [
            "is_stream_enable",
            "function:is_stream_enable -> apci_cap_ide"
        ],
        "body": [
            "is_stream_enable(${1:id});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function int is_stream_enable(bit       id);    "
    },
    "apci_cap_ide :: is_link_stream": {
        "prefix": [
            "is_link_stream",
            "function:is_link_stream -> apci_cap_ide"
        ],
        "body": [
            "is_link_stream(${1:id});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function int is_link_stream(bit       id);    "
    },
    "apci_cap_ide :: get_stream_tc": {
        "prefix": [
            "get_stream_tc",
            "function:get_stream_tc -> apci_cap_ide"
        ],
        "body": [
            "get_stream_tc(${1:id});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function int get_stream_tc(bit       id);    "
    },
    "apci_cap_ide :: get_rid_base": {
        "prefix": [
            "get_rid_base",
            "function:get_rid_base -> apci_cap_ide"
        ],
        "body": [
            "get_rid_base(${1:id});"
        ],
        "description": "[Class:apci_cap_ide]\n     virtual function bit       get_rid_base(bit       id);    "
    },
    "apci_cap_ide :: get_aggregate_size": {
        "prefix": [
            "get_aggregate_size",
            "function:get_aggregate_size -> apci_cap_ide"
        ],
        "body": [
            "get_aggregate_size(${1:id}, ${2:mode});"
        ],
        "description": "[Class:apci_cap_ide]\n     function int get_aggregate_size(bit       id,\n int mode);    "
    },
    "apci_cap_ide :: is_pcrc_enable": {
        "prefix": [
            "is_pcrc_enable",
            "function:is_pcrc_enable -> apci_cap_ide"
        ],
        "body": [
            "is_pcrc_enable(${1:id});"
        ],
        "description": "[Class:apci_cap_ide]\n     function int is_pcrc_enable(bit       id);    "
    },
    "apci_cap_ide :: get_stream_id_from_tc": {
        "prefix": [
            "get_stream_id_from_tc",
            "function:get_stream_id_from_tc -> apci_cap_ide"
        ],
        "body": [
            "get_stream_id_from_tc(${1:tc});"
        ],
        "description": "[Class:apci_cap_ide]\n     function int get_stream_id_from_tc (bit       tc);    "
    },
    "acxl_cdat_header": {
        "prefix": "acxl_cdat_header",
        "body": [
            "acxl_cdat_header  ${0:name_class};"
        ],
        "description": "class acxl_cdat_header extends avery_reg;\n"
    },
    "acxl_cdat_header :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_header"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_cdat_header]\n     function new(string name = \"acxl_cdat_header\");    "
    },
    "acxl_cdat_dsmas": {
        "prefix": "acxl_cdat_dsmas",
        "body": [
            "acxl_cdat_dsmas  ${0:name_class};"
        ],
        "description": "class acxl_cdat_dsmas extends avery_reg;\n"
    },
    "acxl_cdat_dsmas :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_dsmas"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_cdat_dsmas]\n     function new(string name = \"acxl_cdat_dsmas\");    "
    },
    "acxl_cdat_dslbis": {
        "prefix": "acxl_cdat_dslbis",
        "body": [
            "acxl_cdat_dslbis  ${0:name_class};"
        ],
        "description": "class acxl_cdat_dslbis extends avery_reg;\n"
    },
    "acxl_cdat_dslbis :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_dslbis"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_cdat_dslbis]\n     function new(string name = \"acxl_cdat_dslbis\");    "
    },
    "acxl_cdat_dsmscis": {
        "prefix": "acxl_cdat_dsmscis",
        "body": [
            "acxl_cdat_dsmscis  ${0:name_class};"
        ],
        "description": "class acxl_cdat_dsmscis extends avery_reg;\n"
    },
    "acxl_cdat_dsmscis :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_dsmscis"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_cdat_dsmscis]\n     function new(string name = \"acxl_cdat_dsmscis\");    "
    },
    "acxl_cdat_dsis": {
        "prefix": "acxl_cdat_dsis",
        "body": [
            "acxl_cdat_dsis  ${0:name_class};"
        ],
        "description": "class acxl_cdat_dsis extends avery_reg;\n"
    },
    "acxl_cdat_dsis :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_dsis"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_cdat_dsis]\n     function new(string name = \"acxl_cdat_dsis\");    "
    },
    "acxl_cdat_dsemts": {
        "prefix": "acxl_cdat_dsemts",
        "body": [
            "acxl_cdat_dsemts  ${0:name_class};"
        ],
        "description": "class acxl_cdat_dsemts extends avery_reg;\n"
    },
    "acxl_cdat_dsemts :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_dsemts"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_cdat_dsemts]\n     function new(string name = \"acxl_cdat_dsemts\");    "
    },
    "acxl_cdat_sslbis": {
        "prefix": "acxl_cdat_sslbis",
        "body": [
            "acxl_cdat_sslbis  ${0:name_class};"
        ],
        "description": "class acxl_cdat_sslbis extends avery_reg;\n"
    },
    "acxl_cdat_sslbis :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cdat_sslbis"
        ],
        "body": [
            "new(${1:name}, ${2:num_ports});"
        ],
        "description": "[Class:acxl_cdat_sslbis]\n     function new(string name = \"acxl_cdat_sslbis\",\n int num_ports);    "
    },
    "acxl_cdat_sslbis :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> acxl_cdat_sslbis"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:acxl_cdat_sslbis]\n     virtual function void create_dynamic_fields();      "
    },
    "apci_cb_rx_err_logic_idle": {
        "prefix": "apci_cb_rx_err_logic_idle",
        "body": [
            "apci_cb_rx_err_logic_idle  ${0:name_class};"
        ],
        "description": "class apci_cb_rx_err_logic_idle extends apci_callbacks;\n"
    },
    "apci_cb_rx_err_logic_idle :: tx_sym_before_scramble": {
        "prefix": [
            "tx_sym_before_scramble",
            "function:tx_sym_before_scramble -> apci_cb_rx_err_logic_idle"
        ],
        "body": [
            "tx_sym_before_scramble(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:raw});"
        ],
        "description": "[Class:apci_cb_rx_err_logic_idle]\n     virtual function void tx_sym_before_scramble(                  apci_device    bfm           ,\n                  int            port_id       ,\n                  int            logic_lane_num,\n            inout apci_raw_sym_t raw);    "
    },
    "cb_eios_any_lane": {
        "prefix": "cb_eios_any_lane",
        "body": [
            "cb_eios_any_lane  ${0:name_class};"
        ],
        "description": "class cb_eios_any_lane extends apci_callbacks;\n"
    },
    "cb_eios_any_lane :: tx_os_enter_lane": {
        "prefix": [
            "tx_os_enter_lane",
            "function:tx_os_enter_lane -> cb_eios_any_lane"
        ],
        "body": [
            "tx_os_enter_lane(${1:bfm}, ${2:port_id}, ${3:active_oses}, ${4:inactive_oses});"
        ],
        "description": "[Class:cb_eios_any_lane]\n     virtual function void tx_os_enter_lane(            apci_device bfm            ,\n            int         port_id        ,\n            ref apci_os active_oses        ,\n            ref apci_os inactive_oses              );    "
    },
    "apci_seq_util": {
        "prefix": "apci_seq_util",
        "body": [
            "apci_seq_util  ${0:name_class};"
        ],
        "description": "class apci_seq_util extends apci_seq_common;\n"
    },
    "apci_seq_util :: new": {
        "prefix": [
            "new",
            "function:new -> apci_seq_util"
        ],
        "body": [
            "new(${1:bfm}, ${2:rc_app_bfm}, ${3:target}, ${4:testcase});"
        ],
        "description": "[Class:apci_seq_util]\n     function new(apci_device bfm,\n apci_device rc_app_bfm = null,\n apci_device target = null,\n apci_testcase_base testcase = null);    "
    },
    "apci_seq_util :: update_vf_bdf": {
        "prefix": [
            "update_vf_bdf",
            "task:update_vf_bdf -> apci_seq_util"
        ],
        "body": [
            "update_vf_bdf(${1:mgr});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task update_vf_bdf(ref apci_device_mgr mgr);    "
    },
    "apci_seq_util :: get_func_info_by_bdf": {
        "prefix": [
            "get_func_info_by_bdf",
            "function:get_func_info_by_bdf -> apci_seq_util"
        ],
        "body": [
            "get_func_info_by_bdf(${1:bdf}, ${2:mgrs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_func_info get_func_info_by_bdf (int bdf,\n ref apci_device_mgr mgrs      );    "
    },
    "apci_seq_util :: get_func_info_by_dev": {
        "prefix": [
            "get_func_info_by_dev",
            "function:get_func_info_by_dev -> apci_seq_util"
        ],
        "body": [
            "get_func_info_by_dev(${1:tgt_dev}, ${2:mgrs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_func_info get_func_info_by_dev(apci_device tgt_dev,\n apci_device_mgr mgrs      );     "
    },
    "apci_seq_util :: get_mgr_by_dev": {
        "prefix": [
            "get_mgr_by_dev",
            "function:get_mgr_by_dev -> apci_seq_util"
        ],
        "body": [
            "get_mgr_by_dev(${1:tgt_dev}, ${2:mgrs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_device_mgr get_mgr_by_dev(apci_device tgt_dev,\n apci_device_mgr mgrs      );    "
    },
    "apci_seq_util :: fetch_cfg_space": {
        "prefix": [
            "fetch_cfg_space",
            "task:fetch_cfg_space -> apci_seq_util"
        ],
        "body": [
            "fetch_cfg_space(${1:tgt}, ${2:cs}, ${3:raw_dwords});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task fetch_cfg_space(apci_bdf_t tgt,\n output apci_cfg_space cs,\n ref bit       raw_dwords      );    "
    },
    "apci_seq_util :: detect_wmsk": {
        "prefix": [
            "detect_wmsk",
            "function:detect_wmsk -> apci_seq_util"
        ],
        "body": [
            "detect_wmsk(${1:v});"
        ],
        "description": "[Class:apci_seq_util]\n     local function bit       detect_wmsk(bit       v);    "
    },
    "apci_seq_util :: collect_dut_funcs": {
        "prefix": [
            "collect_dut_funcs",
            "function:collect_dut_funcs -> apci_seq_util"
        ],
        "body": [
            "collect_dut_funcs(${1:mgrs}, ${2:funcs}, ${3:mode}, ${4:sorting}, ${5:num_vfs});"
        ],
        "description": "[Class:apci_seq_util]\n     static function void collect_dut_funcs(            ref   apci_device_mgr mgrs        ,\n            ref   apci_func_info  funcs       ,\n            input string          mode    = \"\",\n            input string          sorting = \"\",\n            input int             num_vfs = 5 );    "
    },
    "apci_seq_util :: collect_link_partner_info": {
        "prefix": [
            "collect_link_partner_info",
            "task:collect_link_partner_info -> apci_seq_util"
        ],
        "body": [
            "collect_link_partner_info(${1:me}, ${2:port}, ${3:funcs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task collect_link_partner_info(apci_device me,\n int port,\n output apci_func_info funcs      );    "
    },
    "apci_seq_util :: check_switch_atomic_routing": {
        "prefix": [
            "check_switch_atomic_routing",
            "task:check_switch_atomic_routing -> apci_seq_util"
        ],
        "body": [
            "check_switch_atomic_routing(${1:atomic_routing_sup});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_switch_atomic_routing(output int atomic_routing_sup);    "
    },
    "apci_seq_util :: set_err_rpt_enable": {
        "prefix": [
            "set_err_rpt_enable",
            "task:set_err_rpt_enable -> apci_seq_util"
        ],
        "body": [
            "set_err_rpt_enable(${1:mgrs}, ${2:tgt_func}, ${3:tgt_val});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_err_rpt_enable(apci_device_mgr mgrs,\n apci_func_info tgt_func,\n bit       tgt_val);    "
    },
    "apci_seq_util :: check_cap_exist": {
        "prefix": [
            "check_cap_exist",
            "task:check_cap_exist -> apci_seq_util"
        ],
        "body": [
            "check_cap_exist(${1:cap}, ${2:bdf}, ${3:found});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_cap_exist(    input apci_capability cap,\n    input apci_bdf_t bdf,\n    output int found);    "
    },
    "apci_seq_util :: search_cap": {
        "prefix": [
            "search_cap",
            "task:search_cap -> apci_seq_util"
        ],
        "body": [
            "search_cap(${1:cap}, ${2:bdf}, ${3:cap_addrs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task search_cap(        input  apci_capability  cap,\n       apci_bdf_tbdf,\n        output bit       cap_addrs              );    "
    },
    "apci_seq_util :: wait_rx_ufc": {
        "prefix": [
            "wait_rx_ufc",
            "task:wait_rx_ufc -> apci_seq_util"
        ],
        "body": [
            "wait_rx_ufc(${1:port_id}, ${2:vc_id}, ${3:t}, ${4:fc_h}, ${5:fc_d}, ${6:dp}, ${7:timer}, ${8:msg});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task wait_rx_ufc(input  int      port_id = 0,\ninput  int            vc_id = 0,\n        input  apci_dllp_type t,\n        input  int      fc_h = 0,\ninput  int      fc_d = 0,\n        output apci_dllp      dp,\n        input  time      timer = 0,\n         input  string      msg = \"\"        );    "
    },
    "apci_seq_util :: wait_tx_acknak": {
        "prefix": [
            "wait_tx_acknak",
            "task:wait_tx_acknak -> apci_seq_util"
        ],
        "body": [
            "wait_tx_acknak(${1:port_id}, ${2:t}, ${3:seq_num}, ${4:dp}, ${5:timer}, ${6:msg});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task wait_tx_acknak(input  int      port_id = 0,\ninput  apci_dllp_type t,\ninput  int      seq_num = 0,\noutput apci_dllp      dp,\ninput  time      timer = 0,\n input  string      msg = \"\");    "
    },
    "apci_seq_util :: wait_rx_acknak": {
        "prefix": [
            "wait_rx_acknak",
            "task:wait_rx_acknak -> apci_seq_util"
        ],
        "body": [
            "wait_rx_acknak(${1:port_id}, ${2:t}, ${3:seq_num}, ${4:dp}, ${5:timer}, ${6:msg});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task wait_rx_acknak(input  int      port_id = 0,\ninput  apci_dllp_type t,\ninput  int      seq_num = 0,\noutput apci_dllp      dp,\ninput  time      timer = 0,\n input  string      msg = \"\");    "
    },
    "apci_seq_util :: get_target_func_info": {
        "prefix": [
            "get_target_func_info",
            "task:get_target_func_info -> apci_seq_util"
        ],
        "body": [
            "get_target_func_info(${1:tgt_finfs}, ${2:mode}, ${3:num_vfs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_target_func_info(output apci_func_info tgt_finfs      ,\n input string mode = \"\",\n input int num_vfs = 5);     "
    },
    "apci_seq_util :: get_target_mgr": {
        "prefix": [
            "get_target_mgr",
            "task:get_target_mgr -> apci_seq_util"
        ],
        "body": [
            "get_target_mgr(${1:tgt_mgrs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_target_mgr(output apci_device_mgr tgt_mgrs      );     "
    },
    "apci_seq_util :: get_ep_devices": {
        "prefix": [
            "get_ep_devices",
            "task:get_ep_devices -> apci_seq_util"
        ],
        "body": [
            "get_ep_devices(${1:bdf}, ${2:all_devs_q}, ${3:tgt_devs_q});"
        ],
        "description": "[Class:apci_seq_util]\n virtual task get_ep_devices(input apci_bdf_t bdf,\n ref apci_device all_devs_q      ,\n ref apci_device tgt_devs_q      );    "
    },
    "apci_seq_util :: get_target_speeds": {
        "prefix": [
            "get_target_speeds",
            "task:get_target_speeds -> apci_seq_util"
        ],
        "body": [
            "get_target_speeds(${1:f}, ${2:highest_rate}, ${3:target_speeds}, ${4:disable_eq_bypass});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_target_speeds(input apci_func_info f,\n output int highest_rate,\n output int target_speeds      ,\n input bit disable_eq_bypass = 0);     "
    },
    "apci_seq_util :: disable_gen5_eq_bypass": {
        "prefix": [
            "disable_gen5_eq_bypass",
            "task:disable_gen5_eq_bypass -> apci_seq_util"
        ],
        "body": [
            "disable_gen5_eq_bypass(${1:f}, ${2:dn_bdf}, ${3:up_bdf});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task disable_gen5_eq_bypass(input apci_func_info f = null,\n input apci_bdf_t dn_bdf = 0,\n input apci_bdf_t up_bdf = 0);    "
    },
    "apci_seq_util :: backdoor_bfm_gen5_eq_option": {
        "prefix": [
            "backdoor_bfm_gen5_eq_option",
            "function:backdoor_bfm_gen5_eq_option -> apci_seq_util"
        ],
        "body": [
            "backdoor_bfm_gen5_eq_option(${1:eq_option}, ${2:all_bfms});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function void backdoor_bfm_gen5_eq_option (apci_link_behavior_ctrl_e eq_option,\n apci_device all_bfms      );    "
    },
    "apci_seq_util :: get_link_partner_bdf": {
        "prefix": [
            "get_link_partner_bdf",
            "task:get_link_partner_bdf -> apci_seq_util"
        ],
        "body": [
            "get_link_partner_bdf(${1:me}, ${2:port}, ${3:bdf});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_link_partner_bdf(apci_device me,\n int port,\n output apci_bdf_t bdf);    "
    },
    "apci_seq_util :: get_link_partner_info": {
        "prefix": [
            "get_link_partner_info",
            "task:get_link_partner_info -> apci_seq_util"
        ],
        "body": [
            "get_link_partner_info(${1:me}, ${2:port}, ${3:peer});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_link_partner_info(apci_device me,\n int port,\n output apci_func_info peer);    "
    },
    "apci_seq_util :: get_link_partner_mgr": {
        "prefix": [
            "get_link_partner_mgr",
            "task:get_link_partner_mgr -> apci_seq_util"
        ],
        "body": [
            "get_link_partner_mgr(${1:me}, ${2:port}, ${3:peer});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_link_partner_mgr(apci_device me,\n int port,\n output apci_device_mgr peer);    "
    },
    "apci_seq_util :: get_link_bdf": {
        "prefix": [
            "get_link_bdf",
            "task:get_link_bdf -> apci_seq_util"
        ],
        "body": [
            "get_link_bdf(${1:f}, ${2:dn_port_bdf}, ${3:up_port_bdf});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_link_bdf(apci_func_info f,\n output apci_bdf_t dn_port_bdf,\n output apci_bdf_t up_port_bdf);    "
    },
    "apci_seq_util :: get_link_width": {
        "prefix": [
            "get_link_width",
            "task:get_link_width -> apci_seq_util"
        ],
        "body": [
            "get_link_width(${1:bdf}, ${2:link_width}, ${3:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_link_width(apci_bdf_t bdf,\n output int link_width,\n output bit err);    "
    },
    "apci_seq_util :: get_highest_common_rate": {
        "prefix": [
            "get_highest_common_rate",
            "task:get_highest_common_rate -> apci_seq_util"
        ],
        "body": [
            "get_highest_common_rate(${1:f}, ${2:highest_rate});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_highest_common_rate(apci_func_info f,\n output int highest_rate);    "
    },
    "apci_seq_util :: speed_to_rate": {
        "prefix": [
            "speed_to_rate",
            "function:speed_to_rate -> apci_seq_util"
        ],
        "body": [
            "speed_to_rate(${1:sp});"
        ],
        "description": "[Class:apci_seq_util]\n     local function bit       speed_to_rate(bit       sp);    "
    },
    "apci_seq_util :: do_dl_down_rst": {
        "prefix": [
            "do_dl_down_rst",
            "task:do_dl_down_rst -> apci_seq_util"
        ],
        "body": [
            "do_dl_down_rst(${1:func}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_dl_down_rst(input apci_func_info func,\n output bit err);    "
    },
    "apci_seq_util :: do_2nd_bus_rst": {
        "prefix": [
            "do_2nd_bus_rst",
            "task:do_2nd_bus_rst -> apci_seq_util"
        ],
        "body": [
            "do_2nd_bus_rst(${1:func}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_2nd_bus_rst(input apci_func_info func,\n output bit err);    "
    },
    "apci_seq_util :: do_flr": {
        "prefix": [
            "do_flr",
            "task:do_flr -> apci_seq_util"
        ],
        "body": [
            "do_flr(${1:func}, ${2:err}, ${3:na});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_flr(input apci_func_info func,\n output bit err,\n output bit na);    "
    },
    "apci_seq_util :: read_secondary_bdf": {
        "prefix": [
            "read_secondary_bdf",
            "task:read_secondary_bdf -> apci_seq_util"
        ],
        "body": [
            "read_secondary_bdf(${1:type1_bdf}, ${2:bdf}, ${3:err}, ${4:caller});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task read_secondary_bdf(apci_bdf_t  type1_bdf,\n output apci_bdf_t bdf,\n output bit err,\n input string caller);    "
    },
    "apci_seq_util :: program_target_link_speed_if_needed": {
        "prefix": [
            "program_target_link_speed_if_needed",
            "task:program_target_link_speed_if_needed -> apci_seq_util"
        ],
        "body": [
            "program_target_link_speed_if_needed(${1:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task program_target_link_speed_if_needed(bit err);    "
    },
    "apci_seq_util :: do_speed_change_by_bdf": {
        "prefix": [
            "do_speed_change_by_bdf",
            "task:do_speed_change_by_bdf -> apci_seq_util"
        ],
        "body": [
            "do_speed_change_by_bdf(${1:dn_port_bdf}, ${2:new_speed}, ${3:not_applicable}, ${4:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_speed_change_by_bdf(                   apci_bdf_t dn_port_bdf   ,\n                      int        new_speed,\n            output bit        not_applicable,\n            output bit        err);    "
    },
    "apci_seq_util :: do_speed_change": {
        "prefix": [
            "do_speed_change",
            "task:do_speed_change -> apci_seq_util"
        ],
        "body": [
            "do_speed_change(${1:new_speed}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_speed_change(input int new_speed = -1,\n output bit err);    "
    },
    "apci_seq_util :: do_inj_jitter": {
        "prefix": [
            "do_inj_jitter",
            "function:do_inj_jitter -> apci_seq_util"
        ],
        "body": [
            "do_inj_jitter(${1:negative}, ${2:random}, ${3:all_bfms});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function void do_inj_jitter(input bit negative = 0,\n input bit random = 0,\n apci_device all_bfms      );    "
    },
    "apci_seq_util :: do_linkwidth_change": {
        "prefix": [
            "do_linkwidth_change",
            "task:do_linkwidth_change -> apci_seq_util"
        ],
        "body": [
            "do_linkwidth_change(${1:change_linkwidth}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_linkwidth_change(input int change_linkwidth = -1,\n output bit err);    "
    },
    "apci_seq_util :: do_hot_reset": {
        "prefix": [
            "do_hot_reset",
            "task:do_hot_reset -> apci_seq_util"
        ],
        "body": [
            "do_hot_reset(${0:});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_hot_reset();    "
    },
    "apci_seq_util :: do_reset": {
        "prefix": [
            "do_reset",
            "task:do_reset -> apci_seq_util"
        ],
        "body": [
            "do_reset(${0:});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_reset();    "
    },
    "apci_seq_util :: do_disabled": {
        "prefix": [
            "do_disabled",
            "task:do_disabled -> apci_seq_util"
        ],
        "body": [
            "do_disabled(${0:});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_disabled();    "
    },
    "apci_seq_util :: do_rst_then_enum_revive": {
        "prefix": [
            "do_rst_then_enum_revive",
            "task:do_rst_then_enum_revive -> apci_seq_util"
        ],
        "body": [
            "do_rst_then_enum_revive(${1:entry}, ${2:bfms}, ${3:func}, ${4:skip_bus_master_enable}, ${5:skip_vf_enable});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_rst_then_enum_revive(input string entry = \"do_reset\",\ninput apci_device bfms       = {},\n input apci_func_info func = null,\ninput bit skip_bus_master_enable = 0,\n input bit skip_vf_enable = 0);    "
    },
    "apci_seq_util :: pick_up_non_d0_dstate": {
        "prefix": [
            "pick_up_non_d0_dstate",
            "task:pick_up_non_d0_dstate -> apci_seq_util"
        ],
        "body": [
            "pick_up_non_d0_dstate(${1:mgrs}, ${2:dstate}, ${3:no_soft_rst});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task pick_up_non_d0_dstate(input apci_device_mgr mgrs      ,\noutput apci_pm_dstate_e dstate,\noutput bit no_soft_rst    );    "
    },
    "apci_seq_util :: check_dstate_sup": {
        "prefix": [
            "check_dstate_sup",
            "task:check_dstate_sup -> apci_seq_util"
        ],
        "body": [
            "check_dstate_sup(${1:mgrs}, ${2:d1_sup}, ${3:d2_sup}, ${4:no_soft_rst});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_dstate_sup(input apci_device_mgr mgrs      ,\noutput bit d1_sup,\noutput bit d2_sup,\noutput bit no_soft_rst    );    "
    },
    "apci_seq_util :: direct_dstate": {
        "prefix": [
            "direct_dstate",
            "task:direct_dstate -> apci_seq_util"
        ],
        "body": [
            "direct_dstate(${1:test_mode}, ${2:mgrs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task direct_dstate(input apci_pm_dstate_e test_mode,\ninput apci_device_mgr mgrs          );    "
    },
    "apci_seq_util :: write_power_state": {
        "prefix": [
            "write_power_state",
            "task:write_power_state -> apci_seq_util"
        ],
        "body": [
            "write_power_state(${1:func}, ${2:test_mode});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task write_power_state (        input apci_func_info func,\n        input apci_pm_dstate_e test_mode    );    "
    },
    "apci_seq_util :: check_end2end_prefix_sup_per_func": {
        "prefix": [
            "check_end2end_prefix_sup_per_func",
            "task:check_end2end_prefix_sup_per_func -> apci_seq_util"
        ],
        "body": [
            "check_end2end_prefix_sup_per_func(${1:func}, ${2:end2end_prefix_sup}, ${3:max_end2end_tlp_prefixes}, ${4:tph_sup}, ${5:pasid_sup});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_end2end_prefix_sup_per_func(input apci_func_info   func,\noutput bit end2end_prefix_sup,\noutput byte max_end2end_tlp_prefixes,\noutput bit tph_sup,\noutput bit pasid_sup    );    "
    },
    "apci_seq_util :: corrupt_ts": {
        "prefix": [
            "corrupt_ts",
            "function:corrupt_ts -> apci_seq_util"
        ],
        "body": [
            "corrupt_ts(${1:os}, ${2:corrupt_type}, ${3:entry}, ${4:value});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function void corrupt_ts(input apci_os os,\ninput apci_os_type corrupt_type,\n input string  entry,\ninput integer value = -1);    "
    },
    "apci_seq_util :: make_ts": {
        "prefix": [
            "make_ts",
            "function:make_ts -> apci_seq_util"
        ],
        "body": [
            "make_ts(${1:os}, ${2:link_num}, ${3:lane_num}, ${4:nfts}, ${5:rate}, ${6:tc});"
        ],
        "description": "[Class:apci_seq_util]\n     local function void make_ts(apci_os os,\n apci_symbol_t link_num,\n lane_num,\n nfts,\n rate,\n tc);    "
    },
    "apci_seq_util :: create_tr": {
        "prefix": [
            "create_tr",
            "function:create_tr -> apci_seq_util"
        ],
        "body": [
            "create_tr(${1:func}, ${2:write}, ${3:tr_type}, ${4:len});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_transaction create_tr (        apci_func_info func,\n         bit write = -1,\n         apci_trans_type tr_type = APCI_TRANS_unknown,\n         int len = 1);    "
    },
    "apci_seq_util :: create_tlp": {
        "prefix": [
            "create_tlp",
            "function:create_tlp -> apci_seq_util"
        ],
        "body": [
            "create_tlp(${1:func}, ${2:cfg}, ${3:req_type}, ${4:len_input});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_tlp create_tlp(apci_func_info func,\ninput apci_cfg_space cfg = null,\n        apci_tlp_type  req_type = APCI_TLP_unknown,\nbit             len_input = 0);    "
    },
    "apci_seq_util :: create_err_tlp": {
        "prefix": [
            "create_err_tlp",
            "function:create_err_tlp -> apci_seq_util"
        ],
        "body": [
            "create_err_tlp(${1:func}, ${2:cfg}, ${3:req_type}, ${4:for_ei});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_tlp create_err_tlp(apci_func_info func,\napci_cfg_space cfg,\n        apci_tlp_type  req_type = APCI_TLP_unknown,\nbit            for_ei = 0);    "
    },
    "apci_seq_util :: get_random_funcs": {
        "prefix": [
            "get_random_funcs",
            "function:get_random_funcs -> apci_seq_util"
        ],
        "body": [
            "get_random_funcs(${1:mgrs}, ${2:tgt_funcs}, ${3:found}, ${4:num_funcs});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function void get_random_funcs(    input  apci_device_mgr  mgrs      ,\n    output apci_func_info   tgt_funcs      ,\n    output bit    found,\n    input  int              num_funcs = 5);    "
    },
    "apci_seq_util :: get_imd_dn_port": {
        "prefix": [
            "get_imd_dn_port",
            "function:get_imd_dn_port -> apci_seq_util"
        ],
        "body": [
            "get_imd_dn_port(${1:func});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function apci_bdf_t get_imd_dn_port(apci_func_info func);    "
    },
    "apci_seq_util :: do_equalization": {
        "prefix": [
            "do_equalization",
            "task:do_equalization -> apci_seq_util"
        ],
        "body": [
            "do_equalization(${1:target_speed}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n      virtual task do_equalization(    int        target_speed,\n     output bit        err     );    "
    },
    "apci_seq_util :: perform_equal": {
        "prefix": [
            "perform_equal",
            "task:perform_equal -> apci_seq_util"
        ],
        "body": [
            "perform_equal(${1:target_speed}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     task perform_equal(input byte target_speed,\n output err);    "
    },
    "apci_seq_util :: do_err_inj": {
        "prefix": [
            "do_err_inj",
            "task:do_err_inj -> apci_seq_util"
        ],
        "body": [
            "do_err_inj(${1:func}, ${2:et}, ${3:timer}, ${4:bad_tlp});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_err_inj(        input  apci_func_infofunc,\ninput  apci_error_typeet,\n        input  timetimer = 0,\noutput apci_tlpbad_tlp    );    "
    },
    "apci_seq_util :: malformed_rsvd_tlp": {
        "prefix": [
            "malformed_rsvd_tlp",
            "task:malformed_rsvd_tlp -> apci_seq_util"
        ],
        "body": [
            "malformed_rsvd_tlp(${1:p}, ${2:entry});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task malformed_rsvd_tlp (input  apci_tlp  p,\ninput  string    entry = \"\"    );    "
    },
    "apci_seq_util :: cfg_access": {
        "prefix": [
            "cfg_access",
            "task:cfg_access -> apci_seq_util"
        ],
        "body": [
            "cfg_access(${1:bdf}, ${2:is_write}, ${3:cfg_addr}, ${4:v}, ${5:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task cfg_access(input  apci_bdf_t    bdf,\n               bit           is_write = 0,\n       bit           cfg_addr = 0,\ninout  avery_u32     v,\noutput bit     err);    "
    },
    "apci_seq_util :: polling_link_training": {
        "prefix": [
            "polling_link_training",
            "task:polling_link_training -> apci_seq_util"
        ],
        "body": [
            "polling_link_training(${1:bdf}, ${2:pcie_cap}, ${3:v}, ${4:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task polling_link_training(            input  apci_bdf_t      bdf  ,\n          apci_cap_pcie   pcie_cap,\n                      avery_u64       v    ,\n                  output bit             err  );         "
    },
    "apci_seq_util :: polling_cap_change": {
        "prefix": [
            "polling_cap_change",
            "task:polling_cap_change -> apci_seq_util"
        ],
        "body": [
            "polling_cap_change(${1:bdf}, ${2:cap}, ${3:f}, ${4:v}, ${5:timer}, ${6:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task polling_cap_change(            input  apci_bdf_t      bdf  ,\n                             apci_capability cap  ,\n                             avery_reg_field f    ,\n                             avery_u64       v    ,\n                             time            timer = 0,\n                  output bit             err  );           "
    },
    "apci_seq_util :: polling_cap_unchange": {
        "prefix": [
            "polling_cap_unchange",
            "task:polling_cap_unchange -> apci_seq_util"
        ],
        "body": [
            "polling_cap_unchange(${1:is_keep}, ${2:bdf}, ${3:cap}, ${4:f}, ${5:v}, ${6:timer}, ${7:is_dw});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task polling_cap_unchange(input bit is_keep,\n     apci_bdf_t bdf,\n     apci_capability cap,\n     avery_reg_field f,\n     avery_u64 v = 0,\n           time   timer = 0,\n   bit   is_dw = 0    );    "
    },
    "apci_seq_util :: set_max_payload_size": {
        "prefix": [
            "set_max_payload_size",
            "task:set_max_payload_size -> apci_seq_util"
        ],
        "body": [
            "set_max_payload_size(${1:mgrs}, ${2:mps}, ${3:mps_dw});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_max_payload_size(input  apci_device_mgr mgrs      ,\ninput  bit       mps,\noutput intmps_dw    );    "
    },
    "apci_seq_util :: set_max_read_req_size": {
        "prefix": [
            "set_max_read_req_size",
            "task:set_max_read_req_size -> apci_seq_util"
        ],
        "body": [
            "set_max_read_req_size(${1:mgrs}, ${2:mrqs}, ${3:mrqs_dw});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_max_read_req_size(input  apci_device_mgr mgrs      ,\ninput  bit       mrqs,\noutput intmrqs_dw    );    "
    },
    "apci_seq_util :: set_highest_mps_mrqs": {
        "prefix": [
            "set_highest_mps_mrqs",
            "task:set_highest_mps_mrqs -> apci_seq_util"
        ],
        "body": [
            "set_highest_mps_mrqs(${1:mps_dw}, ${2:mrqs_dw});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_highest_mps_mrqs(output int mps_dw,\n output int mrqs_dw);    "
    },
    "apci_seq_util :: check_err_status": {
        "prefix": [
            "check_err_status",
            "task:check_err_status -> apci_seq_util"
        ],
        "body": [
            "check_err_status(${1:func}, ${2:exp_val}, ${3:err_status}, ${4:s}, ${5:mask});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_err_status(input  apci_func_info func,\ninput  bit       exp_val,\noutput bit       err_status,\nref    string   s,\ninput  bit       mask = 0    );    "
    },
    "apci_seq_util :: clear_err_status": {
        "prefix": [
            "clear_err_status",
            "task:clear_err_status -> apci_seq_util"
        ],
        "body": [
            "clear_err_status(${1:func}, ${2:aer_exist});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task clear_err_status(input apci_func_infofunc,\ninput bitaer_exist    );    "
    },
    "apci_seq_util :: enable_err_report": {
        "prefix": [
            "enable_err_report",
            "task:enable_err_report -> apci_seq_util"
        ],
        "body": [
            "enable_err_report(${1:func}, ${2:v});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task enable_err_report(input apci_func_infofunc,\ninput bit      v = 'b1111     );    "
    },
    "apci_seq_util :: disable_err_report": {
        "prefix": [
            "disable_err_report",
            "task:disable_err_report -> apci_seq_util"
        ],
        "body": [
            "disable_err_report(${1:func});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task disable_err_report(input apci_func_infofunc    );    "
    },
    "apci_seq_util :: framing_error_cap_check": {
        "prefix": [
            "framing_error_cap_check",
            "task:framing_error_cap_check -> apci_seq_util"
        ],
        "body": [
            "framing_error_cap_check(${1:func});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task framing_error_cap_check(input apci_func_infofunc    );    "
    },
    "apci_seq_util :: write_aspm_ctrl": {
        "prefix": [
            "write_aspm_ctrl",
            "task:write_aspm_ctrl -> apci_seq_util"
        ],
        "body": [
            "write_aspm_ctrl(${1:func}, ${2:new_value});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task write_aspm_ctrl (input apci_func_info func,\ninput bit       new_value    );    "
    },
    "apci_seq_util :: program_aspm_ctrl": {
        "prefix": [
            "program_aspm_ctrl",
            "task:program_aspm_ctrl -> apci_seq_util"
        ],
        "body": [
            "program_aspm_ctrl(${1:bdf}, ${2:new_value});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task program_aspm_ctrl (input  apci_bdf_t bdf,\ninput  bit         new_value    );    "
    },
    "apci_seq_util :: program_auto_speed_and_width": {
        "prefix": [
            "program_auto_speed_and_width",
            "task:program_auto_speed_and_width -> apci_seq_util"
        ],
        "body": [
            "program_auto_speed_and_width(${1:bdf}, ${2:disable_auto_speed}, ${3:disable_auto_width});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task program_auto_speed_and_width(    input  apci_bdf_t bdf,\n    input  bit        disable_auto_speed,\n       input  bit        disable_auto_width    );    "
    },
    "apci_seq_util :: wait_ltssm_and_speed": {
        "prefix": [
            "wait_ltssm_and_speed",
            "task:wait_ltssm_and_speed -> apci_seq_util"
        ],
        "body": [
            "wait_ltssm_and_speed(${1:state}, ${2:speed}, ${3:timer}, ${4:timeout_msg}, ${5:err});"
        ],
        "description": "[Class:apci_seq_util]\n     task wait_ltssm_and_speed(input apci_ltssm_state_e state,\ninput int speed = -1,\n        input time timer = test_info.ltssm_1ms_timeout,\n        input string timeout_msg = \"\",\nbit err = 0);    "
    },
    "apci_seq_util :: verify_eq_status": {
        "prefix": [
            "verify_eq_status",
            "task:verify_eq_status -> apci_seq_util"
        ],
        "body": [
            "verify_eq_status(${1:speed}, ${2:dut_func});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task verify_eq_status (input int speed = -1,\ninput apci_func_info dut_func = null    );    "
    },
    "apci_seq_util :: wait_aspm_happen": {
        "prefix": [
            "wait_aspm_happen",
            "task:wait_aspm_happen -> apci_seq_util"
        ],
        "body": [
            "wait_aspm_happen(${1:func}, ${2:exp_pm_state}, ${3:accept});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task wait_aspm_happen (input apci_func_info func,\ninput apci_aspm_control_e exp_pm_state,\ninput bit accept = 1    );    "
    },
    "apci_seq_util :: aspm_support_then_send_cfg": {
        "prefix": [
            "aspm_support_then_send_cfg",
            "task:aspm_support_then_send_cfg -> apci_seq_util"
        ],
        "body": [
            "aspm_support_then_send_cfg(${1:func}, ${2:aspm_ctrl}, ${3:not_applicable}, ${4:msg});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task aspm_support_then_send_cfg(input apci_func_info func,\ninput apci_aspm_control_e aspm_ctrl,\noutput bit not_applicable,\noutput string msg    );    "
    },
    "apci_seq_util :: enable_aspm": {
        "prefix": [
            "enable_aspm",
            "task:enable_aspm -> apci_seq_util"
        ],
        "body": [
            "enable_aspm(${1:mgrs}, ${2:aspm_ctrl}, ${3:not_applicable}, ${4:msg}, ${5:enter_pkgc_l1});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task enable_aspm(input apci_device_mgr mgrs      ,\ninput apci_aspm_control_e aspm_ctrl,\noutput bit not_applicable,\noutput string msg,\n        input  bit enter_pkgc_l1 = 1    );    "
    },
    "apci_seq_util :: disable_aspm": {
        "prefix": [
            "disable_aspm",
            "task:disable_aspm -> apci_seq_util"
        ],
        "body": [
            "disable_aspm(${1:mgrs}, ${2:not_applicable}, ${3:msg});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task disable_aspm(input apci_device_mgr mgrs      ,\noutput bit not_applicable,\noutput string msg    );    "
    },
    "apci_seq_util :: margin_get_subset_of_lanes": {
        "prefix": [
            "margin_get_subset_of_lanes",
            "function:margin_get_subset_of_lanes -> apci_seq_util"
        ],
        "body": [
            "margin_get_subset_of_lanes(${1:offset}, ${2:params}, ${3:lane_mask});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function int margin_get_subset_of_lanes(int offset,\n ref apci_margin_param params      ,\n output int lane_mask);    "
    },
    "apci_seq_util :: do_margin_cmd": {
        "prefix": [
            "do_margin_cmd",
            "task:do_margin_cmd -> apci_seq_util"
        ],
        "body": [
            "do_margin_cmd(${1:func}, ${2:cmd}, ${3:lane_no}, ${4:link_width}, ${5:err}, ${6:reports});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_cmd(    input  apci_func_info     func      ,\n    input  apci_margin_cmd    cmd       ,\n            input  int                lane_no   ,\n               input  int                link_width,\n            output bit                err       ,\n    ref    apci_margin_param  reports      );    "
    },
    "apci_seq_util :: check_margin_ready": {
        "prefix": [
            "check_margin_ready",
            "task:check_margin_ready -> apci_seq_util"
        ],
        "body": [
            "check_margin_ready(${1:func}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_margin_ready(    input  apci_func_info    func,\n    output bit               err    );    "
    },
    "apci_seq_util :: do_margin_reports": {
        "prefix": [
            "do_margin_reports",
            "task:do_margin_reports -> apci_seq_util"
        ],
        "body": [
            "do_margin_reports(${1:func}, ${2:link_width}, ${3:err}, ${4:reports}, ${5:receiver_num});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_reports(    input  apci_func_info    func,\n    input  int               link_width,\n    output bit               err,\n    ref    apci_margin_param reports      ,\n            input apci_margin_receiver_num_e receiver_num = APCI_MARGIN_RX_NUM_reserved);    "
    },
    "apci_seq_util :: do_margin_broadcast": {
        "prefix": [
            "do_margin_broadcast",
            "task:do_margin_broadcast -> apci_seq_util"
        ],
        "body": [
            "do_margin_broadcast(${1:func}, ${2:kind}, ${3:link_width}, ${4:err}, ${5:reports});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_broadcast(    input  apci_func_info     func,\n    input apci_margin_type    kind,\n    input int                 link_width,\n            output bit                err,\n    ref    apci_margin_param  reports      );    "
    },
    "apci_seq_util :: do_margin_acc_retimer_reg": {
        "prefix": [
            "do_margin_acc_retimer_reg",
            "task:do_margin_acc_retimer_reg -> apci_seq_util"
        ],
        "body": [
            "do_margin_acc_retimer_reg(${1:func}, ${2:rx_num}, ${3:payload}, ${4:link_width}, ${5:err}, ${6:reports});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_acc_retimer_reg(    input  apci_func_info      func,\n    input  apci_margin_receiver_num_e rx_num,\n    input  bit            payload,\n    input  int      link_width,\n            output bit      err,\n    ref    apci_margin_param      reports      );    "
    },
    "apci_seq_util :: do_margin_set_err_cnt_limit": {
        "prefix": [
            "do_margin_set_err_cnt_limit",
            "task:do_margin_set_err_cnt_limit -> apci_seq_util"
        ],
        "body": [
            "do_margin_set_err_cnt_limit(${1:func}, ${2:rx_num}, ${3:err_cnt}, ${4:link_width}, ${5:err}, ${6:reports});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_set_err_cnt_limit(    input  apci_func_info      func,\n    input  apci_margin_receiver_num_e rx_num,\n    input  bit            err_cnt,\n    input  int      link_width,\n            output bit      err,\n    ref    apci_margin_param      reports      );    "
    },
    "apci_seq_util :: do_margin_by_mask": {
        "prefix": [
            "do_margin_by_mask",
            "task:do_margin_by_mask -> apci_seq_util"
        ],
        "body": [
            "do_margin_by_mask(${1:func}, ${2:cmd}, ${3:lane_mask}, ${4:err}, ${5:reports});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_by_mask(    input  apci_func_info     func          ,\n    input  apci_margin_cmd    cmd           ,\n            input  bit                lane_mask     ,\n               output bit                err           ,\n    ref    apci_margin_param  reports      );    "
    },
    "apci_seq_util :: do_margin_acc_retimer": {
        "prefix": [
            "do_margin_acc_retimer",
            "task:do_margin_acc_retimer -> apci_seq_util"
        ],
        "body": [
            "do_margin_acc_retimer(${1:func}, ${2:cmd}, ${3:lane_mask}, ${4:err}, ${5:reports});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task do_margin_acc_retimer(    input  apci_func_info     func          ,\n    input  apci_margin_cmd    cmd           ,\n            input  bit                lane_mask     ,\n               output bit                err           ,\n    ref    apci_margin_param  reports      );    "
    },
    "apci_seq_util :: setup_vc": {
        "prefix": [
            "setup_vc",
            "task:setup_vc -> apci_seq_util"
        ],
        "body": [
            "setup_vc(${1:bdf}, ${2:index}, ${3:vc_en}, ${4:vc_id}, ${5:tc_vc_map}, ${6:ext_vc_cnt});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task setup_vc(apci_bdf_t bdf,\n bit       index,\n bit vc_en,\n bit       vc_id,\n   bit       tc_vc_map,\n bit       ext_vc_cnt);    "
    },
    "apci_seq_util :: set_msix_vector_mask": {
        "prefix": [
            "set_msix_vector_mask",
            "task:set_msix_vector_mask -> apci_seq_util"
        ],
        "body": [
            "set_msix_vector_mask(${1:bdf}, ${2:vec_index}, ${3:mask});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_msix_vector_mask(apci_bdf_t bdf,\n int vec_index,\n bit mask);    "
    },
    "apci_seq_util :: set_aer_mask_severity": {
        "prefix": [
            "set_aer_mask_severity",
            "task:set_aer_mask_severity -> apci_seq_util"
        ],
        "body": [
            "set_aer_mask_severity(${1:et}, ${2:func}, ${3:mask}, ${4:sev}, ${5:is_advisory});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_aer_mask_severity(apci_error_type et,\n apci_func_info func,\n bit mask,\n bit sev,\n bit is_advisory = 0);    "
    },
    "apci_seq_util :: get_tlp_replay_time": {
        "prefix": [
            "get_tlp_replay_time",
            "task:get_tlp_replay_time -> apci_seq_util"
        ],
        "body": [
            "get_tlp_replay_time(${1:func}, ${2:replay_timer_timeout_high}, ${3:replay_timer_timeout_low});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task get_tlp_replay_time(        input   apci_func_info func,\n                 output  time replay_timer_timeout_high,\n        output  time replay_timer_timeout_low        );      "
    },
    "apci_seq_util :: set_extended_sync": {
        "prefix": [
            "set_extended_sync",
            "task:set_extended_sync -> apci_seq_util"
        ],
        "body": [
            "set_extended_sync(${1:enable}, ${2:mgrs});"
        ],
        "description": "[Class:apci_seq_util]\n     task set_extended_sync(bit enable,\n apci_device_mgr mgrs      );    "
    },
    "apci_seq_util :: check_ecs_status": {
        "prefix": [
            "check_ecs_status",
            "task:check_ecs_status -> apci_seq_util"
        ],
        "body": [
            "check_ecs_status(${1:func}, ${2:tlp}, ${3:ecs_type});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task check_ecs_status(apci_func_info func,\n apci_tlp tlp,\n apci_msg_ecs_e ecs_type);    "
    },
    "apci_seq_util :: trigger_dpc": {
        "prefix": [
            "trigger_dpc",
            "task:trigger_dpc -> apci_seq_util"
        ],
        "body": [
            "trigger_dpc(${1:bdf}, ${2:reason});"
        ],
        "description": "[Class:apci_seq_util]\n     task trigger_dpc(apci_bdf_t bdf,\n apci_dpc_tirgger_reason reason = APCI_DPC_TRIGGER_ramdon);    "
    },
    "apci_seq_util :: use_common_cb": {
        "prefix": [
            "use_common_cb",
            "task:use_common_cb -> apci_seq_util"
        ],
        "body": [
            "use_common_cb(${1:entry});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task use_common_cb(        input  string    entry = \"drop_eios\"        );    "
    },
    "apci_seq_util :: get_cxl_test_alg_base": {
        "prefix": [
            "get_cxl_test_alg_base",
            "function:get_cxl_test_alg_base -> apci_seq_util"
        ],
        "body": [
            "get_cxl_test_alg_base(${1:f});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual function bit       get_cxl_test_alg_base(apci_func_info f);    "
    },
    "apci_seq_util :: wait_err_msg": {
        "prefix": [
            "wait_err_msg",
            "task:wait_err_msg -> apci_seq_util"
        ],
        "body": [
            "wait_err_msg(${1:func}, ${2:exp_msg}, ${3:exp_msg_code}, ${4:rx_msg});"
        ],
        "description": "[Class:apci_seq_util]\n     task wait_err_msg(        apci_func_info  func    ,\n                              bit             exp_msg ,\n      apci_msg_code_e exp_msg_code,\n                       output apci_tlp        rx_msg);    "
    },
    "apci_seq_util :: set_ide_register_block": {
        "prefix": [
            "set_ide_register_block",
            "task:set_ide_register_block -> apci_seq_util"
        ],
        "body": [
            "set_ide_register_block(${1:bdf}, ${2:is_link_stream}, ${3:index}, ${4:enable}, ${5:stream_id}, ${6:tc});"
        ],
        "description": "[Class:apci_seq_util]\n     virtual task set_ide_register_block(apci_bdf_t bdf,\n bit is_link_stream,\n int index,\n bit enable,\n bit       stream_id,\n bit       tc);    "
    },
    "apci_seq_util :: check_status_reg_and_clear": {
        "prefix": [
            "check_status_reg_and_clear",
            "task:check_status_reg_and_clear -> apci_seq_util"
        ],
        "body": [
            "check_status_reg_and_clear(${1:func}, ${2:aer_exist}, ${3:mask}, ${4:exp_err_type}, ${5:is_correctable});"
        ],
        "description": "[Class:apci_seq_util]\n     task check_status_reg_and_clear(    apci_func_info  func     ,\n    bit             aer_exist,\n    bit             mask     ,\n    apci_err_type_e exp_err_type,\n    bit             is_correctable);    "
    },
    "apci_seq_util :: prepare_AER_to_report_internal_err": {
        "prefix": [
            "prepare_AER_to_report_internal_err",
            "task:prepare_AER_to_report_internal_err -> apci_seq_util"
        ],
        "body": [
            "prepare_AER_to_report_internal_err(${1:finf}, ${2:err});"
        ],
        "description": "[Class:apci_seq_util]\n     task prepare_AER_to_report_internal_err(apci_func_info finf,\n output bit err);    "
    },
    "apci_seq_mem_pair": {
        "prefix": "apci_seq_mem_pair",
        "body": [
            "apci_seq_mem_pair  ${0:name_class};"
        ],
        "description": "class apci_seq_mem_pair extends apci_seq_common;\n"
    },
    "apci_seq_mem_pair :: new": {
        "prefix": [
            "new",
            "function:new -> apci_seq_mem_pair"
        ],
        "body": [
            "new(${1:bfm}, ${2:mgr});"
        ],
        "description": "[Class:apci_seq_mem_pair]\n     function new(apci_device bfm,\n apci_device_mgr mgr);    "
    },
    "apci_seq_mem_pair :: run": {
        "prefix": [
            "run",
            "task:run -> apci_seq_mem_pair"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:apci_seq_mem_pair]\n     virtual task run();    "
    },
    "apci_seq_mem_pair :: send_tr_pair": {
        "prefix": [
            "send_tr_pair",
            "task:send_tr_pair -> apci_seq_mem_pair"
        ],
        "body": [
            "send_tr_pair(${1:func}, ${2:mbar}, ${3:err});"
        ],
        "description": "[Class:apci_seq_mem_pair]\n     virtual task send_tr_pair(apci_func_info func,\n apci_bar_t mbar,\n output err);    "
    },
    "apci_cfg_seq_util": {
        "prefix": "apci_cfg_seq_util",
        "body": [
            "apci_cfg_seq_util  ${0:name_class};"
        ],
        "description": "class apci_cfg_seq_util extends apci_seq_util;\n"
    },
    "apci_cfg_seq_util :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cfg_seq_util"
        ],
        "body": [
            "new(${1:bfm});"
        ],
        "description": "[Class:apci_cfg_seq_util]\n     function new(apci_device bfm);    "
    },
    "apci_cfg_seq_util :: bdf_cfg_read": {
        "prefix": [
            "bdf_cfg_read",
            "task:bdf_cfg_read -> apci_cfg_seq_util"
        ],
        "body": [
            "bdf_cfg_read(${1:bdf}, ${2:cap_offset}, ${3:v}, ${4:port_id});"
        ],
        "description": "[Class:apci_cfg_seq_util]\n     virtual task bdf_cfg_read(input bit        bdf,\ninput int  cap_offset,\noutput avery_u32 v,\ninput int        port_id = 0);    "
    },
    "apci_cfg_seq_util :: bdf_cfg_write": {
        "prefix": [
            "bdf_cfg_write",
            "task:bdf_cfg_write -> apci_cfg_seq_util"
        ],
        "body": [
            "bdf_cfg_write(${1:bdf}, ${2:cap_offset}, ${3:v}, ${4:port_id});"
        ],
        "description": "[Class:apci_cfg_seq_util]\n     virtual task bdf_cfg_write(input bit        bdf,\ninput int  cap_offset,\ninput avery_u32  v,\ninput int        port_id = 0);    "
    },
    "ebuf_check_remove_RxInvalid": {
        "prefix": [
            "ebuf_check_remove_RxInvalid",
            "function:ebuf_check_remove_RxInvalid"
        ],
        "body": [
            "ebuf_check_remove_RxInvalid(${0:});"
        ],
        "description": "function bit ebuf_check_remove_RxInvalid();    "
    },
    "ebuf_is_underflow": {
        "prefix": [
            "ebuf_is_underflow",
            "function:ebuf_is_underflow"
        ],
        "body": [
            "ebuf_is_underflow(${0:});"
        ],
        "description": "function bit ebuf_is_underflow();    "
    },
    "ebuf_is_overflow": {
        "prefix": [
            "ebuf_is_overflow",
            "function:ebuf_is_overflow"
        ],
        "body": [
            "ebuf_is_overflow(${1:n_bytes});"
        ],
        "description": "function bit ebuf_is_overflow(int n_bytes);    "
    },
    "ebuf_has_less_half": {
        "prefix": [
            "ebuf_has_less_half",
            "function:ebuf_has_less_half"
        ],
        "body": [
            "ebuf_has_less_half(${0:});"
        ],
        "description": "function bit ebuf_has_less_half();    "
    },
    "ebuf_has_less_empty": {
        "prefix": [
            "ebuf_has_less_empty",
            "function:ebuf_has_less_empty"
        ],
        "body": [
            "ebuf_has_less_empty(${0:});"
        ],
        "description": "function bit ebuf_has_less_empty();    "
    },
    "ebuf_push_back": {
        "prefix": [
            "ebuf_push_back",
            "function:ebuf_push_back"
        ],
        "body": [
            "ebuf_push_back(${1:entry});"
        ],
        "description": "function void ebuf_push_back(ebuf_data_t entry);    "
    },
    "ebuf_pop_back": {
        "prefix": [
            "ebuf_pop_back",
            "function:ebuf_pop_back"
        ],
        "body": [
            "ebuf_pop_back(${0:});"
        ],
        "description": "function void ebuf_pop_back();    "
    },
    "is_start_sos_nominal": {
        "prefix": [
            "is_start_sos_nominal",
            "function:is_start_sos_nominal"
        ],
        "body": [
            "is_start_sos_nominal(${1:sym});"
        ],
        "description": "function bit is_start_sos_nominal(ebuf_data_t  sym);    "
    },
    "flush_ebuf_util_half": {
        "prefix": [
            "flush_ebuf_util_half",
            "function:flush_ebuf_util_half"
        ],
        "body": [
            "flush_ebuf_util_half(${0:});"
        ],
        "description": "function void flush_ebuf_util_half();    "
    },
    "consume_all_invalid": {
        "prefix": [
            "consume_all_invalid",
            "function:consume_all_invalid"
        ],
        "body": [
            "consume_all_invalid(${0:});"
        ],
        "description": "function void consume_all_invalid();    "
    },
    "(TC0)\")": {
        "prefix": "(TC0)\")",
        "body": [
            "(TC0)\")  ${0:name_class};"
        ],
        "description": "item = new(AVY_ERROR, 'b11111, APCI5_6n5, \"Power Management Message fields follow the following rules: Traffic Class field must use the default class (TC0)\"); chklist_map[APCI5_6n5] = item;\n"
    },
    "get_ui": {
        "prefix": [
            "get_ui",
            "function:get_ui"
        ],
        "body": [
            "get_ui(${1:rate});"
        ],
        "description": "function time get_ui(byte rate);    "
    },
    "get_half_pclk_period_in_ps": {
        "prefix": [
            "get_half_pclk_period_in_ps",
            "function:get_half_pclk_period_in_ps"
        ],
        "body": [
            "get_half_pclk_period_in_ps(${0:});"
        ],
        "description": "function int get_half_pclk_period_in_ps();    "
    },
    "get_pclk_period_in_ps": {
        "prefix": [
            "get_pclk_period_in_ps",
            "function:get_pclk_period_in_ps"
        ],
        "body": [
            "get_pclk_period_in_ps(${1:rate});"
        ],
        "description": "function int get_pclk_period_in_ps(int rate);    "
    },
    "get_pclk_period_ccix_in_ps": {
        "prefix": [
            "get_pclk_period_ccix_in_ps",
            "function:get_pclk_period_ccix_in_ps"
        ],
        "body": [
            "get_pclk_period_ccix_in_ps(${1:rate});"
        ],
        "description": "function int get_pclk_period_ccix_in_ps(int rate);    "
    },
    "get_pclk_multiplier_new": {
        "prefix": [
            "get_pclk_multiplier_new",
            "function:get_pclk_multiplier_new"
        ],
        "body": [
            "get_pclk_multiplier_new(${1:data_rate}, ${2:pclk_rate});"
        ],
        "description": "function real get_pclk_multiplier_new(byte data_rate,\n byte pclk_rate);    "
    },
    "check_100fs_time_precision": {
        "prefix": [
            "check_100fs_time_precision",
            "task:check_100fs_time_precision"
        ],
        "body": [
            "check_100fs_time_precision(${0:});"
        ],
        "description": "task check_100fs_time_precision();    "
    },
    "check_1fs_time_precision": {
        "prefix": [
            "check_1fs_time_precision",
            "task:check_1fs_time_precision"
        ],
        "body": [
            "check_1fs_time_precision(${0:});"
        ],
        "description": "task check_1fs_time_precision();    "
    },
    "acxl_dut_seq": {
        "prefix": "acxl_dut_seq",
        "body": [
            "acxl_dut_seq  ${0:name_class};"
        ],
        "description": "class acxl_dut_seq extends avery_data_base;\n"
    },
    "acxl_dut_seq :: get_cacheline": {
        "prefix": [
            "get_cacheline",
            "task:get_cacheline -> acxl_dut_seq"
        ],
        "body": [
            "get_cacheline(${1:addr}, ${2:cline});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task get_cacheline (bit       addr,\n output acxl_cacheline cline);    "
    },
    "acxl_dut_seq :: cline_to_invalid": {
        "prefix": [
            "cline_to_invalid",
            "task:cline_to_invalid -> acxl_dut_seq"
        ],
        "body": [
            "cline_to_invalid(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task cline_to_invalid(bit       addr);    "
    },
    "acxl_dut_seq :: cline_to_exclusive_clean": {
        "prefix": [
            "cline_to_exclusive_clean",
            "task:cline_to_exclusive_clean -> acxl_dut_seq"
        ],
        "body": [
            "cline_to_exclusive_clean(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task cline_to_exclusive_clean(bit       addr);    "
    },
    "acxl_dut_seq :: cline_to_modified": {
        "prefix": [
            "cline_to_modified",
            "task:cline_to_modified -> acxl_dut_seq"
        ],
        "body": [
            "cline_to_modified(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task cline_to_modified(bit       addr);    "
    },
    "acxl_dut_seq :: send_RdCurr": {
        "prefix": [
            "send_RdCurr",
            "task:send_RdCurr -> acxl_dut_seq"
        ],
        "body": [
            "send_RdCurr(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_RdCurr(bit       addr);    "
    },
    "acxl_dut_seq :: send_RdOwn": {
        "prefix": [
            "send_RdOwn",
            "task:send_RdOwn -> acxl_dut_seq"
        ],
        "body": [
            "send_RdOwn(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_RdOwn(bit       addr);    "
    },
    "acxl_dut_seq :: send_RdOwnNoData": {
        "prefix": [
            "send_RdOwnNoData",
            "task:send_RdOwnNoData -> acxl_dut_seq"
        ],
        "body": [
            "send_RdOwnNoData(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_RdOwnNoData(bit       addr);    "
    },
    "acxl_dut_seq :: send_RdShared": {
        "prefix": [
            "send_RdShared",
            "task:send_RdShared -> acxl_dut_seq"
        ],
        "body": [
            "send_RdShared(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_RdShared(bit       addr);    "
    },
    "acxl_dut_seq :: send_MemWr": {
        "prefix": [
            "send_MemWr",
            "task:send_MemWr -> acxl_dut_seq"
        ],
        "body": [
            "send_MemWr(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_MemWr(bit       addr);    "
    },
    "acxl_dut_seq :: send_ItoMWr": {
        "prefix": [
            "send_ItoMWr",
            "task:send_ItoMWr -> acxl_dut_seq"
        ],
        "body": [
            "send_ItoMWr(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_ItoMWr(bit       addr);    "
    },
    "acxl_dut_seq :: send_CLFlush": {
        "prefix": [
            "send_CLFlush",
            "task:send_CLFlush -> acxl_dut_seq"
        ],
        "body": [
            "send_CLFlush(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_CLFlush(bit       addr);    "
    },
    "acxl_dut_seq :: send_CleanEvict": {
        "prefix": [
            "send_CleanEvict",
            "task:send_CleanEvict -> acxl_dut_seq"
        ],
        "body": [
            "send_CleanEvict(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_CleanEvict(bit       addr);    "
    },
    "acxl_dut_seq :: send_DirtyEvict": {
        "prefix": [
            "send_DirtyEvict",
            "task:send_DirtyEvict -> acxl_dut_seq"
        ],
        "body": [
            "send_DirtyEvict(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_DirtyEvict(bit       addr);    "
    },
    "acxl_dut_seq :: send_RdAny": {
        "prefix": [
            "send_RdAny",
            "task:send_RdAny -> acxl_dut_seq"
        ],
        "body": [
            "send_RdAny(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_RdAny(bit       addr);    "
    },
    "acxl_dut_seq :: send_CleanEvictNoData": {
        "prefix": [
            "send_CleanEvictNoData",
            "task:send_CleanEvictNoData -> acxl_dut_seq"
        ],
        "body": [
            "send_CleanEvictNoData(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_CleanEvictNoData(bit       addr);    "
    },
    "acxl_dut_seq :: send_WOWrInv": {
        "prefix": [
            "send_WOWrInv",
            "task:send_WOWrInv -> acxl_dut_seq"
        ],
        "body": [
            "send_WOWrInv(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_WOWrInv(bit       addr);    "
    },
    "acxl_dut_seq :: send_WOWrInvF": {
        "prefix": [
            "send_WOWrInvF",
            "task:send_WOWrInvF -> acxl_dut_seq"
        ],
        "body": [
            "send_WOWrInvF(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_WOWrInvF(bit       addr);    "
    },
    "acxl_dut_seq :: send_WrInv": {
        "prefix": [
            "send_WrInv",
            "task:send_WrInv -> acxl_dut_seq"
        ],
        "body": [
            "send_WrInv(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_WrInv(bit       addr);    "
    },
    "acxl_dut_seq :: send_CacheFlushed": {
        "prefix": [
            "send_CacheFlushed",
            "task:send_CacheFlushed -> acxl_dut_seq"
        ],
        "body": [
            "send_CacheFlushed(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_CacheFlushed(bit       addr);    "
    },
    "acxl_dut_seq :: enter_pkgc_l1": {
        "prefix": [
            "enter_pkgc_l1",
            "task:enter_pkgc_l1 -> acxl_dut_seq"
        ],
        "body": [
            "enter_pkgc_l1(${0:});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task enter_pkgc_l1();    "
    },
    "acxl_dut_seq :: add_ide_key": {
        "prefix": [
            "add_ide_key",
            "task:add_ide_key -> acxl_dut_seq"
        ],
        "body": [
            "add_ide_key(${1:key}, ${2:iv}, ${3:is_tx});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task add_ide_key(bit       key,\n bit       iv,\n bit is_tx);    "
    },
    "acxl_dut_seq :: start_ide_sequence": {
        "prefix": [
            "start_ide_sequence",
            "task:start_ide_sequence -> acxl_dut_seq"
        ],
        "body": [
            "start_ide_sequence(${0:});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task start_ide_sequence();    "
    },
    "acxl_dut_seq :: send_d2h_req": {
        "prefix": [
            "send_d2h_req",
            "task:send_d2h_req -> acxl_dut_seq"
        ],
        "body": [
            "send_d2h_req(${1:req_type}, ${2:addr});"
        ],
        "description": "[Class:acxl_dut_seq]\n     virtual task send_d2h_req(acxl_d2h_req_opcode_e req_type,\n bit       addr);    "
    },
    "acxl_seq_base": {
        "prefix": "acxl_seq_base",
        "body": [
            "acxl_seq_base  ${0:name_class};"
        ],
        "description": "class acxl_seq_base extends apci_seq_common;\n"
    },
    "acxl_seq_base :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_seq_base"
        ],
        "body": [
            "new(${1:bfm}, ${2:rc_app_bfm}, ${3:target}, ${4:scope});"
        ],
        "description": "[Class:acxl_seq_base]\n     function new (apci_device bfm    = null,\n   apci_device rc_app_bfm    = null,\n   apci_device target    = null,\n   string scope = \"\");    "
    },
    "acxl_seq_util": {
        "prefix": "acxl_seq_util",
        "body": [
            "acxl_seq_util  ${0:name_class};"
        ],
        "description": "class acxl_seq_util extends acxl_seq_base;\n"
    },
    "acxl_seq_util :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_seq_util"
        ],
        "body": [
            "new(${1:bfm}, ${2:rc_app_bfm}, ${3:target}, ${4:testcase});"
        ],
        "description": "[Class:acxl_seq_util]\n     function new(apci_device bfm,\n apci_device rc_app_bfm = null,\n apci_device target = null,\n apci_testcase_base testcase = null);    "
    },
    "acxl_seq_util :: wait_hdm_ready": {
        "prefix": [
            "wait_hdm_ready",
            "task:wait_hdm_ready -> acxl_seq_util"
        ],
        "body": [
            "wait_hdm_ready(${1:hdm_bdf}, ${2:host_addr}, ${3:hdm_addr}, ${4:hdm_len});"
        ],
        "description": "[Class:acxl_seq_util]\n     virtual task wait_hdm_ready (    input  apci_bdf_t  hdm_bdf,\n    output bit         host_addr,\n    output bit         hdm_addr,\n    output bit         hdm_len);    "
    },
    "acxl_seq_util :: write0": {
        "prefix": [
            "write0",
            "task:write0 -> acxl_seq_util"
        ],
        "body": [
            "write0(${1:cline_addr}, ${2:ndw}, ${3:tr}, ${4:first_byte_en}, ${5:wr_alloc});"
        ],
        "description": "[Class:acxl_seq_util]\n     task write0(        bit              cline_addr,\n                        int              ndw       ,\n                 output apci_transaction tr        ,\n                 input  bit               first_byte_en = 4'hf,\n                 input  byte             wr_alloc   = -1 );    "
    },
    "acxl_seq_util :: read0": {
        "prefix": [
            "read0",
            "task:read0 -> acxl_seq_util"
        ],
        "body": [
            "read0(${1:cline_addr}, ${2:ndw}, ${3:tr_golden});"
        ],
        "description": "[Class:acxl_seq_util]\n     task read0 (bit       cline_addr,\n int ndw,\n apci_transaction tr_golden = null);    "
    },
    "acxl_seq_util :: read_full_line": {
        "prefix": [
            "read_full_line",
            "task:read_full_line -> acxl_seq_util"
        ],
        "body": [
            "read_full_line(${1:cline_addr}, ${2:code});"
        ],
        "description": "[Class:acxl_seq_util]\n     task automatic read_full_line(bit       cline_addr,\n acxl_d2h_req_opcode_e code);     "
    },
    "acxl_seq_util :: evict_all_cachelines": {
        "prefix": [
            "evict_all_cachelines",
            "task:evict_all_cachelines -> acxl_seq_util"
        ],
        "body": [
            "evict_all_cachelines(${0:});"
        ],
        "description": "[Class:acxl_seq_util]\n     task evict_all_cachelines();    "
    },
    "acxl_seq_util :: cxl_io_traffic": {
        "prefix": [
            "cxl_io_traffic",
            "task:cxl_io_traffic -> acxl_seq_util"
        ],
        "body": [
            "cxl_io_traffic(${1:user_len});"
        ],
        "description": "[Class:acxl_seq_util]\n     task cxl_io_traffic(input int user_len       = {});    "
    },
    "acxl_seq_util :: wait_d2h_req_msg": {
        "prefix": [
            "wait_d2h_req_msg",
            "task:wait_d2h_req_msg -> acxl_seq_util"
        ],
        "body": [
            "wait_d2h_req_msg(${1:kind}, ${2:timer}, ${3:m}, ${4:dbg});"
        ],
        "description": "[Class:acxl_seq_util]\n     virtual task wait_d2h_req_msg (acxl_d2h_req_opcode_e kind,\n time timer = 0,\n output acxl_msg m,\n input string dbg=\"\");    "
    },
    "acxl_seq_util :: wait_d2h_rsp_by_uqid": {
        "prefix": [
            "wait_d2h_rsp_by_uqid",
            "task:wait_d2h_rsp_by_uqid -> acxl_seq_util"
        ],
        "body": [
            "wait_d2h_rsp_by_uqid(${1:uqid}, ${2:timer}, ${3:m}, ${4:dbg});"
        ],
        "description": "[Class:acxl_seq_util]\n     virtual task wait_d2h_rsp_by_uqid(int uqid,\n time timer = 0,\n output acxl_msg m,\n input string dbg = \"\");    "
    },
    "acxl_seq_util :: wait_d2h_rsp_msg": {
        "prefix": [
            "wait_d2h_rsp_msg",
            "task:wait_d2h_rsp_msg -> acxl_seq_util"
        ],
        "body": [
            "wait_d2h_rsp_msg(${1:kind}, ${2:timer}, ${3:m}, ${4:dbg});"
        ],
        "description": "[Class:acxl_seq_util]\n     virtual task wait_d2h_rsp_msg (string kind = \"any\",\n time timer = 0,\n output acxl_msg m,\n input string dbg = \"\");    "
    },
    "acxl_seq_util :: wait_s2m_msg": {
        "prefix": [
            "wait_s2m_msg",
            "task:wait_s2m_msg -> acxl_seq_util"
        ],
        "body": [
            "wait_s2m_msg(${1:kind}, ${2:timer}, ${3:m}, ${4:dbg});"
        ],
        "description": "[Class:acxl_seq_util]\n     virtual task wait_s2m_msg (string kind = \"any\",\n time timer = 0,\n output acxl_msg m,\n input string dbg = \"\");    "
    },
    "acxl_seq_util :: configure_link_for_IDE": {
        "prefix": [
            "configure_link_for_IDE",
            "task:configure_link_for_IDE -> acxl_seq_util"
        ],
        "body": [
            "configure_link_for_IDE(${1:link_bdf}, ${2:disable_pcrc}, ${3:err});"
        ],
        "description": "[Class:acxl_seq_util]\n     virtual task configure_link_for_IDE (apci_func_info link_bdf,\n bit disable_pcrc,\n output bit err);    "
    },
    "acxl_seq_util :: clear_RAS_err_masks": {
        "prefix": [
            "clear_RAS_err_masks",
            "task:clear_RAS_err_masks -> acxl_seq_util"
        ],
        "body": [
            "clear_RAS_err_masks(${1:finf}, ${2:err});"
        ],
        "description": "[Class:acxl_seq_util]\n     task clear_RAS_err_masks(apci_func_info finf,\n output bit err);    "
    },
    "acxl_seq_util :: do_cxl_reset": {
        "prefix": [
            "do_cxl_reset",
            "task:do_cxl_reset -> acxl_seq_util"
        ],
        "body": [
            "do_cxl_reset(${1:tgt_func}, ${2:delay}, ${3:na}, ${4:err});"
        ],
        "description": "[Class:acxl_seq_util]\n     task do_cxl_reset(apci_func_info tgt_func,\n time delay = 10us,\n output bit na,\n output bit err);    "
    },
    "acxl_seq_cacheline_to_I": {
        "prefix": "acxl_seq_cacheline_to_I",
        "body": [
            "acxl_seq_cacheline_to_I  ${0:name_class};"
        ],
        "description": "class acxl_seq_cacheline_to_I extends acxl_seq_base;\n"
    },
    "acxl_seq_cacheline_to_I :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_seq_cacheline_to_I"
        ],
        "body": [
            "new(${1:bfm}, ${2:testcase});"
        ],
        "description": "[Class:acxl_seq_cacheline_to_I]\n     function new(apci_device bfm,\n  apci_testcase_base testcase = null);    "
    },
    "acxl_seq_cacheline_to_I :: run": {
        "prefix": [
            "run",
            "task:run -> acxl_seq_cacheline_to_I"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:acxl_seq_cacheline_to_I]\n     virtual task run();    "
    },
    "acxl_seq_cacheline_to_UC": {
        "prefix": "acxl_seq_cacheline_to_UC",
        "body": [
            "acxl_seq_cacheline_to_UC  ${0:name_class};"
        ],
        "description": "class acxl_seq_cacheline_to_UC extends acxl_seq_base;\n"
    },
    "acxl_seq_cacheline_to_UC :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_seq_cacheline_to_UC"
        ],
        "body": [
            "new(${1:bfm}, ${2:testcase});"
        ],
        "description": "[Class:acxl_seq_cacheline_to_UC]\n     function new(apci_device bfm,\n  apci_testcase_base testcase = null);    "
    },
    "acxl_seq_cacheline_to_UC :: run": {
        "prefix": [
            "run",
            "task:run -> acxl_seq_cacheline_to_UC"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:acxl_seq_cacheline_to_UC]\n     virtual task run();    "
    },
    "acxl_seq_cacheline_to_UD": {
        "prefix": "acxl_seq_cacheline_to_UD",
        "body": [
            "acxl_seq_cacheline_to_UD  ${0:name_class};"
        ],
        "description": "class acxl_seq_cacheline_to_UD extends acxl_seq_base;\n"
    },
    "acxl_seq_cacheline_to_UD :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_seq_cacheline_to_UD"
        ],
        "body": [
            "new(${1:bfm}, ${2:testcase});"
        ],
        "description": "[Class:acxl_seq_cacheline_to_UD]\n     function new(apci_device bfm,\n  apci_testcase_base testcase = null);    "
    },
    "acxl_seq_cacheline_to_UD :: run": {
        "prefix": [
            "run",
            "task:run -> acxl_seq_cacheline_to_UD"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:acxl_seq_cacheline_to_UD]\n     virtual task run();    "
    },
    "acxl_dut_seq_avery": {
        "prefix": "acxl_dut_seq_avery",
        "body": [
            "acxl_dut_seq_avery  ${0:name_class};"
        ],
        "description": "class acxl_dut_seq_avery extends acxl_dut_seq;\n"
    },
    "acxl_dut_seq_avery :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_dut_seq_avery"
        ],
        "body": [
            "new(${1:name}, ${2:avery_bfm});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     function new(string name = \"acxl_dut_seq_avery\",\n apci_device avery_bfm);    "
    },
    "acxl_dut_seq_avery :: get_cacheline": {
        "prefix": [
            "get_cacheline",
            "task:get_cacheline -> acxl_dut_seq_avery"
        ],
        "body": [
            "get_cacheline(${1:addr}, ${2:cline});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task get_cacheline (bit       addr,\n output acxl_cacheline cline);    "
    },
    "acxl_dut_seq_avery :: cline_to_invalid": {
        "prefix": [
            "cline_to_invalid",
            "task:cline_to_invalid -> acxl_dut_seq_avery"
        ],
        "body": [
            "cline_to_invalid(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task cline_to_invalid(bit       addr);    "
    },
    "acxl_dut_seq_avery :: cline_to_exclusive_clean": {
        "prefix": [
            "cline_to_exclusive_clean",
            "task:cline_to_exclusive_clean -> acxl_dut_seq_avery"
        ],
        "body": [
            "cline_to_exclusive_clean(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task cline_to_exclusive_clean(bit       addr);    "
    },
    "acxl_dut_seq_avery :: cline_to_modified": {
        "prefix": [
            "cline_to_modified",
            "task:cline_to_modified -> acxl_dut_seq_avery"
        ],
        "body": [
            "cline_to_modified(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task cline_to_modified(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_CleanEvict": {
        "prefix": [
            "send_CleanEvict",
            "task:send_CleanEvict -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_CleanEvict(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_CleanEvict(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_DirtyEvict": {
        "prefix": [
            "send_DirtyEvict",
            "task:send_DirtyEvict -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_DirtyEvict(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_DirtyEvict(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_RdOwn": {
        "prefix": [
            "send_RdOwn",
            "task:send_RdOwn -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_RdOwn(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_RdOwn(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_RdOwnNoData": {
        "prefix": [
            "send_RdOwnNoData",
            "task:send_RdOwnNoData -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_RdOwnNoData(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_RdOwnNoData(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_RdShared": {
        "prefix": [
            "send_RdShared",
            "task:send_RdShared -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_RdShared(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_RdShared(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_RdAny": {
        "prefix": [
            "send_RdAny",
            "task:send_RdAny -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_RdAny(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_RdAny(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_CLFlush": {
        "prefix": [
            "send_CLFlush",
            "task:send_CLFlush -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_CLFlush(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_CLFlush(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_ItoMWr": {
        "prefix": [
            "send_ItoMWr",
            "task:send_ItoMWr -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_ItoMWr(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_ItoMWr(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_MemWr": {
        "prefix": [
            "send_MemWr",
            "task:send_MemWr -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_MemWr(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_MemWr(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_WOWrInv": {
        "prefix": [
            "send_WOWrInv",
            "task:send_WOWrInv -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_WOWrInv(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_WOWrInv(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_WOWrInvF": {
        "prefix": [
            "send_WOWrInvF",
            "task:send_WOWrInvF -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_WOWrInvF(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_WOWrInvF(bit       addr);    "
    },
    "acxl_dut_seq_avery :: send_WrInv": {
        "prefix": [
            "send_WrInv",
            "task:send_WrInv -> acxl_dut_seq_avery"
        ],
        "body": [
            "send_WrInv(${1:addr});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task send_WrInv(bit       addr);    "
    },
    "acxl_dut_seq_avery :: enter_pkgc_l1": {
        "prefix": [
            "enter_pkgc_l1",
            "task:enter_pkgc_l1 -> acxl_dut_seq_avery"
        ],
        "body": [
            "enter_pkgc_l1(${0:});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task enter_pkgc_l1();    "
    },
    "acxl_dut_seq_avery :: add_ide_key": {
        "prefix": [
            "add_ide_key",
            "task:add_ide_key -> acxl_dut_seq_avery"
        ],
        "body": [
            "add_ide_key(${1:key}, ${2:iv}, ${3:is_tx});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task add_ide_key(bit       key,\n bit       iv,\n bit is_tx);    "
    },
    "acxl_dut_seq_avery :: start_ide_sequence": {
        "prefix": [
            "start_ide_sequence",
            "task:start_ide_sequence -> acxl_dut_seq_avery"
        ],
        "body": [
            "start_ide_sequence(${0:});"
        ],
        "description": "[Class:acxl_dut_seq_avery]\n     virtual task start_ide_sequence();    "
    },
    "tx_tlp_dllp_to_flit": {
        "prefix": [
            "tx_tlp_dllp_to_flit",
            "task:tx_tlp_dllp_to_flit"
        ],
        "body": [
            "tx_tlp_dllp_to_flit(${0:});"
        ],
        "description": "task tx_tlp_dllp_to_flit();    "
    },
    "retrive_io_flit": {
        "prefix": [
            "retrive_io_flit",
            "function:retrive_io_flit"
        ],
        "body": [
            "retrive_io_flit(${0:});"
        ],
        "description": "function void retrive_io_flit();    "
    },
    "pack_and_send_io_flit": {
        "prefix": [
            "pack_and_send_io_flit",
            "task:pack_and_send_io_flit"
        ],
        "body": [
            "pack_and_send_io_flit(${0:});"
        ],
        "description": "task pack_and_send_io_flit();    "
    },
    "post_to_arbmux_and_wait_done": {
        "prefix": [
            "post_to_arbmux_and_wait_done",
            "task:post_to_arbmux_and_wait_done"
        ],
        "body": [
            "post_to_arbmux_and_wait_done(${1:f});"
        ],
        "description": "task post_to_arbmux_and_wait_done(acxl_flit f);    "
    },
    "pick_tlp_dllp": {
        "prefix": [
            "pick_tlp_dllp",
            "function:pick_tlp_dllp"
        ],
        "body": [
            "pick_tlp_dllp(${1:qid});"
        ],
        "description": "function apci_packet pick_tlp_dllp(output int qid);    "
    },
    "pop_tlp_dllp": {
        "prefix": [
            "pop_tlp_dllp",
            "function:pop_tlp_dllp"
        ],
        "body": [
            "pop_tlp_dllp(${1:qid});"
        ],
        "description": "function apci_packet pop_tlp_dllp(int qid = -1);    "
    },
    "callback_tx_exit_mac": {
        "prefix": [
            "callback_tx_exit_mac",
            "function:callback_tx_exit_mac"
        ],
        "body": [
            "callback_tx_exit_mac(${1:p}, ${2:start_lane_no}, ${3:is_drop}, ${4:flexbus_mode});"
        ],
        "description": "function void callback_tx_exit_mac(apci_packet p,\n int start_lane_no,\n output bit is_drop,\n input bit flexbus_mode = 0);    "
    },
    "rx_io_flit_from_arbmux": {
        "prefix": [
            "rx_io_flit_from_arbmux",
            "task:rx_io_flit_from_arbmux"
        ],
        "body": [
            "rx_io_flit_from_arbmux(${0:});"
        ],
        "description": "task rx_io_flit_from_arbmux();    "
    },
    "apci_capability": {
        "prefix": "apci_capability",
        "body": [
            "apci_capability  ${0:name_class};"
        ],
        "description": "class apci_capability extends avery_reg;\n"
    },
    "apci_capability :: new": {
        "prefix": [
            "new",
            "function:new -> apci_capability"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_capability]\n     function new(string name = \"apci_capability\");    "
    },
    "apci_capability :: write": {
        "prefix": [
            "write",
            "function:write -> apci_capability"
        ],
        "body": [
            "write(${1:reg_no}, ${2:v}, ${3:byte_enable});"
        ],
        "description": "[Class:apci_capability]\n     extern virtual function void write(int reg_no,\n avery_u32 v,\n bit       byte_enable);    "
    },
    "apci_capability :: read": {
        "prefix": [
            "read",
            "function:read -> apci_capability"
        ],
        "body": [
            "read(${1:reg_no}, ${2:byte_enable});"
        ],
        "description": "[Class:apci_capability]\n     extern virtual function avery_u32 read (int reg_no,\n bit       byte_enable);    "
    },
    "apci_capability :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_capability"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_capability]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_capability :: configure": {
        "prefix": [
            "configure",
            "function:configure -> apci_capability"
        ],
        "body": [
            "configure(${1:is_vf}, ${2:func_no}, ${3:ptype}, ${4:speed_sup}, ${5:n_dwords}, ${6:cfg_info});"
        ],
        "description": "[Class:apci_capability]\n     function void configure( bit            is_vf       =  0,\n     int            func_no     = -1,\n                             apci_port_type ptype       = APCI_PORT_unknown,\n                             bit             speed_sup   = -1,\n                             int            n_dwords    =  0,\n     apci_cfg_info  cfg_info    =  null );    "
    },
    "apci_capability :: set_next_cap_offset": {
        "prefix": [
            "set_next_cap_offset",
            "function:set_next_cap_offset -> apci_capability"
        ],
        "body": [
            "set_next_cap_offset(${1:v});"
        ],
        "description": "[Class:apci_capability]\n     virtual function void set_next_cap_offset(bit       v);    "
    },
    "apci_capability :: get_next_cap_offset": {
        "prefix": [
            "get_next_cap_offset",
            "function:get_next_cap_offset -> apci_capability"
        ],
        "body": [
            "get_next_cap_offset(${0:});"
        ],
        "description": "[Class:apci_capability]\n     virtual function bit       get_next_cap_offset();    "
    },
    "apci_capability :: get_cap_id": {
        "prefix": [
            "get_cap_id",
            "function:get_cap_id -> apci_capability"
        ],
        "body": [
            "get_cap_id(${0:});"
        ],
        "description": "[Class:apci_capability]\n     virtual function bit       get_cap_id();    "
    },
    "patito": {
        "prefix": [
            "patito",
            "function:patito"
        ],
        "body": [
            "patito(${1:msg}, ${2:is_disable}, ${3:item});"
        ],
        "description": "virtual function void patito(input string msg,\ninout bit is_disable,\nref apci_assertion_item item    );    "
    },
    "apci_log_callbacks": {
        "prefix": "apci_log_callbacks",
        "body": [
            "apci_log_callbacks  ${0:name_class};"
        ],
        "description": "virtual class apci_log_callbacks;\n"
    },
    "apci_log_callbacks :: assertion_msg_cb": {
        "prefix": [
            "assertion_msg_cb",
            "function:assertion_msg_cb -> apci_log_callbacks"
        ],
        "body": [
            "assertion_msg_cb(${1:msg}, ${2:is_disable}, ${3:item});"
        ],
        "description": "[Class:apci_log_callbacks]\n     virtual function void assertion_msg_cb(input string msg,\ninout bit is_disable,\nref apci_assertion_item item    );    "
    },
    "apci_log_callbacks :: warn_msg_cb": {
        "prefix": [
            "warn_msg_cb",
            "function:warn_msg_cb -> apci_log_callbacks"
        ],
        "body": [
            "warn_msg_cb(${1:msg}, ${2:is_disable});"
        ],
        "description": "[Class:apci_log_callbacks]\n     virtual function void warn_msg_cb(input string msg,\ninout bit is_disable     );    "
    },
    "apci_log_callbacks :: error_msg_cb": {
        "prefix": [
            "error_msg_cb",
            "function:error_msg_cb -> apci_log_callbacks"
        ],
        "body": [
            "error_msg_cb(${1:msg}, ${2:is_disable});"
        ],
        "description": "[Class:apci_log_callbacks]\n     virtual function void error_msg_cb(input string msg,\ninout bit is_disable     );    "
    },
    "apci_log_callbacks :: fatal_msg_cb": {
        "prefix": [
            "fatal_msg_cb",
            "function:fatal_msg_cb -> apci_log_callbacks"
        ],
        "body": [
            "fatal_msg_cb(${1:msg}, ${2:is_disable});"
        ],
        "description": "[Class:apci_log_callbacks]\n     virtual function void fatal_msg_cb(input string msg,\ninout bit is_disable    );    "
    },
    "apci_assertion_item": {
        "prefix": "apci_assertion_item",
        "body": [
            "apci_assertion_item  ${0:name_class};"
        ],
        "description": "class apci_assertion_item;\n"
    },
    "apci_assertion_item :: new": {
        "prefix": [
            "new",
            "function:new -> apci_assertion_item"
        ],
        "body": [
            "new(${1:severity}, ${2:dut_type}, ${3:id}, ${4:des}, ${5:idname});"
        ],
        "description": "[Class:apci_assertion_item]\n     function new (    avery_severity      severity,\n    bit                 dut_type,\n       apci_chklist_id_e  id = APCI_chklist_id_begin,\n    string             des = \"\",\n    string             idname = \"\");    "
    },
    "apci_assertion_item :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_assertion_item"
        ],
        "body": [
            "sprint(${1:verbosity});"
        ],
        "description": "[Class:apci_assertion_item]\n     function string sprint(int verbosity = 0);    "
    },
    "apci_log": {
        "prefix": "apci_log",
        "body": [
            "apci_log  ${0:name_class};"
        ],
        "description": "class apci_log extends avery_log;\n"
    },
    "apci_log :: new": {
        "prefix": [
            "new",
            "function:new -> apci_log"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent});"
        ],
        "description": "[Class:apci_log]\n     extern function new( string name,\n `avery_xvm_parent);    "
    },
    "apci_log :: append_callback": {
        "prefix": [
            "append_callback",
            "function:append_callback -> apci_log"
        ],
        "body": [
            "append_callback(${1:cb}, ${2:is_global});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void append_callback(apci_log_callbacks cb,\n input is_global = 0);    "
    },
    "apci_log :: prepend_callback": {
        "prefix": [
            "prepend_callback",
            "function:prepend_callback -> apci_log"
        ],
        "body": [
            "prepend_callback(${1:cb}, ${2:is_global});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void prepend_callback(apci_log_callbacks cb,\n input is_global = 0);    "
    },
    "apci_log :: unregister_callback": {
        "prefix": [
            "unregister_callback",
            "function:unregister_callback -> apci_log"
        ],
        "body": [
            "unregister_callback(${1:cb}, ${2:is_global});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void unregister_callback(apci_log_callbacks cb,\n input is_global = 0);    "
    },
    "apci_log :: track_lecroy": {
        "prefix": [
            "track_lecroy",
            "function:track_lecroy -> apci_log"
        ],
        "body": [
            "track_lecroy(${1:s});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy(string s);    "
    },
    "apci_log :: track_lecroy_comment": {
        "prefix": [
            "track_lecroy_comment",
            "function:track_lecroy_comment -> apci_log"
        ],
        "body": [
            "track_lecroy_comment(${1:s});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_comment(string s);    "
    },
    "apci_log :: track_lecroy_speed_change": {
        "prefix": [
            "track_lecroy_speed_change",
            "function:track_lecroy_speed_change -> apci_log"
        ],
        "body": [
            "track_lecroy_speed_change(${1:tgt_speed});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_speed_change(int tgt_speed);    "
    },
    "apci_log :: track_lecroy_packet": {
        "prefix": [
            "track_lecroy_packet",
            "function:track_lecroy_packet -> apci_log"
        ],
        "body": [
            "track_lecroy_packet(${1:pkt}, ${2:is_bus_enum_active});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_packet(apci_packet pkt,\n bit is_bus_enum_active = 0);    "
    },
    "apci_log :: track_lecroy_wait_np_done": {
        "prefix": [
            "track_lecroy_wait_np_done",
            "function:track_lecroy_wait_np_done -> apci_log"
        ],
        "body": [
            "track_lecroy_wait_np_done(${1:cpl}, ${2:is_bus_enum_active});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_wait_np_done(apci_tlp cpl,\n bit is_bus_enum_active = 0);    "
    },
    "apci_log :: track_lecroy_wait_to_sent_cpl": {
        "prefix": [
            "track_lecroy_wait_to_sent_cpl",
            "function:track_lecroy_wait_to_sent_cpl -> apci_log"
        ],
        "body": [
            "track_lecroy_wait_to_sent_cpl(${1:req}, ${2:cpl});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_wait_to_sent_cpl(apci_tlp req,\n apci_tlp cpl);    "
    },
    "apci_log :: dump_lecroy_read_data": {
        "prefix": [
            "dump_lecroy_read_data",
            "function:dump_lecroy_read_data -> apci_log"
        ],
        "body": [
            "dump_lecroy_read_data(${0:});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void dump_lecroy_read_data();    "
    },
    "apci_log :: track_lecroy_ltssm": {
        "prefix": [
            "track_lecroy_ltssm",
            "function:track_lecroy_ltssm -> apci_log"
        ],
        "body": [
            "track_lecroy_ltssm(${1:ltssm});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_ltssm(apci_ltssm_state_e ltssm);    "
    },
    "apci_log :: track_lecroy_config_all": {
        "prefix": [
            "track_lecroy_config_all",
            "function:track_lecroy_config_all -> apci_log"
        ],
        "body": [
            "track_lecroy_config_all(${1:bfm});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_config_all(apci_device bfm);    "
    },
    "apci_log :: track_lecroy_bus_enum": {
        "prefix": [
            "track_lecroy_bus_enum",
            "function:track_lecroy_bus_enum -> apci_log"
        ],
        "body": [
            "track_lecroy_bus_enum(${1:bfm});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_lecroy_bus_enum(apci_device bfm);     "
    },
    "apci_log :: save_lecroy_data": {
        "prefix": [
            "save_lecroy_data",
            "function:save_lecroy_data -> apci_log"
        ],
        "body": [
            "save_lecroy_data(${1:rx_cpls});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void save_lecroy_data(apci_tlp rx_cpls      );    "
    },
    "apci_log :: update_lecroy_addr": {
        "prefix": [
            "update_lecroy_addr",
            "function:update_lecroy_addr -> apci_log"
        ],
        "body": [
            "update_lecroy_addr(${1:addr});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void update_lecroy_addr(avery_u64 addr);    "
    },
    "apci_log :: set_lecroy_track_file_name": {
        "prefix": [
            "set_lecroy_track_file_name",
            "function:set_lecroy_track_file_name -> apci_log"
        ],
        "body": [
            "set_lecroy_track_file_name(${1:file_name});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void set_lecroy_track_file_name(string file_name);     "
    },
    "apci_log :: track_cfg": {
        "prefix": [
            "track_cfg",
            "function:track_cfg -> apci_log"
        ],
        "body": [
            "track_cfg(${1:msg});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_cfg(string msg);    "
    },
    "apci_log :: track_al": {
        "prefix": [
            "track_al",
            "function:track_al -> apci_log"
        ],
        "body": [
            "track_al(${1:msg}, ${2:linebrk_before});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_al (string msg,\n bit linebrk_before=0);    "
    },
    "apci_log :: track_tl": {
        "prefix": [
            "track_tl",
            "function:track_tl -> apci_log"
        ],
        "body": [
            "track_tl(${1:msg}, ${2:linebrk_before});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_tl (string msg,\n bit linebrk_before=0);    "
    },
    "apci_log :: track_dll": {
        "prefix": [
            "track_dll",
            "function:track_dll -> apci_log"
        ],
        "body": [
            "track_dll(${1:col}, ${2:msg}, ${3:linebrk_after});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_dll(byte col,\n string msg,\n bit linebrk_after=1);    "
    },
    "apci_log :: track_phy": {
        "prefix": [
            "track_phy",
            "function:track_phy -> apci_log"
        ],
        "body": [
            "track_phy(${1:col}, ${2:msg}, ${3:linebrk_after}, ${4:mytime});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_phy(byte col,\n string msg,\n bit linebrk_after=1,\n time mytime=0);    "
    },
    "apci_log :: track_phy2": {
        "prefix": [
            "track_phy2",
            "function:track_phy2 -> apci_log"
        ],
        "body": [
            "track_phy2(${1:col}, ${2:is_tx}, ${3:msg}, ${4:linebrk_after}, ${5:mytime});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_phy2(byte col,\n bit is_tx,\n string msg,\n bit linebrk_after=1,\n time mytime=0);    "
    },
    "apci_log :: track_tl2": {
        "prefix": [
            "track_tl2",
            "function:track_tl2 -> apci_log"
        ],
        "body": [
            "track_tl2(${1:msg}, ${2:is_tx}, ${3:print_dir}, ${4:linebrk_before});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_tl2 (string msg,\n bit is_tx,\n bit print_dir=1,\n bit linebrk_before=0);    "
    },
    "apci_log :: track_trans2": {
        "prefix": [
            "track_trans2",
            "function:track_trans2 -> apci_log"
        ],
        "body": [
            "track_trans2(${1:msg}, ${2:is_tx}, ${3:print_dir}, ${4:linebrk_before});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void track_trans2 (string msg,\n bit is_tx,\n bit print_dir=1,\n bit linebrk_before=0);    "
    },
    "apci_log :: set_global_severity": {
        "prefix": [
            "set_global_severity",
            "function:set_global_severity -> apci_log"
        ],
        "body": [
            "set_global_severity(${1:idname}, ${2:v});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void set_global_severity(string idname,\n avery_severity v);    "
    },
    "apci_log :: set_severity": {
        "prefix": [
            "set_severity",
            "function:set_severity -> apci_log"
        ],
        "body": [
            "set_severity(${1:idname}, ${2:v});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void set_severity       (string idname,\n avery_severity v);    "
    },
    "apci_log :: set_severity_by_id": {
        "prefix": [
            "set_severity_by_id",
            "function:set_severity_by_id -> apci_log"
        ],
        "body": [
            "set_severity_by_id(${1:id}, ${2:v});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void set_severity_by_id (apci_chklist_id_e id,\n avery_severity v);    "
    },
    "apci_log :: lock_severity_by_id": {
        "prefix": [
            "lock_severity_by_id",
            "function:lock_severity_by_id -> apci_log"
        ],
        "body": [
            "lock_severity_by_id(${1:id}, ${2:v});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void lock_severity_by_id (apci_chklist_id_e id,\n bit v);    "
    },
    "apci_log :: info": {
        "prefix": [
            "info",
            "function:info -> apci_log"
        ],
        "body": [
            "info(${1:msg}, ${2:line_breaks_prefix});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void info (string msg=\"\",\n int line_breaks_prefix=0);    "
    },
    "apci_log :: warn": {
        "prefix": [
            "warn",
            "function:warn -> apci_log"
        ],
        "body": [
            "warn(${1:msg});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void warn (string msg=\"\");                                 "
    },
    "apci_log :: error": {
        "prefix": [
            "error",
            "function:error -> apci_log"
        ],
        "body": [
            "error(${1:msg}, ${2:f});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void error(string msg = \"\",\n avery_data_base f=null);    "
    },
    "apci_log :: fatal": {
        "prefix": [
            "fatal",
            "function:fatal -> apci_log"
        ],
        "body": [
            "fatal(${1:msg}, ${2:msg2});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void fatal(string msg,\n string msg2 = \"\");    "
    },
    "apci_log :: usage": {
        "prefix": [
            "usage",
            "function:usage -> apci_log"
        ],
        "body": [
            "usage(${1:msg}, ${2:is_finish});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void usage(string msg,\n int is_finish=1);    "
    },
    "apci_log :: coverage_rpt": {
        "prefix": [
            "coverage_rpt",
            "function:coverage_rpt -> apci_log"
        ],
        "body": [
            "coverage_rpt(${1:filename});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void coverage_rpt (string filename=\"\");    "
    },
    "apci_log :: sample": {
        "prefix": [
            "sample",
            "function:sample -> apci_log"
        ],
        "body": [
            "sample(${1:id});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void sample (apci_chklist_id_e id);    "
    },
    "apci_log :: sample_only": {
        "prefix": [
            "sample_only",
            "function:sample_only -> apci_log"
        ],
        "body": [
            "sample_only(${1:id});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void sample_only (apci_chklist_id_e id);    "
    },
    "apci_log :: fire": {
        "prefix": [
            "fire",
            "function:fire -> apci_log"
        ],
        "body": [
            "fire(${1:id}, ${2:msg}, ${3:f});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function void fire (apci_chklist_id_e id,\n string msg=\"\",\n avery_data_base f=null);    "
    },
    "apci_log :: cnt_fired": {
        "prefix": [
            "cnt_fired",
            "function:cnt_fired -> apci_log"
        ],
        "body": [
            "cnt_fired(${1:id});"
        ],
        "description": "[Class:apci_log]\n     extern virtual function int  cnt_fired (apci_chklist_id_e id);    "
    },
    "apci_log :: message_control": {
        "prefix": [
            "message_control",
            "function:message_control -> apci_log"
        ],
        "body": [
            "message_control(${1:s}, ${2:is_enable});"
        ],
        "description": "[Class:apci_log]\n     function void message_control(string s,\n bit is_enable);    "
    },
    "apci_log :: disable_info": {
        "prefix": [
            "disable_info",
            "function:disable_info -> apci_log"
        ],
        "body": [
            "disable_info(${0:});"
        ],
        "description": "[Class:apci_log]\n     function void disable_info();    "
    },
    "apci_log :: enable_info": {
        "prefix": [
            "enable_info",
            "function:enable_info -> apci_log"
        ],
        "body": [
            "enable_info(${0:});"
        ],
        "description": "[Class:apci_log]\n     function void enable_info();    "
    },
    "apci_log :: step": {
        "prefix": [
            "step",
            "function:step -> apci_log"
        ],
        "body": [
            "step(${1:msg});"
        ],
        "description": "[Class:apci_log]\n     extern function void step( string msg);    "
    },
    "apci_log :: substep": {
        "prefix": [
            "substep",
            "function:substep -> apci_log"
        ],
        "body": [
            "substep(${1:msg});"
        ],
        "description": "[Class:apci_log]\n     extern function void substep( string msg);    "
    },
    "apci_log :: add_mirror": {
        "prefix": [
            "add_mirror",
            "function:add_mirror -> apci_log"
        ],
        "body": [
            "add_mirror(${1:log});"
        ],
        "description": "[Class:apci_log]\n     extern function void add_mirror( apci_log log);    "
    },
    "apci_log :: trim_path": {
        "prefix": [
            "trim_path",
            "function:trim_path -> apci_log"
        ],
        "body": [
            "trim_path(${1:path}, ${2:num_dots}, ${3:remove_leading_scope});"
        ],
        "description": "[Class:apci_log]\n     extern function string trim_path(string path,\n int num_dots = 1,\n bit remove_leading_scope = 0);    "
    },
    "apci_ltssm_timeout_mon": {
        "prefix": "apci_ltssm_timeout_mon",
        "body": [
            "apci_ltssm_timeout_mon  ${0:name_class};"
        ],
        "description": "class apci_ltssm_timeout_mon;\n"
    },
    "apci_ltssm_timeout_mon :: new": {
        "prefix": [
            "new",
            "function:new -> apci_ltssm_timeout_mon"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:dev});"
        ],
        "description": "[Class:apci_ltssm_timeout_mon]\n     function new(string name,\n apci_log log,\n apci_device dev);    "
    },
    "apci_ltssm_timeout_mon :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_ltssm_timeout_mon"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_ltssm_timeout_mon]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_ltssm_timeout_mon :: monitor_ltssm_timeout": {
        "prefix": [
            "monitor_ltssm_timeout",
            "task:monitor_ltssm_timeout -> apci_ltssm_timeout_mon"
        ],
        "body": [
            "monitor_ltssm_timeout(${1:port_id});"
        ],
        "description": "[Class:apci_ltssm_timeout_mon]\n     extern virtual task monitor_ltssm_timeout(int port_id = 0);    "
    },
    "apci_ltssm_timeout_mon :: detect_ltssm_state_change": {
        "prefix": [
            "detect_ltssm_state_change",
            "task:detect_ltssm_state_change -> apci_ltssm_timeout_mon"
        ],
        "body": [
            "detect_ltssm_state_change(${1:port_id}, ${2:state}, ${3:state_timer});"
        ],
        "description": "[Class:apci_ltssm_timeout_mon]\n     extern virtual task detect_ltssm_state_change(int port_id = 0,\n apci_ltssm_state_e state,\n avery_u64 state_timer);    "
    },
    "apci_func_info": {
        "prefix": "apci_func_info",
        "body": [
            "apci_func_info  ${0:name_class};"
        ],
        "description": "class apci_func_info extends apci_data_base;\n"
    },
    "apci_func_info :: new": {
        "prefix": [
            "new",
            "function:new -> apci_func_info"
        ],
        "body": [
            "new(${1:name}, ${2:bdf});"
        ],
        "description": "[Class:apci_func_info]\n     extern function new(string name = \"\",\n apci_bdf_t bdf);    "
    },
    "apci_func_info :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_func_info"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_func_info]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_func_info :: get_link_partner": {
        "prefix": [
            "get_link_partner",
            "function:get_link_partner -> apci_func_info"
        ],
        "body": [
            "get_link_partner(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     extern virtual function apci_func_info get_link_partner();    "
    },
    "apci_func_info :: get_link_partner_bdf": {
        "prefix": [
            "get_link_partner_bdf",
            "function:get_link_partner_bdf -> apci_func_info"
        ],
        "body": [
            "get_link_partner_bdf(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     extern virtual function apci_bdf_t get_link_partner_bdf();    "
    },
    "apci_func_info :: get_device_mgr": {
        "prefix": [
            "get_device_mgr",
            "function:get_device_mgr -> apci_func_info"
        ],
        "body": [
            "get_device_mgr(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     extern virtual function apci_device_mgr get_device_mgr();    "
    },
    "apci_func_info :: is_rcrb": {
        "prefix": [
            "is_rcrb",
            "function:is_rcrb -> apci_func_info"
        ],
        "body": [
            "is_rcrb(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     virtual function bit is_rcrb();    "
    },
    "apci_func_info :: connected_to_cxl": {
        "prefix": [
            "connected_to_cxl",
            "function:connected_to_cxl -> apci_func_info"
        ],
        "body": [
            "connected_to_cxl(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     function bit connected_to_cxl();    "
    },
    "apci_func_info :: connected_to_cxl2": {
        "prefix": [
            "connected_to_cxl2",
            "function:connected_to_cxl2 -> apci_func_info"
        ],
        "body": [
            "connected_to_cxl2(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     function bit connected_to_cxl2();    "
    },
    "apci_func_info :: connected_to_cxl11": {
        "prefix": [
            "connected_to_cxl11",
            "function:connected_to_cxl11 -> apci_func_info"
        ],
        "body": [
            "connected_to_cxl11(${0:});"
        ],
        "description": "[Class:apci_func_info]\n     function bit connected_to_cxl11();    "
    },
    "apci_margin_cmd": {
        "prefix": "apci_margin_cmd",
        "body": [
            "apci_margin_cmd  ${0:name_class};"
        ],
        "description": "class apci_margin_cmd extends apci_data_base;\n"
    },
    "apci_margin_cmd :: new": {
        "prefix": [
            "new",
            "function:new -> apci_margin_cmd"
        ],
        "body": [
            "new(${1:kind});"
        ],
        "description": "[Class:apci_margin_cmd]\n     function new(`avery_strname  apci_margin_type kind = APCI_MARGIN_unknown);    "
    },
    "apci_margin_cmd :: is_step_margin": {
        "prefix": [
            "is_step_margin",
            "function:is_step_margin -> apci_margin_cmd"
        ],
        "body": [
            "is_step_margin(${0:});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function bit is_step_margin        (); return kind inside {APCI_MARGIN_step_margin_timing,\n APCI_MARGIN_step_margin_voltage}; endfunction    "
    },
    "apci_margin_cmd :: is_step_margin_timing": {
        "prefix": [
            "is_step_margin_timing",
            "function:is_step_margin_timing -> apci_margin_cmd"
        ],
        "body": [
            "is_step_margin_timing(${0:});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function bit is_step_margin_timing (); return kind == APCI_MARGIN_step_margin_timing ; endfunction    "
    },
    "apci_margin_cmd :: is_step_margin_voltage": {
        "prefix": [
            "is_step_margin_voltage",
            "function:is_step_margin_voltage -> apci_margin_cmd"
        ],
        "body": [
            "is_step_margin_voltage(${0:});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function bit is_step_margin_voltage(); return kind == APCI_MARGIN_step_margin_voltage; endfunction    "
    },
    "apci_margin_cmd :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_margin_cmd"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_margin_cmd]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_margin_cmd :: is_broadcast": {
        "prefix": [
            "is_broadcast",
            "function:is_broadcast -> apci_margin_cmd"
        ],
        "body": [
            "is_broadcast(${0:});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function is_broadcast();    "
    },
    "apci_margin_cmd :: is_report": {
        "prefix": [
            "is_report",
            "function:is_report -> apci_margin_cmd"
        ],
        "body": [
            "is_report(${0:});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function bit is_report();    "
    },
    "apci_margin_cmd :: encode": {
        "prefix": [
            "encode",
            "function:encode -> apci_margin_cmd"
        ],
        "body": [
            "encode(${1:log});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function void encode(apci_log log);    "
    },
    "apci_margin_cmd :: decode": {
        "prefix": [
            "decode",
            "function:decode -> apci_margin_cmd"
        ],
        "body": [
            "decode(${1:log});"
        ],
        "description": "[Class:apci_margin_cmd]\n     virtual function void decode(apci_log log);    "
    },
    "apci_tlp": {
        "prefix": "apci_tlp",
        "body": [
            "apci_tlp  ${0:name_class};"
        ],
        "description": "class apci_tlp extends apci_packet;\n"
    },
    "apci_tlp :: new": {
        "prefix": [
            "new",
            "function:new -> apci_tlp"
        ],
        "body": [
            "new(${1:kind});"
        ],
        "description": "[Class:apci_tlp]\n     extern function new(`avery_strname  apci_tlp_type kind = APCI_TLP_unknown);    "
    },
    "apci_tlp :: pre_randomize": {
        "prefix": [
            "pre_randomize",
            "function:pre_randomize -> apci_tlp"
        ],
        "body": [
            "pre_randomize(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function void pre_randomize(); endfunction    "
    },
    "apci_tlp :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_tlp"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:apci_tlp]\n     extern function apci_tlp copy  (apci_tlp to = null,\n int level = -1);    "
    },
    "apci_tlp :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_tlp"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_tlp]\n     extern function string   sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_tlp :: compare": {
        "prefix": [
            "compare",
            "function:compare -> apci_tlp"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:apci_tlp]\n     extern function bit compare(apci_tlp to,\n ref string diff);    "
    },
    "apci_tlp :: decode_kind": {
        "prefix": [
            "decode_kind",
            "function:decode_kind -> apci_tlp"
        ],
        "body": [
            "decode_kind(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void decode_kind();    "
    },
    "apci_tlp :: rehash_ecrc": {
        "prefix": [
            "rehash_ecrc",
            "function:rehash_ecrc -> apci_tlp"
        ],
        "body": [
            "rehash_ecrc(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void rehash_ecrc();    "
    },
    "apci_tlp :: cpl_is_last_split": {
        "prefix": [
            "cpl_is_last_split",
            "function:cpl_is_last_split -> apci_tlp"
        ],
        "body": [
            "cpl_is_last_split(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit cpl_is_last_split();    "
    },
    "apci_tlp :: ide_encrypt": {
        "prefix": [
            "ide_encrypt",
            "function:ide_encrypt -> apci_tlp"
        ],
        "body": [
            "ide_encrypt(${1:is_link_stream}, ${2:aesgcm});"
        ],
        "description": "[Class:apci_tlp]\n     extern function void ide_encrypt(bit is_link_stream,\n ref avery_aesgcm aesgcm);    "
    },
    "apci_tlp :: ide_decrypt": {
        "prefix": [
            "ide_decrypt",
            "function:ide_decrypt -> apci_tlp"
        ],
        "body": [
            "ide_decrypt(${1:is_link_stream}, ${2:aesgcm});"
        ],
        "description": "[Class:apci_tlp]\n     extern function int ide_decrypt(bit is_link_stream,\n ref avery_aesgcm aesgcm);    "
    },
    "apci_tlp :: rehash_ide_pcrc": {
        "prefix": [
            "rehash_ide_pcrc",
            "function:rehash_ide_pcrc -> apci_tlp"
        ],
        "body": [
            "rehash_ide_pcrc(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern function avery_u32 rehash_ide_pcrc();    "
    },
    "apci_tlp :: is_4header": {
        "prefix": [
            "is_4header",
            "function:is_4header -> apci_tlp"
        ],
        "body": [
            "is_4header(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_4header();   return (u.com.fmt       && kind != APCI_TLP_vendor_p && is_ccix.optimized == 0); endfunction    "
    },
    "apci_tlp :: is_mem": {
        "prefix": [
            "is_mem",
            "function:is_mem -> apci_tlp"
        ],
        "body": [
            "is_mem(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_mem32;    return is_mem() && !u.com.fmt      ; endfunction    "
    },
    "apci_tlp :: is_pure_mem": {
        "prefix": [
            "is_pure_mem",
            "function:is_pure_mem -> apci_tlp"
        ],
        "body": [
            "is_pure_mem(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_pure_mem();  return kind inside {APCI_TLP_mrd,\n APCI_TLP_mrdlk,\n APCI_TLP_mwr,\n APCI_TLP_dmwr}; endfunction    "
    },
    "apci_tlp :: is_io": {
        "prefix": [
            "is_io",
            "function:is_io -> apci_tlp"
        ],
        "body": [
            "is_io(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_io();        return kind inside {APCI_TLP_iord,\n APCI_TLP_iowr};  endfunction    "
    },
    "apci_tlp :: is_cfg": {
        "prefix": [
            "is_cfg",
            "function:is_cfg -> apci_tlp"
        ],
        "body": [
            "is_cfg(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_cfg();       return kind inside {APCI_TLP_cfgrd,\n APCI_TLP_cfgwr,\n APCI_TLP_cfgrd0,\n APCI_TLP_cfgwr0,\n APCI_TLP_cfgrd1,\n APCI_TLP_cfgwr1}; endfunction    "
    },
    "apci_tlp :: is_msg": {
        "prefix": [
            "is_msg",
            "function:is_msg -> apci_tlp"
        ],
        "body": [
            "is_msg(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_msg();       return kind inside {APCI_TLP_msg,\n APCI_TLP_msgd}; endfunction    "
    },
    "apci_tlp :: is_cpl": {
        "prefix": [
            "is_cpl",
            "function:is_cpl -> apci_tlp"
        ],
        "body": [
            "is_cpl(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_cpl();       return kind inside {APCI_TLP_cpl,\n APCI_TLP_cpld,\n APCI_TLP_cpllk,\n APCI_TLP_cpldlk}; endfunction    "
    },
    "apci_tlp :: is_type1_cfg": {
        "prefix": [
            "is_type1_cfg",
            "function:is_type1_cfg -> apci_tlp"
        ],
        "body": [
            "is_type1_cfg(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_type1_cfg(); return kind inside {APCI_TLP_cfgrd1,\n APCI_TLP_cfgwr1}; endfunction    "
    },
    "apci_tlp :: is_cpl_nd": {
        "prefix": [
            "is_cpl_nd",
            "function:is_cpl_nd -> apci_tlp"
        ],
        "body": [
            "is_cpl_nd(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_cpl_nd();    return kind inside {APCI_TLP_cpl,\n  APCI_TLP_cpllk}; endfunction    "
    },
    "apci_tlp :: is_cpld": {
        "prefix": [
            "is_cpld",
            "function:is_cpld -> apci_tlp"
        ],
        "body": [
            "is_cpld(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_cpld();      return kind inside {APCI_TLP_cpld,\n APCI_TLP_cpldlk}; endfunction    "
    },
    "apci_tlp :: is_mem_rd": {
        "prefix": [
            "is_mem_rd",
            "function:is_mem_rd -> apci_tlp"
        ],
        "body": [
            "is_mem_rd(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_mem_rd();    return kind inside {APCI_TLP_mrd,\n  APCI_TLP_mrdlk}; endfunction    "
    },
    "apci_tlp :: is_mem_wr": {
        "prefix": [
            "is_mem_wr",
            "function:is_mem_wr -> apci_tlp"
        ],
        "body": [
            "is_mem_wr(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_mem_wr();    return kind inside {APCI_TLP_mwr,\n APCI_TLP_dmwr}; endfunction    "
    },
    "apci_tlp :: is_deferred_mem_wr": {
        "prefix": [
            "is_deferred_mem_wr",
            "function:is_deferred_mem_wr -> apci_tlp"
        ],
        "body": [
            "is_deferred_mem_wr(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_deferred_mem_wr();    return kind == APCI_TLP_dmwr; endfunction    "
    },
    "apci_tlp :: is_io_rd": {
        "prefix": [
            "is_io_rd",
            "function:is_io_rd -> apci_tlp"
        ],
        "body": [
            "is_io_rd(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_io_rd();     return kind inside {APCI_TLP_iord}; endfunction    "
    },
    "apci_tlp :: is_atomic": {
        "prefix": [
            "is_atomic",
            "function:is_atomic -> apci_tlp"
        ],
        "body": [
            "is_atomic(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_atomic();    return kind inside {APCI_TLP_fetchadd,\n APCI_TLP_swap,\n APCI_TLP_cas}; endfunction    "
    },
    "apci_tlp :: is_posted": {
        "prefix": [
            "is_posted",
            "function:is_posted -> apci_tlp"
        ],
        "body": [
            "is_posted(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_posted();    return(kind inside {APCI_TLP_mwr,\n APCI_TLP_vendor_p}) || is_msg() || is_ccix; endfunction    "
    },
    "apci_tlp :: is_non_posted": {
        "prefix": [
            "is_non_posted",
            "function:is_non_posted -> apci_tlp"
        ],
        "body": [
            "is_non_posted(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_non_posted();return !is_posted && !is_cpl(); endfunction    "
    },
    "apci_tlp :: is_request": {
        "prefix": [
            "is_request",
            "function:is_request -> apci_tlp"
        ],
        "body": [
            "is_request(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_request();   return !is_cpl(); endfunction    "
    },
    "apci_tlp :: is_np_read": {
        "prefix": [
            "is_np_read",
            "function:is_np_read -> apci_tlp"
        ],
        "body": [
            "is_np_read(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_np_read();   return kind inside {APCI_TLP_mrd,\n  APCI_TLP_mrdlk,\n    "
    },
    "apci_tlp :: is_np_write": {
        "prefix": [
            "is_np_write",
            "function:is_np_write -> apci_tlp"
        ],
        "body": [
            "is_np_write(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_np_write();  return kind inside {APCI_TLP_iowr,\n APCI_TLP_cfgwr0,\n APCI_TLP_cfgwr1 ,\n APCI_TLP_tcfgwr,\n    "
    },
    "apci_tlp :: is_relaxed_order": {
        "prefix": [
            "is_relaxed_order",
            "function:is_relaxed_order -> apci_tlp"
        ],
        "body": [
            "is_relaxed_order(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_relaxed_order(); return u.com.attr      ; endfunction    "
    },
    "apci_tlp :: is_id_based_order": {
        "prefix": [
            "is_id_based_order",
            "function:is_id_based_order -> apci_tlp"
        ],
        "body": [
            "is_id_based_order(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_id_based_order();return u.com.attr2; endfunction       "
    },
    "apci_tlp :: is_ats_request": {
        "prefix": [
            "is_ats_request",
            "function:is_ats_request -> apci_tlp"
        ],
        "body": [
            "is_ats_request(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ats_request(); return kind == APCI_TLP_mrd && get_at() == 1; endfunction    "
    },
    "apci_tlp :: is_ats_invalidate": {
        "prefix": [
            "is_ats_invalidate",
            "function:is_ats_invalidate -> apci_tlp"
        ],
        "body": [
            "is_ats_invalidate(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ats_invalidate(); return kind == APCI_TLP_msgd && get_msg_code() == APCI_MSG_ats_invalidate; endfunction    "
    },
    "apci_tlp :: is_ats_invalidate_cpl": {
        "prefix": [
            "is_ats_invalidate_cpl",
            "function:is_ats_invalidate_cpl -> apci_tlp"
        ],
        "body": [
            "is_ats_invalidate_cpl(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ats_invalidate_cpl(); return kind == APCI_TLP_msg && get_msg_code() == APCI_MSG_ats_invalidate_cpl; endfunction    "
    },
    "apci_tlp :: is_ats_page_req": {
        "prefix": [
            "is_ats_page_req",
            "function:is_ats_page_req -> apci_tlp"
        ],
        "body": [
            "is_ats_page_req(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ats_page_req(); return kind == APCI_TLP_msg && get_msg_code() == APCI_MSG_ats_page_request; endfunction    "
    },
    "apci_tlp :: is_ats_prg_response": {
        "prefix": [
            "is_ats_prg_response",
            "function:is_ats_prg_response -> apci_tlp"
        ],
        "body": [
            "is_ats_prg_response(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ats_prg_response(); return kind == APCI_TLP_msg && get_msg_code() == APCI_MSG_ats_prg_response; endfunction    "
    },
    "apci_tlp :: is_set_slot_power_limit": {
        "prefix": [
            "is_set_slot_power_limit",
            "function:is_set_slot_power_limit -> apci_tlp"
        ],
        "body": [
            "is_set_slot_power_limit(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_set_slot_power_limit(); return kind == APCI_TLP_msgd && get_msg_code() == APCI_MSG_set_slot_power_limit; endfunction    "
    },
    "apci_tlp :: is_poisoned": {
        "prefix": [
            "is_poisoned",
            "function:is_poisoned -> apci_tlp"
        ],
        "body": [
            "is_poisoned(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_poisoned(); return u.com.ep; endfunction    "
    },
    "apci_tlp :: is_vendor_p": {
        "prefix": [
            "is_vendor_p",
            "function:is_vendor_p -> apci_tlp"
        ],
        "body": [
            "is_vendor_p(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_vendor_p(); return kind == APCI_TLP_vendor_p; endfunction    "
    },
    "apci_tlp :: is_zero_length_write": {
        "prefix": [
            "is_zero_length_write",
            "function:is_zero_length_write -> apci_tlp"
        ],
        "body": [
            "is_zero_length_write(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_zero_length_write(); return this.get_first_be == 0 && this.get_last_be == 0 && this.get_length_dw == 1; endfunction    "
    },
    "apci_tlp :: is_ptm_msg": {
        "prefix": [
            "is_ptm_msg",
            "function:is_ptm_msg -> apci_tlp"
        ],
        "body": [
            "is_ptm_msg(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ptm_msg(); return is_msg() && get_msg_code() inside {APCI_MSG_ptm_req,\n APCI_MSG_ptm_resp}; endfunction    "
    },
    "apci_tlp :: is_ide_sync_msg": {
        "prefix": [
            "is_ide_sync_msg",
            "function:is_ide_sync_msg -> apci_tlp"
        ],
        "body": [
            "is_ide_sync_msg(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ide_sync_msg(); return is_msg() && get_msg_code() == APCI_MSG_ide_sync; endfunction    "
    },
    "apci_tlp :: has_ecrc": {
        "prefix": [
            "has_ecrc",
            "function:has_ecrc -> apci_tlp"
        ],
        "body": [
            "has_ecrc(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit has_ecrc();     return (u.com.td || (is_flit_mode && u.fm_com.ts == 3'b001)); endfunction    "
    },
    "apci_tlp :: has_data": {
        "prefix": [
            "has_data",
            "function:has_data -> apci_tlp"
        ],
        "body": [
            "has_data(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit has_data();  return is_write(); endfunction    "
    },
    "apci_tlp :: is_write": {
        "prefix": [
            "is_write",
            "function:is_write -> apci_tlp"
        ],
        "body": [
            "is_write(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern function bit is_write();      "
    },
    "apci_tlp :: is_cross4k": {
        "prefix": [
            "is_cross4k",
            "function:is_cross4k -> apci_tlp"
        ],
        "body": [
            "is_cross4k(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_cross4k();    "
    },
    "apci_tlp :: this.get_cpl_status": {
        "prefix": [
            "this.get_cpl_status",
            "function:this.get_cpl_status -> apci_tlp"
        ],
        "body": [
            "this.get_cpl_status(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit cpl_is_ok; return this.get_cpl_status() == 0; endfunction    "
    },
    "apci_tlp :: get_steering_tag": {
        "prefix": [
            "get_steering_tag",
            "function:get_steering_tag -> apci_tlp"
        ],
        "body": [
            "get_steering_tag(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit       get_steering_tag();     "
    },
    "apci_tlp :: set_steering_tag": {
        "prefix": [
            "set_steering_tag",
            "function:set_steering_tag -> apci_tlp"
        ],
        "body": [
            "set_steering_tag(${1:steering_tag});"
        ],
        "description": "[Class:apci_tlp]\n     function void set_steering_tag(bit       steering_tag);    "
    },
    "apci_tlp :: be_is_steering_tag": {
        "prefix": [
            "be_is_steering_tag",
            "function:be_is_steering_tag -> apci_tlp"
        ],
        "body": [
            "be_is_steering_tag(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit be_is_steering_tag();    "
    },
    "apci_tlp :: get_tag": {
        "prefix": [
            "get_tag",
            "function:get_tag -> apci_tlp"
        ],
        "body": [
            "get_tag(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit       get_tag();    "
    },
    "apci_tlp :: set_tag": {
        "prefix": [
            "set_tag",
            "function:set_tag -> apci_tlp"
        ],
        "body": [
            "set_tag(${1:tag});"
        ],
        "description": "[Class:apci_tlp]\n     function void set_tag(bit       tag);    "
    },
    "apci_tlp :: get_first_be": {
        "prefix": [
            "get_first_be",
            "function:get_first_be -> apci_tlp"
        ],
        "body": [
            "get_first_be(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit       get_first_be();    "
    },
    "apci_tlp :: set_first_be": {
        "prefix": [
            "set_first_be",
            "function:set_first_be -> apci_tlp"
        ],
        "body": [
            "set_first_be(${1:fbe});"
        ],
        "description": "[Class:apci_tlp]\n     function void set_first_be(bit       fbe);    "
    },
    "apci_tlp :: get_last_be": {
        "prefix": [
            "get_last_be",
            "function:get_last_be -> apci_tlp"
        ],
        "body": [
            "get_last_be(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit       get_last_be();    "
    },
    "apci_tlp :: set_last_be": {
        "prefix": [
            "set_last_be",
            "function:set_last_be -> apci_tlp"
        ],
        "body": [
            "set_last_be(${1:lbe});"
        ],
        "description": "[Class:apci_tlp]\n     function void set_last_be(bit       lbe);    "
    },
    "apci_tlp :: get_rid": {
        "prefix": [
            "get_rid",
            "function:get_rid -> apci_tlp"
        ],
        "body": [
            "get_rid(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit       get_rid();    "
    },
    "apci_tlp :: get_tid": {
        "prefix": [
            "get_tid",
            "function:get_tid -> apci_tlp"
        ],
        "body": [
            "get_tid(${1:is_10bit_tag}, ${2:is_14bit_tag});"
        ],
        "description": "[Class:apci_tlp]\n     function bit       get_tid(bit is_10bit_tag = 1,\n bit is_14bit_tag = 0);    "
    },
    "apci_tlp :: set_tid": {
        "prefix": [
            "set_tid",
            "function:set_tid -> apci_tlp"
        ],
        "body": [
            "set_tid(${1:tid});"
        ],
        "description": "[Class:apci_tlp]\n     function void set_tid(bit       tid);    "
    },
    "apci_tlp :: get_length_dw": {
        "prefix": [
            "get_length_dw",
            "function:get_length_dw -> apci_tlp"
        ],
        "body": [
            "get_length_dw(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function avery_u32 get_length_dw();    "
    },
    "apci_tlp :: rehash_frame_crc_parity": {
        "prefix": [
            "rehash_frame_crc_parity",
            "function:rehash_frame_crc_parity -> apci_tlp"
        ],
        "body": [
            "rehash_frame_crc_parity(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void rehash_frame_crc_parity();    "
    },
    "apci_tlp :: get_replay_cnt": {
        "prefix": [
            "get_replay_cnt",
            "function:get_replay_cnt -> apci_tlp"
        ],
        "body": [
            "get_replay_cnt(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function int get_replay_cnt();    "
    },
    "apci_tlp :: enable_ecrc_gen": {
        "prefix": [
            "enable_ecrc_gen",
            "function:enable_ecrc_gen -> apci_tlp"
        ],
        "body": [
            "enable_ecrc_gen(${1:en_ecrc});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void enable_ecrc_gen(bit en_ecrc);    "
    },
    "apci_tlp :: set_byte_cnt": {
        "prefix": [
            "set_byte_cnt",
            "function:set_byte_cnt -> apci_tlp"
        ],
        "body": [
            "set_byte_cnt(${1:byte_cnt});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_byte_cnt(bit       byte_cnt);    "
    },
    "apci_tlp :: get_byte_cnt": {
        "prefix": [
            "get_byte_cnt",
            "function:get_byte_cnt -> apci_tlp"
        ],
        "body": [
            "get_byte_cnt(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_byte_cnt();     "
    },
    "apci_tlp :: set_low_addr": {
        "prefix": [
            "set_low_addr",
            "function:set_low_addr -> apci_tlp"
        ],
        "body": [
            "set_low_addr(${1:low_addr});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_low_addr(bit       low_addr);    "
    },
    "apci_tlp :: get_low_addr": {
        "prefix": [
            "get_low_addr",
            "function:get_low_addr -> apci_tlp"
        ],
        "body": [
            "get_low_addr(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_low_addr();    "
    },
    "apci_tlp :: set_cpl_status": {
        "prefix": [
            "set_cpl_status",
            "function:set_cpl_status -> apci_tlp"
        ],
        "body": [
            "set_cpl_status(${1:cpl_status});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_cpl_status(bit       cpl_status);    "
    },
    "apci_tlp :: get_cpl_status": {
        "prefix": [
            "get_cpl_status",
            "function:get_cpl_status -> apci_tlp"
        ],
        "body": [
            "get_cpl_status(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_cpl_status();    "
    },
    "apci_tlp :: set_attr": {
        "prefix": [
            "set_attr",
            "function:set_attr -> apci_tlp"
        ],
        "body": [
            "set_attr(${1:attr});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_attr(bit       attr);    "
    },
    "apci_tlp :: get_attr": {
        "prefix": [
            "get_attr",
            "function:get_attr -> apci_tlp"
        ],
        "body": [
            "get_attr(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_attr();    "
    },
    "apci_tlp :: set_msg_code": {
        "prefix": [
            "set_msg_code",
            "function:set_msg_code -> apci_tlp"
        ],
        "body": [
            "set_msg_code(${1:msg_code});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_msg_code(bit       msg_code);    "
    },
    "apci_tlp :: get_msg_code": {
        "prefix": [
            "get_msg_code",
            "function:get_msg_code -> apci_tlp"
        ],
        "body": [
            "get_msg_code(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_msg_code();    "
    },
    "apci_tlp :: set_tc": {
        "prefix": [
            "set_tc",
            "function:set_tc -> apci_tlp"
        ],
        "body": [
            "set_tc(${1:tc});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_tc(bit       tc);      "
    },
    "apci_tlp :: get_tc": {
        "prefix": [
            "get_tc",
            "function:get_tc -> apci_tlp"
        ],
        "body": [
            "get_tc(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_tc();    "
    },
    "apci_tlp :: set_ph": {
        "prefix": [
            "set_ph",
            "function:set_ph -> apci_tlp"
        ],
        "body": [
            "set_ph(${1:ph});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_ph(bit       ph);    "
    },
    "apci_tlp :: get_ph": {
        "prefix": [
            "get_ph",
            "function:get_ph -> apci_tlp"
        ],
        "body": [
            "get_ph(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_ph();     "
    },
    "apci_tlp :: set_at": {
        "prefix": [
            "set_at",
            "function:set_at -> apci_tlp"
        ],
        "body": [
            "set_at(${1:at});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_at(bit       at);    "
    },
    "apci_tlp :: get_at": {
        "prefix": [
            "get_at",
            "function:get_at -> apci_tlp"
        ],
        "body": [
            "get_at(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_at();    "
    },
    "apci_tlp :: set_cpl_id": {
        "prefix": [
            "set_cpl_id",
            "function:set_cpl_id -> apci_tlp"
        ],
        "body": [
            "set_cpl_id(${1:cpl_id});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_cpl_id(bit       cpl_id);    "
    },
    "apci_tlp :: get_cpl_id": {
        "prefix": [
            "get_cpl_id",
            "function:get_cpl_id -> apci_tlp"
        ],
        "body": [
            "get_cpl_id(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_cpl_id();    "
    },
    "apci_tlp :: set_req_id": {
        "prefix": [
            "set_req_id",
            "function:set_req_id -> apci_tlp"
        ],
        "body": [
            "set_req_id(${1:req_id});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function void set_req_id(bit       req_id);    "
    },
    "apci_tlp :: get_req_id": {
        "prefix": [
            "get_req_id",
            "function:get_req_id -> apci_tlp"
        ],
        "body": [
            "get_req_id(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     extern virtual function bit       get_req_id();    "
    },
    "apci_tlp :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> apci_tlp"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function void post_randomize();    "
    },
    "apci_tlp :: is_ide_tlp": {
        "prefix": [
            "is_ide_tlp",
            "function:is_ide_tlp -> apci_tlp"
        ],
        "body": [
            "is_ide_tlp(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function bit is_ide_tlp();    "
    },
    "apci_tlp :: get_ide_prefix": {
        "prefix": [
            "get_ide_prefix",
            "function:get_ide_prefix -> apci_tlp"
        ],
        "body": [
            "get_ide_prefix(${0:});"
        ],
        "description": "[Class:apci_tlp]\n     function apci_tlp_prefix_u get_ide_prefix();    "
    },
    "apci_tlp :: set_ide_pr_sent_count": {
        "prefix": [
            "set_ide_pr_sent_count",
            "function:set_ide_pr_sent_count -> apci_tlp"
        ],
        "body": [
            "set_ide_pr_sent_count(${1:pr_sent_cnt});"
        ],
        "description": "[Class:apci_tlp]\n     function void set_ide_pr_sent_count(bit       pr_sent_cnt);    "
    },
    "acxl_msgs_in_slot": {
        "prefix": "acxl_msgs_in_slot",
        "body": [
            "acxl_msgs_in_slot  ${0:name_class};"
        ],
        "description": "class acxl_msgs_in_slot;\n"
    },
    "acxl_flit": {
        "prefix": "acxl_flit",
        "body": [
            "acxl_flit  ${0:name_class};"
        ],
        "description": "class acxl_flit extends apci_data_base;\n"
    },
    "acxl_flit :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_flit"
        ],
        "body": [
            "new(${1:name}, ${2:kind});"
        ],
        "description": "[Class:acxl_flit]\n     extern function new(string name= \"\",\n acxl_flit_type kind = ACXL_FLIT_unknown);    "
    },
    "acxl_flit :: pre_randomize": {
        "prefix": [
            "pre_randomize",
            "function:pre_randomize -> acxl_flit"
        ],
        "body": [
            "pre_randomize(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     function void pre_randomize(); endfunction    "
    },
    "acxl_flit :: copy": {
        "prefix": [
            "copy",
            "function:copy -> acxl_flit"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:acxl_flit]\n     extern function acxl_flit copy  (acxl_flit to = null,\n int level = -1);    "
    },
    "acxl_flit :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_flit"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_flit]\n     extern function string   sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_flit :: compare": {
        "prefix": [
            "compare",
            "function:compare -> acxl_flit"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:acxl_flit]\n     extern function bit compare(acxl_flit to,\n ref string diff);    "
    },
    "acxl_flit :: check_decode_kind": {
        "prefix": [
            "check_decode_kind",
            "function:check_decode_kind -> acxl_flit"
        ],
        "body": [
            "check_decode_kind(${1:log}, ${2:cxlcfg}, ${3:portcfg}, ${4:err_no});"
        ],
        "description": "[Class:acxl_flit]\n     extern function void check_decode_kind(        apci_log           log    ,\n                                                   acxl_cfg_info      cxlcfg,\n                                                   acxl_port_cfg      portcfg,\n                                            output acxl_framing_err_e err_no  );    "
    },
    "acxl_flit :: get_valid_pid_byte": {
        "prefix": [
            "get_valid_pid_byte",
            "function:get_valid_pid_byte -> acxl_flit"
        ],
        "body": [
            "get_valid_pid_byte(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     extern static function quene_of_byte get_valid_pid_byte();    "
    },
    "acxl_flit :: rehash_crc": {
        "prefix": [
            "rehash_crc",
            "function:rehash_crc -> acxl_flit"
        ],
        "body": [
            "rehash_crc(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     extern function void rehash_crc();    "
    },
    "acxl_flit :: end_on_blk_boundary": {
        "prefix": [
            "end_on_blk_boundary",
            "function:end_on_blk_boundary -> acxl_flit"
        ],
        "body": [
            "end_on_blk_boundary(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     extern function bit end_on_blk_boundary();    "
    },
    "acxl_flit :: pid_has_eds": {
        "prefix": [
            "pid_has_eds",
            "function:pid_has_eds -> acxl_flit"
        ],
        "body": [
            "pid_has_eds(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     extern virtual function bit pid_has_eds();    "
    },
    "acxl_flit :: wait_sent": {
        "prefix": [
            "wait_sent",
            "task:wait_sent -> acxl_flit"
        ],
        "body": [
            "wait_sent(${1:entry}, ${2:timer}, ${3:msg});"
        ],
        "description": "[Class:acxl_flit]\n     extern virtual task wait_sent(string entry,\n time timer = 0,\n string msg = \"\");    "
    },
    "acxl_flit :: user_decode_slot": {
        "prefix": [
            "user_decode_slot",
            "function:user_decode_slot -> acxl_flit"
        ],
        "body": [
            "user_decode_slot(${1:log}, ${2:is_down_port}, ${3:is_all_data_flit});"
        ],
        "description": "[Class:acxl_flit]\n     extern function void user_decode_slot(apci_log log,\n bit is_down_port,\n bit is_all_data_flit = 0);    "
    },
    "acxl_flit :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> acxl_flit"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     function void post_randomize();    "
    },
    "acxl_flit :: is_cm_prot": {
        "prefix": [
            "is_cm_prot",
            "function:is_cm_prot -> acxl_flit"
        ],
        "body": [
            "is_cm_prot(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_cm_prot()    ; return kind == ACXL_FLIT_cm_prot   ; endfunction    "
    },
    "acxl_flit :: is_cm_data": {
        "prefix": [
            "is_cm_data",
            "function:is_cm_data -> acxl_flit"
        ],
        "body": [
            "is_cm_data(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_cm_data()    ; return kind == ACXL_FLIT_cm_data   ; endfunction    "
    },
    "acxl_flit :: is_cm": {
        "prefix": [
            "is_cm",
            "function:is_cm -> acxl_flit"
        ],
        "body": [
            "is_cm(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_cm()         ; return kind inside {ACXL_FLIT_cm,\n ACXL_FLIT_cm_prot,\n ACXL_FLIT_cm_data}; endfunction    "
    },
    "acxl_flit :: is_llctrl": {
        "prefix": [
            "is_llctrl",
            "function:is_llctrl -> acxl_flit"
        ],
        "body": [
            "is_llctrl(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_llctrl()     ; return kind inside {ACXL_FLIT_llcrd_ack,\n    "
    },
    "acxl_flit :: is_llcrd_ack": {
        "prefix": [
            "is_llcrd_ack",
            "function:is_llcrd_ack -> acxl_flit"
        ],
        "body": [
            "is_llcrd_ack(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_llcrd_ack()  ; return kind == ACXL_FLIT_llcrd_ack ; endfunction    "
    },
    "acxl_flit :: is_retry_frame": {
        "prefix": [
            "is_retry_frame",
            "function:is_retry_frame -> acxl_flit"
        ],
        "body": [
            "is_retry_frame(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retry_frame(); return kind == ACXL_FLIT_retry_frame; endfunction    "
    },
    "acxl_flit :: is_retry_req": {
        "prefix": [
            "is_retry_req",
            "function:is_retry_req -> acxl_flit"
        ],
        "body": [
            "is_retry_req(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retry_req()  ; return kind == ACXL_FLIT_retry_req ; endfunction    "
    },
    "acxl_flit :: is_retry_ack": {
        "prefix": [
            "is_retry_ack",
            "function:is_retry_ack -> acxl_flit"
        ],
        "body": [
            "is_retry_ack(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retry_ack()  ; return kind == ACXL_FLIT_retry_ack ; endfunction    "
    },
    "acxl_flit :: is_retry_idle": {
        "prefix": [
            "is_retry_idle",
            "function:is_retry_idle -> acxl_flit"
        ],
        "body": [
            "is_retry_idle(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retry_idle()  ; return kind == ACXL_FLIT_retry_idle; endfunction    "
    },
    "acxl_flit :: is_init_param": {
        "prefix": [
            "is_init_param",
            "function:is_init_param -> acxl_flit"
        ],
        "body": [
            "is_init_param(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_init_param() ; return kind == ACXL_FLIT_init_param; endfunction    "
    },
    "acxl_flit :: is_almp": {
        "prefix": [
            "is_almp",
            "function:is_almp -> acxl_flit"
        ],
        "body": [
            "is_almp(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_almp()       ; return kind == ACXL_FLIT_almp      ; endfunction    "
    },
    "acxl_flit :: is_null_flit": {
        "prefix": [
            "is_null_flit",
            "function:is_null_flit -> acxl_flit"
        ],
        "body": [
            "is_null_flit(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_null_flit()  ; return kind == ACXL_FLIT_null      ; endfunction    "
    },
    "acxl_flit :: is_io": {
        "prefix": [
            "is_io",
            "function:is_io -> acxl_flit"
        ],
        "body": [
            "is_io(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_io()         ; return kind == ACXL_FLIT_io        ; endfunction    "
    },
    "acxl_flit :: is_ide": {
        "prefix": [
            "is_ide",
            "function:is_ide -> acxl_flit"
        ],
        "body": [
            "is_ide(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_ide()        ; return kind inside {ACXL_FLIT_ide_start,\n ACXL_FLIT_ide_idle,\n ACXL_FLIT_ide_tmac}; endfunction    "
    },
    "acxl_flit :: is_ide_start": {
        "prefix": [
            "is_ide_start",
            "function:is_ide_start -> acxl_flit"
        ],
        "body": [
            "is_ide_start(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_ide_start()  ; return kind == ACXL_FLIT_ide_start; endfunction    "
    },
    "acxl_flit :: is_ide_idle": {
        "prefix": [
            "is_ide_idle",
            "function:is_ide_idle -> acxl_flit"
        ],
        "body": [
            "is_ide_idle(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_ide_idle()   ; return kind == ACXL_FLIT_ide_idle ; endfunction    "
    },
    "acxl_flit :: is_ide_tmac": {
        "prefix": [
            "is_ide_tmac",
            "function:is_ide_tmac -> acxl_flit"
        ],
        "body": [
            "is_ide_tmac(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_ide_tmac()   ; return kind == ACXL_FLIT_ide_tmac ; endfunction    "
    },
    "acxl_flit :: is_retry": {
        "prefix": [
            "is_retry",
            "function:is_retry -> acxl_flit"
        ],
        "body": [
            "is_retry(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retry();    "
    },
    "acxl_flit :: is_retryable_ctrl_flit": {
        "prefix": [
            "is_retryable_ctrl_flit",
            "function:is_retryable_ctrl_flit -> acxl_flit"
        ],
        "body": [
            "is_retryable_ctrl_flit(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retryable_ctrl_flit();    "
    },
    "acxl_flit :: is_retryable": {
        "prefix": [
            "is_retryable",
            "function:is_retryable -> acxl_flit"
        ],
        "body": [
            "is_retryable(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_retryable();    "
    },
    "acxl_flit :: is_non_retryable": {
        "prefix": [
            "is_non_retryable",
            "function:is_non_retryable -> acxl_flit"
        ],
        "body": [
            "is_non_retryable(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function bit is_non_retryable();    "
    },
    "acxl_flit :: get_full_ack": {
        "prefix": [
            "get_full_ack",
            "function:get_full_ack -> acxl_flit"
        ],
        "body": [
            "get_full_ack(${0:});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function int get_full_ack();    "
    },
    "acxl_flit :: set_full_ack": {
        "prefix": [
            "set_full_ack",
            "function:set_full_ack -> acxl_flit"
        ],
        "body": [
            "set_full_ack(${1:v});"
        ],
        "description": "[Class:acxl_flit]\n     virtual function void set_full_ack(int v);    "
    },
    "apci_flit": {
        "prefix": "apci_flit",
        "body": [
            "apci_flit  ${0:name_class};"
        ],
        "description": "class apci_flit extends apci_data_base;\n"
    },
    "apci_flit :: `avery_new_named": {
        "prefix": [
            "`avery_new_named",
            "function:`avery_new_named -> apci_flit"
        ],
        "body": [
            "`avery_new_named(${1:kind});"
        ],
        "description": "[Class:apci_flit]\n     extern function `avery_new_named(apci_flit_type kind = APCI_FLIT_unknown);    "
    },
    "apci_flit :: pre_randomize": {
        "prefix": [
            "pre_randomize",
            "function:pre_randomize -> apci_flit"
        ],
        "body": [
            "pre_randomize(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function void pre_randomize(); endfunction    "
    },
    "apci_flit :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_flit"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:apci_flit]\n     extern function apci_flit copy  (apci_flit to = null,\n int level = -1);    "
    },
    "apci_flit :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_flit"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_flit]\n     extern function string   sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_flit :: sprint_tlp_dllp": {
        "prefix": [
            "sprint_tlp_dllp",
            "function:sprint_tlp_dllp -> apci_flit"
        ],
        "body": [
            "sprint_tlp_dllp(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_flit]\n     extern function string   sprint_tlp_dllp(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_flit :: compare": {
        "prefix": [
            "compare",
            "function:compare -> apci_flit"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:apci_flit]\n     extern function bit compare(apci_flit to,\n ref string diff);    "
    },
    "apci_flit :: rehash_crc": {
        "prefix": [
            "rehash_crc",
            "function:rehash_crc -> apci_flit"
        ],
        "body": [
            "rehash_crc(${0:});"
        ],
        "description": "[Class:apci_flit]\n     extern function void rehash_crc();    "
    },
    "apci_flit :: rehash_ecc": {
        "prefix": [
            "rehash_ecc",
            "function:rehash_ecc -> apci_flit"
        ],
        "body": [
            "rehash_ecc(${0:});"
        ],
        "description": "[Class:apci_flit]\n     extern function void rehash_ecc();    "
    },
    "apci_flit :: pack_raw_bytes": {
        "prefix": [
            "pack_raw_bytes",
            "function:pack_raw_bytes -> apci_flit"
        ],
        "body": [
            "pack_raw_bytes(${0:});"
        ],
        "description": "[Class:apci_flit]\n     extern function void pack_raw_bytes();    "
    },
    "apci_flit :: wait_sent": {
        "prefix": [
            "wait_sent",
            "task:wait_sent -> apci_flit"
        ],
        "body": [
            "wait_sent(${1:entry}, ${2:timer}, ${3:msg});"
        ],
        "description": "[Class:apci_flit]\n     extern virtual task wait_sent(string entry,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_flit :: is_replayed": {
        "prefix": [
            "is_replayed",
            "function:is_replayed -> apci_flit"
        ],
        "body": [
            "is_replayed(${0:});"
        ],
        "description": "[Class:apci_flit]\n     extern function bit is_replayed();    "
    },
    "apci_flit :: has_explict_seq_num": {
        "prefix": [
            "has_explict_seq_num",
            "function:has_explict_seq_num -> apci_flit"
        ],
        "body": [
            "has_explict_seq_num(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit has_explict_seq_num(); return dllp.replay_cmd == APCI_FLIT_REPLAY_CMD_tx_seq; endfunction    "
    },
    "apci_flit :: is_ack": {
        "prefix": [
            "is_ack",
            "function:is_ack -> apci_flit"
        ],
        "body": [
            "is_ack(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_ack();      return dllp.replay_cmd == APCI_FLIT_REPLAY_CMD_ack; endfunction    "
    },
    "apci_flit :: is_nak": {
        "prefix": [
            "is_nak",
            "function:is_nak -> apci_flit"
        ],
        "body": [
            "is_nak(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_nak();      return is_std_nak() || is_sel_nak(); endfunction    "
    },
    "apci_flit :: is_std_nak": {
        "prefix": [
            "is_std_nak",
            "function:is_std_nak -> apci_flit"
        ],
        "body": [
            "is_std_nak(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_std_nak();  return dllp.replay_cmd == APCI_FLIT_REPLAY_CMD_std_nak; endfunction    "
    },
    "apci_flit :: is_sel_nak": {
        "prefix": [
            "is_sel_nak",
            "function:is_sel_nak -> apci_flit"
        ],
        "body": [
            "is_sel_nak(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_sel_nak();  return dllp.replay_cmd == APCI_FLIT_REPLAY_CMD_sel_nak; endfunction    "
    },
    "apci_flit :: is_idle": {
        "prefix": [
            "is_idle",
            "function:is_idle -> apci_flit"
        ],
        "body": [
            "is_idle(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_idle();     return kind == APCI_FLIT_idle; endfunction    "
    },
    "apci_flit :: is_nop": {
        "prefix": [
            "is_nop",
            "function:is_nop -> apci_flit"
        ],
        "body": [
            "is_nop(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_nop();      return kind == APCI_FLIT_nop; endfunction    "
    },
    "apci_flit :: is_payload": {
        "prefix": [
            "is_payload",
            "function:is_payload -> apci_flit"
        ],
        "body": [
            "is_payload(${0:});"
        ],
        "description": "[Class:apci_flit]\n     function bit is_payload();  return kind == APCI_FLIT_payload; endfunction    "
    },
    "apci_cfg_info": {
        "prefix": "apci_cfg_info",
        "body": [
            "apci_cfg_info  ${0:name_class};"
        ],
        "description": "class apci_cfg_info extends apci_data_base;\n"
    },
    "apci_cfg_info :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cfg_info"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:is_quicksim});"
        ],
        "description": "[Class:apci_cfg_info]\n     function new( string   name        = \"unamed_cfg_info\",\n                  apci_log log         = null,\n                  bit      is_quicksim = 1      );    "
    },
    "apci_cfg_info :: get_n_pf": {
        "prefix": [
            "get_n_pf",
            "function:get_n_pf -> apci_cfg_info"
        ],
        "body": [
            "get_n_pf(${1:port_id});"
        ],
        "description": "[Class:apci_cfg_info]\n     function int get_n_pf(int port_id);    "
    },
    "apci_cfg_info :: use_quicksim": {
        "prefix": [
            "use_quicksim",
            "function:use_quicksim -> apci_cfg_info"
        ],
        "body": [
            "use_quicksim(${1:scale});"
        ],
        "description": "[Class:apci_cfg_info]\n     function void use_quicksim (int scale = 0);    "
    },
    "apci_cfg_info :: use_quicksim_plus": {
        "prefix": [
            "use_quicksim_plus",
            "function:use_quicksim_plus -> apci_cfg_info"
        ],
        "body": [
            "use_quicksim_plus(${0:});"
        ],
        "description": "[Class:apci_cfg_info]\n     function void use_quicksim_plus();    "
    },
    "apci_cfg_info :: sanity_check": {
        "prefix": [
            "sanity_check",
            "function:sanity_check -> apci_cfg_info"
        ],
        "body": [
            "sanity_check(${0:});"
        ],
        "description": "[Class:apci_cfg_info]\n     function void sanity_check();    "
    },
    "apci_dllp": {
        "prefix": "apci_dllp",
        "body": [
            "apci_dllp  ${0:name_class};"
        ],
        "description": "class apci_dllp extends apci_packet;\n"
    },
    "apci_dllp :: new": {
        "prefix": [
            "new",
            "function:new -> apci_dllp"
        ],
        "body": [
            "new(${1:kind});"
        ],
        "description": "[Class:apci_dllp]\n     function new(`avery_strname  apci_dllp_type kind = APCI_DLLP_unknown);    "
    },
    "apci_dllp :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_dllp"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_dllp]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_dllp :: rehash_link_crc": {
        "prefix": [
            "rehash_link_crc",
            "function:rehash_link_crc -> apci_dllp"
        ],
        "body": [
            "rehash_link_crc(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     extern virtual function void rehash_link_crc();    "
    },
    "apci_dllp :: is_ack": {
        "prefix": [
            "is_ack",
            "function:is_ack -> apci_dllp"
        ],
        "body": [
            "is_ack(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ack();          return kind == APCI_DLLP_ack;          endfunction     "
    },
    "apci_dllp :: is_nak": {
        "prefix": [
            "is_nak",
            "function:is_nak -> apci_dllp"
        ],
        "body": [
            "is_nak(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_nak();          return kind == APCI_DLLP_nak;          endfunction     "
    },
    "apci_dllp :: is_pm_enter_l1": {
        "prefix": [
            "is_pm_enter_l1",
            "function:is_pm_enter_l1 -> apci_dllp"
        ],
        "body": [
            "is_pm_enter_l1(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_pm_enter_l1();  return kind == APCI_DLLP_pm_enter_l1;  endfunction     "
    },
    "apci_dllp :: is_pm_enter_l23": {
        "prefix": [
            "is_pm_enter_l23",
            "function:is_pm_enter_l23 -> apci_dllp"
        ],
        "body": [
            "is_pm_enter_l23(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_pm_enter_l23(); return kind == APCI_DLLP_pm_enter_l23; endfunction     "
    },
    "apci_dllp :: is_pm_as_req_l1": {
        "prefix": [
            "is_pm_as_req_l1",
            "function:is_pm_as_req_l1 -> apci_dllp"
        ],
        "body": [
            "is_pm_as_req_l1(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_pm_as_req_l1(); return kind == APCI_DLLP_pm_as_req_l1; endfunction     "
    },
    "apci_dllp :: is_pm_req_ack": {
        "prefix": [
            "is_pm_req_ack",
            "function:is_pm_req_ack -> apci_dllp"
        ],
        "body": [
            "is_pm_req_ack(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_pm_req_ack();   return kind == APCI_DLLP_pm_req_ack;   endfunction     "
    },
    "apci_dllp :: is_vendor": {
        "prefix": [
            "is_vendor",
            "function:is_vendor -> apci_dllp"
        ],
        "body": [
            "is_vendor(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_vendor();       return kind == APCI_DLLP_vendor;       endfunction     "
    },
    "apci_dllp :: is_ifc1_p": {
        "prefix": [
            "is_ifc1_p",
            "function:is_ifc1_p -> apci_dllp"
        ],
        "body": [
            "is_ifc1_p(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc1_p();       return kind == APCI_DLLP_ifc1_p;       endfunction     "
    },
    "apci_dllp :: is_ifc1_np": {
        "prefix": [
            "is_ifc1_np",
            "function:is_ifc1_np -> apci_dllp"
        ],
        "body": [
            "is_ifc1_np(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc1_np();      return kind == APCI_DLLP_ifc1_np;      endfunction     "
    },
    "apci_dllp :: is_ifc1_cpl": {
        "prefix": [
            "is_ifc1_cpl",
            "function:is_ifc1_cpl -> apci_dllp"
        ],
        "body": [
            "is_ifc1_cpl(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc1_cpl();     return kind == APCI_DLLP_ifc1_cpl;     endfunction     "
    },
    "apci_dllp :: is_ifc2_p": {
        "prefix": [
            "is_ifc2_p",
            "function:is_ifc2_p -> apci_dllp"
        ],
        "body": [
            "is_ifc2_p(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc2_p();       return kind == APCI_DLLP_ifc2_p;       endfunction     "
    },
    "apci_dllp :: is_ifc2_np": {
        "prefix": [
            "is_ifc2_np",
            "function:is_ifc2_np -> apci_dllp"
        ],
        "body": [
            "is_ifc2_np(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc2_np();      return kind == APCI_DLLP_ifc2_np;      endfunction     "
    },
    "apci_dllp :: is_ifc2_cpl": {
        "prefix": [
            "is_ifc2_cpl",
            "function:is_ifc2_cpl -> apci_dllp"
        ],
        "body": [
            "is_ifc2_cpl(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc2_cpl();     return kind == APCI_DLLP_ifc2_cpl;     endfunction     "
    },
    "apci_dllp :: is_ufc_p": {
        "prefix": [
            "is_ufc_p",
            "function:is_ufc_p -> apci_dllp"
        ],
        "body": [
            "is_ufc_p(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ufc_p();        return kind == APCI_DLLP_ufc_p;        endfunction     "
    },
    "apci_dllp :: is_ufc_np": {
        "prefix": [
            "is_ufc_np",
            "function:is_ufc_np -> apci_dllp"
        ],
        "body": [
            "is_ufc_np(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ufc_np();       return kind == APCI_DLLP_ufc_np;       endfunction     "
    },
    "apci_dllp :: is_ufc_cpl": {
        "prefix": [
            "is_ufc_cpl",
            "function:is_ufc_cpl -> apci_dllp"
        ],
        "body": [
            "is_ufc_cpl(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ufc_cpl();      return kind == APCI_DLLP_ufc_cpl;      endfunction     "
    },
    "apci_dllp :: is_fc_p": {
        "prefix": [
            "is_fc_p",
            "function:is_fc_p -> apci_dllp"
        ],
        "body": [
            "is_fc_p(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_fc_p();         return kind inside {APCI_DLLP_ifc1_p,\n APCI_DLLP_ifc2_p,\n APCI_DLLP_ufc_p}; endfunction    "
    },
    "apci_dllp :: is_fc_np": {
        "prefix": [
            "is_fc_np",
            "function:is_fc_np -> apci_dllp"
        ],
        "body": [
            "is_fc_np(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_fc_np();        return kind inside {APCI_DLLP_ifc1_np,\n APCI_DLLP_ifc2_np,\n APCI_DLLP_ufc_np}; endfunction    "
    },
    "apci_dllp :: is_fc_cpl": {
        "prefix": [
            "is_fc_cpl",
            "function:is_fc_cpl -> apci_dllp"
        ],
        "body": [
            "is_fc_cpl(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_fc_cpl();       return kind inside {APCI_DLLP_ifc1_cpl,\n APCI_DLLP_ifc2_cpl,\n APCI_DLLP_ufc_cpl}; endfunction    "
    },
    "apci_dllp :: is_dl_feature": {
        "prefix": [
            "is_dl_feature",
            "function:is_dl_feature -> apci_dllp"
        ],
        "body": [
            "is_dl_feature(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_dl_feature();   return kind == APCI_DLLP_dl_feature;   endfunction    "
    },
    "apci_dllp :: is_fc": {
        "prefix": [
            "is_fc",
            "function:is_fc -> apci_dllp"
        ],
        "body": [
            "is_fc(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_fc();     "
    },
    "apci_dllp :: is_ufc": {
        "prefix": [
            "is_ufc",
            "function:is_ufc -> apci_dllp"
        ],
        "body": [
            "is_ufc(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ufc();     "
    },
    "apci_dllp :: is_ifc1": {
        "prefix": [
            "is_ifc1",
            "function:is_ifc1 -> apci_dllp"
        ],
        "body": [
            "is_ifc1(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc1();     "
    },
    "apci_dllp :: is_ifc2": {
        "prefix": [
            "is_ifc2",
            "function:is_ifc2 -> apci_dllp"
        ],
        "body": [
            "is_ifc2(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_ifc2();     "
    },
    "apci_dllp :: is_acknak": {
        "prefix": [
            "is_acknak",
            "function:is_acknak -> apci_dllp"
        ],
        "body": [
            "is_acknak(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_acknak();     "
    },
    "apci_dllp :: is_pm": {
        "prefix": [
            "is_pm",
            "function:is_pm -> apci_dllp"
        ],
        "body": [
            "is_pm(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function bit is_pm();     "
    },
    "apci_dllp :: hdr_fc_ratio": {
        "prefix": [
            "hdr_fc_ratio",
            "function:hdr_fc_ratio -> apci_dllp"
        ],
        "body": [
            "hdr_fc_ratio(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function int hdr_fc_ratio();    "
    },
    "apci_dllp :: data_fc_ratio": {
        "prefix": [
            "data_fc_ratio",
            "function:data_fc_ratio -> apci_dllp"
        ],
        "body": [
            "data_fc_ratio(${0:});"
        ],
        "description": "[Class:apci_dllp]\n     function int data_fc_ratio();    "
    },
    "apci_dllp :: get_hdr_fc": {
        "prefix": [
            "get_hdr_fc",
            "function:get_hdr_fc -> apci_dllp"
        ],
        "body": [
            "get_hdr_fc(${1:enable_scaled_fc});"
        ],
        "description": "[Class:apci_dllp]\n     function int get_hdr_fc(bit enable_scaled_fc);    "
    },
    "apci_dllp :: get_data_fc": {
        "prefix": [
            "get_data_fc",
            "function:get_data_fc -> apci_dllp"
        ],
        "body": [
            "get_data_fc(${1:enable_scaled_fc});"
        ],
        "description": "[Class:apci_dllp]\n     function int get_data_fc(bit enable_scaled_fc);    "
    },
    "acxl_pm_msg": {
        "prefix": "acxl_pm_msg",
        "body": [
            "acxl_pm_msg  ${0:name_class};"
        ],
        "description": "class acxl_pm_msg extends apci_data_base;\n"
    },
    "acxl_pm_msg :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_pm_msg"
        ],
        "body": [
            "new(${1:name}, ${2:kind});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function new(string name=\"\",\n acxl_pm_msg_type kind = ACXL_PM_unknown);    "
    },
    "acxl_pm_msg :: to_apci_tr": {
        "prefix": [
            "to_apci_tr",
            "function:to_apci_tr -> acxl_pm_msg"
        ],
        "body": [
            "to_apci_tr(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function apci_transaction to_apci_tr();    "
    },
    "acxl_pm_msg :: from_vdm_tlp": {
        "prefix": [
            "from_vdm_tlp",
            "function:from_vdm_tlp -> acxl_pm_msg"
        ],
        "body": [
            "from_vdm_tlp(${1:tlp}, ${2:log}, ${3:err});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function void from_vdm_tlp(apci_tlp tlp,\n apci_log log,\n output bit err);    "
    },
    "acxl_pm_msg :: is_request": {
        "prefix": [
            "is_request",
            "function:is_request -> acxl_pm_msg"
        ],
        "body": [
            "is_request(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_request   (); return u.pmreq.is_req; endfunction    "
    },
    "acxl_pm_msg :: is_response": {
        "prefix": [
            "is_response",
            "function:is_response -> acxl_pm_msg"
        ],
        "body": [
            "is_response(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_response  (); return !u.pmreq.is_req; endfunction    "
    },
    "acxl_pm_msg :: is_agent_info": {
        "prefix": [
            "is_agent_info",
            "function:is_agent_info -> acxl_pm_msg"
        ],
        "body": [
            "is_agent_info(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_agent_info(); return u.pmreq.opcode == ACXL_PM_agent_info; endfunction    "
    },
    "acxl_pm_msg :: is_reset_prep": {
        "prefix": [
            "is_reset_prep",
            "function:is_reset_prep -> acxl_pm_msg"
        ],
        "body": [
            "is_reset_prep(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_reset_prep(); return u.pmreq.opcode == ACXL_PM_reset_prep; endfunction    "
    },
    "acxl_pm_msg :: is_credit_rtn": {
        "prefix": [
            "is_credit_rtn",
            "function:is_credit_rtn -> acxl_pm_msg"
        ],
        "body": [
            "is_credit_rtn(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_credit_rtn(); return u.pmreq.opcode == ACXL_PM_credit_rtn; endfunction    "
    },
    "acxl_pm_msg :: is_gpf": {
        "prefix": [
            "is_gpf",
            "function:is_gpf -> acxl_pm_msg"
        ],
        "body": [
            "is_gpf(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_gpf       (); return u.pmreq.opcode == ACXL_PM_gpf       ; endfunction    "
    },
    "acxl_pm_msg :: is_pmreq": {
        "prefix": [
            "is_pmreq",
            "function:is_pmreq -> acxl_pm_msg"
        ],
        "body": [
            "is_pmreq(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_pmreq     (); return (u.pmreq.opcode == ACXL_PM_pmreq && !u.pmreq.go &&  u.pmreq.is_req); endfunction    "
    },
    "acxl_pm_msg :: is_pmrsp": {
        "prefix": [
            "is_pmrsp",
            "function:is_pmrsp -> acxl_pm_msg"
        ],
        "body": [
            "is_pmrsp(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_pmrsp     (); return (u.pmreq.opcode == ACXL_PM_pmreq && !u.pmreq.go && !u.pmreq.is_req); endfunction    "
    },
    "acxl_pm_msg :: is_pmgo": {
        "prefix": [
            "is_pmgo",
            "function:is_pmgo -> acxl_pm_msg"
        ],
        "body": [
            "is_pmgo(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit is_pmgo      (); return (u.pmreq.opcode == ACXL_PM_pmreq &&  u.pmreq.go                   ); endfunction    "
    },
    "acxl_pm_msg :: not_use_credit": {
        "prefix": [
            "not_use_credit",
            "function:not_use_credit -> acxl_pm_msg"
        ],
        "body": [
            "not_use_credit(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit not_use_credit(); return u.pmreq.opcode inside {ACXL_PM_credit_rtn,\n ACXL_PM_gpf}; endfunction    "
    },
    "acxl_pm_msg :: require_rsp": {
        "prefix": [
            "require_rsp",
            "function:require_rsp -> acxl_pm_msg"
        ],
        "body": [
            "require_rsp(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit require_rsp(); return (is_request() && u.pmreq.opcode inside {ACXL_PM_agent_info,\n ACXL_PM_reset_prep,\n ACXL_PM_gpf}); endfunction    "
    },
    "acxl_pm_msg :: use_credit": {
        "prefix": [
            "use_credit",
            "function:use_credit -> acxl_pm_msg"
        ],
        "body": [
            "use_credit(${0:});"
        ],
        "description": "[Class:acxl_pm_msg]\n     function bit use_credit()    ; return !not_use_credit(); endfunction    "
    },
    "acxl_pm_msg :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> acxl_pm_msg"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:acxl_pm_msg]\n     extern virtual task wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "apci_doe_discovery": {
        "prefix": "apci_doe_discovery",
        "body": [
            "apci_doe_discovery  ${0:name_class};"
        ],
        "description": "class apci_doe_discovery extends apci_doe_data;\n"
    },
    "apci_doe_discovery :: new": {
        "prefix": [
            "new",
            "function:new -> apci_doe_discovery"
        ],
        "body": [
            "new(${1:name}, ${2:is_read});"
        ],
        "description": "[Class:apci_doe_discovery]\n     function new (string name=\"\",\n bit is_read = 0);    "
    },
    "apci_doe_discovery_table": {
        "prefix": "apci_doe_discovery_table",
        "body": [
            "apci_doe_discovery_table  ${0:name_class};"
        ],
        "description": "class apci_doe_discovery_table;\n"
    },
    "apci_doe_discovery_table :: get_index_by_doe": {
        "prefix": [
            "get_index_by_doe",
            "function:get_index_by_doe -> apci_doe_discovery_table"
        ],
        "body": [
            "get_index_by_doe(${1:doe});"
        ],
        "description": "[Class:apci_doe_discovery_table]\n     function int get_index_by_doe(apci_doe_data_type doe);    "
    },
    "apci_doe_discovery_table :: get_doe_by_index": {
        "prefix": [
            "get_doe_by_index",
            "function:get_doe_by_index -> apci_doe_discovery_table"
        ],
        "body": [
            "get_doe_by_index(${1:idx});"
        ],
        "description": "[Class:apci_doe_discovery_table]\n     function apci_doe_data_type get_doe_by_index(int idx);    "
    },
    "apci_doe_discovery_table :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_doe_discovery_table"
        ],
        "body": [
            "sprint(${0:});"
        ],
        "description": "[Class:apci_doe_discovery_table]\n     function string sprint();    "
    },
    "acxl_doe_cdat": {
        "prefix": "acxl_doe_cdat",
        "body": [
            "acxl_doe_cdat  ${0:name_class};"
        ],
        "description": "class acxl_doe_cdat extends apci_doe_data;\n"
    },
    "acxl_doe_cdat :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_doe_cdat"
        ],
        "body": [
            "new(${1:name}, ${2:is_read}, ${3:rsp_kind});"
        ],
        "description": "[Class:acxl_doe_cdat]\n     function new (string name=\"\",\n bit is_read = 0,\n acxl_cdat_struc_type_e rsp_kind = ACXL_CDAT_DSMAS);    "
    },
    "acxl_coh_dev_attr_table": {
        "prefix": "acxl_coh_dev_attr_table",
        "body": [
            "acxl_coh_dev_attr_table  ${0:name_class};"
        ],
        "description": "class acxl_coh_dev_attr_table extends apci_data_base;\n"
    },
    "acxl_coh_dev_attr_table :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_coh_dev_attr_table"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_coh_dev_attr_table]\n     function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_coh_dev_attr_table :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_coh_dev_attr_table"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_coh_dev_attr_table]\n     function new(string name = \"\");    "
    },
    "acxl_doe_compliance": {
        "prefix": "acxl_doe_compliance",
        "body": [
            "acxl_doe_compliance  ${0:name_class};"
        ],
        "description": "class acxl_doe_compliance extends apci_doe_data;\n"
    },
    "acxl_doe_compliance :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_doe_compliance"
        ],
        "body": [
            "new(${1:name}, ${2:is_read}, ${3:sub_kind});"
        ],
        "description": "[Class:acxl_doe_compliance]\n     function new (string name=\"\",\n bit is_read = 0,\n acxl_doe_compliance_e sub_kind = ACXL_DOE_compliance_unknown);    "
    },
    "apci_doe_data": {
        "prefix": "apci_doe_data",
        "body": [
            "apci_doe_data  ${0:name_class};"
        ],
        "description": "class apci_doe_data extends apci_data_base;\n"
    },
    "apci_doe_data :: decode_header": {
        "prefix": [
            "decode_header",
            "function:decode_header -> apci_doe_data"
        ],
        "body": [
            "decode_header(${0:});"
        ],
        "description": "[Class:apci_doe_data]\n     virtual function void decode_header();    "
    },
    "apci_doe_data :: pack": {
        "prefix": [
            "pack",
            "function:pack -> apci_doe_data"
        ],
        "body": [
            "pack(${0:});"
        ],
        "description": "[Class:apci_doe_data]\n     virtual function void pack();    "
    },
    "apci_doe_data :: unpack": {
        "prefix": [
            "unpack",
            "function:unpack -> apci_doe_data"
        ],
        "body": [
            "unpack(${1:log}, ${2:err});"
        ],
        "description": "[Class:apci_doe_data]\n     virtual function void unpack (apci_log log,\n output bit err);    "
    },
    "apci_doe_data :: get_expected_length": {
        "prefix": [
            "get_expected_length",
            "function:get_expected_length -> apci_doe_data"
        ],
        "body": [
            "get_expected_length(${0:});"
        ],
        "description": "[Class:apci_doe_data]\n     extern virtual function int get_expected_length();    "
    },
    "apci_doe_data :: new": {
        "prefix": [
            "new",
            "function:new -> apci_doe_data"
        ],
        "body": [
            "new(${1:name}, ${2:is_read}, ${3:kind});"
        ],
        "description": "[Class:apci_doe_data]\n     function new( string name = \"\",\n bit is_read = 0,\n apci_doe_data_type kind = APCI_DOE_unknown);    "
    },
    "apci_doe_data :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_doe_data"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_doe_data]\n     extern virtual function string sprint (int verbosity = 0,\n string prefix=\"\");    "
    },
    "apci_doe_data :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_doe_data"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:apci_doe_data]\n     extern function      apci_doe_data copy(apci_doe_data to = null);    "
    },
    "apci_doe_data :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> apci_doe_data"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:apci_doe_data]\n     extern task          wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "apci_doe_data :: annotate": {
        "prefix": [
            "annotate",
            "function:annotate -> apci_doe_data"
        ],
        "body": [
            "annotate(${1:s});"
        ],
        "description": "[Class:apci_doe_data]\n     extern virtual function void annotate(string s);    "
    },
    "acxl_bias_tr": {
        "prefix": "acxl_bias_tr",
        "body": [
            "acxl_bias_tr  ${0:name_class};"
        ],
        "description": "class acxl_bias_tr extends apci_data_base;\n"
    },
    "acxl_bias_tr :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_bias_tr"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_bias_tr]\n     extern function new(string name= \"\");    "
    },
    "acxl_bias_tr :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> acxl_bias_tr"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:acxl_bias_tr]\n     extern virtual task    wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "acxl_bias_tr :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_bias_tr"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_bias_tr]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_phy_datasheet": {
        "prefix": "apci_phy_datasheet",
        "body": [
            "apci_phy_datasheet  ${0:name_class};"
        ],
        "description": "class apci_phy_datasheet;\n"
    },
    "apci_phy_datasheet :: new": {
        "prefix": [
            "new",
            "function:new -> apci_phy_datasheet"
        ],
        "body": [
            "new(${0:});"
        ],
        "description": "[Class:apci_phy_datasheet]\n     function new();    "
    },
    "apci_phy_datasheet :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_phy_datasheet"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_phy_datasheet]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_al_tl_if": {
        "prefix": "apci_al_tl_if",
        "body": [
            "apci_al_tl_if  ${0:name_class};"
        ],
        "description": "class apci_al_tl_if;\n"
    },
    "apci_al_tl_if :: new": {
        "prefix": [
            "new",
            "function:new -> apci_al_tl_if"
        ],
        "body": [
            "new(${1:log});"
        ],
        "description": "[Class:apci_al_tl_if]\n     function new(apci_log log);    "
    },
    "apci_al_tl_if :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_al_tl_if"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_al_tl_if]\n     virtual function string sprint(int verbosity=0,\n string prefix=\"\");    "
    },
    "acxl_cmd_get_event_records": {
        "prefix": "acxl_cmd_get_event_records",
        "body": [
            "acxl_cmd_get_event_records  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_event_records extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_event_records :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_event_records"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_event_records]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_event_records); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_clear_event_records": {
        "prefix": "acxl_cmd_clear_event_records",
        "body": [
            "acxl_cmd_clear_event_records  ${0:name_class};"
        ],
        "description": "class acxl_cmd_clear_event_records extends acxl_device_cmd;\n"
    },
    "acxl_cmd_clear_event_records :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_clear_event_records"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_clear_event_records]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_clear_event_records); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_event_int_policy": {
        "prefix": "acxl_cmd_get_event_int_policy",
        "body": [
            "acxl_cmd_get_event_int_policy  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_event_int_policy extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_event_int_policy :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_event_int_policy"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_event_int_policy]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_event_int_policy); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_event_int_policy": {
        "prefix": "acxl_cmd_set_event_int_policy",
        "body": [
            "acxl_cmd_set_event_int_policy  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_event_int_policy extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_event_int_policy :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_event_int_policy"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_event_int_policy]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_event_int_policy); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_fw_info": {
        "prefix": "acxl_cmd_get_fw_info",
        "body": [
            "acxl_cmd_get_fw_info  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_fw_info extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_fw_info :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_fw_info"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_fw_info]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_fw_info); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_transfer_fw": {
        "prefix": "acxl_cmd_transfer_fw",
        "body": [
            "acxl_cmd_transfer_fw  ${0:name_class};"
        ],
        "description": "class acxl_cmd_transfer_fw extends acxl_device_cmd;\n"
    },
    "acxl_cmd_transfer_fw :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_transfer_fw"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_transfer_fw]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_transfer_fw); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_activate_fw": {
        "prefix": "acxl_cmd_activate_fw",
        "body": [
            "acxl_cmd_activate_fw  ${0:name_class};"
        ],
        "description": "class acxl_cmd_activate_fw extends acxl_device_cmd;\n"
    },
    "acxl_cmd_activate_fw :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_activate_fw"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_activate_fw]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_activate_fw); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_timestamp": {
        "prefix": "acxl_cmd_get_timestamp",
        "body": [
            "acxl_cmd_get_timestamp  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_timestamp extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_timestamp :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_timestamp"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_timestamp]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_timestamp); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_timestamp": {
        "prefix": "acxl_cmd_set_timestamp",
        "body": [
            "acxl_cmd_set_timestamp  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_timestamp extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_timestamp :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_timestamp"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_timestamp]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_timestamp); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_supported_logs": {
        "prefix": "acxl_cmd_get_supported_logs",
        "body": [
            "acxl_cmd_get_supported_logs  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_supported_logs extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_supported_logs :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_supported_logs"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_supported_logs]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_supported_logs); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_log": {
        "prefix": "acxl_cmd_get_log",
        "body": [
            "acxl_cmd_get_log  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_log extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_log :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_log"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_log]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_log); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_identify_mem_dev": {
        "prefix": "acxl_cmd_identify_mem_dev",
        "body": [
            "acxl_cmd_identify_mem_dev  ${0:name_class};"
        ],
        "description": "class acxl_cmd_identify_mem_dev extends acxl_device_cmd;\n"
    },
    "acxl_cmd_identify_mem_dev :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_identify_mem_dev"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_identify_mem_dev]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_identify_mem_dev); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_identify_mem_dev :: pack": {
        "prefix": [
            "pack",
            "function:pack -> acxl_cmd_identify_mem_dev"
        ],
        "body": [
            "pack(${0:});"
        ],
        "description": "[Class:acxl_cmd_identify_mem_dev]\n     virtual function void pack();    "
    },
    "acxl_cmd_identify_mem_dev :: unpack": {
        "prefix": [
            "unpack",
            "function:unpack -> acxl_cmd_identify_mem_dev"
        ],
        "body": [
            "unpack(${1:log});"
        ],
        "description": "[Class:acxl_cmd_identify_mem_dev]\n     virtual function bit unpack(apci_log log);    "
    },
    "acxl_cmd_identify_mem_dev :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_cmd_identify_mem_dev"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_cmd_identify_mem_dev]\n     virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_cmd_get_partition_info": {
        "prefix": "acxl_cmd_get_partition_info",
        "body": [
            "acxl_cmd_get_partition_info  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_partition_info extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_partition_info :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_partition_info"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_partition_info]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_partition_info); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_partition_info": {
        "prefix": "acxl_cmd_set_partition_info",
        "body": [
            "acxl_cmd_set_partition_info  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_partition_info extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_partition_info :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_partition_info"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_partition_info]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_partition_info); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_lsa": {
        "prefix": "acxl_cmd_get_lsa",
        "body": [
            "acxl_cmd_get_lsa  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_lsa extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_lsa :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_lsa"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_lsa]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_lsa); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_lsa": {
        "prefix": "acxl_cmd_set_lsa",
        "body": [
            "acxl_cmd_set_lsa  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_lsa extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_lsa :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_lsa"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_lsa]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_lsa); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_health_info": {
        "prefix": "acxl_cmd_get_health_info",
        "body": [
            "acxl_cmd_get_health_info  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_health_info extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_health_info :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_health_info"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_health_info]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_health_info); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_alert_cfg": {
        "prefix": "acxl_cmd_get_alert_cfg",
        "body": [
            "acxl_cmd_get_alert_cfg  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_alert_cfg extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_alert_cfg :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_alert_cfg"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_alert_cfg]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_alert_cfg); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_alert_cfg": {
        "prefix": "acxl_cmd_set_alert_cfg",
        "body": [
            "acxl_cmd_set_alert_cfg  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_alert_cfg extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_alert_cfg :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_alert_cfg"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_alert_cfg]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_alert_cfg); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_shutdown_state": {
        "prefix": "acxl_cmd_get_shutdown_state",
        "body": [
            "acxl_cmd_get_shutdown_state  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_shutdown_state extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_shutdown_state :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_shutdown_state"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_shutdown_state]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_shutdown_state); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_shutdown_state": {
        "prefix": "acxl_cmd_set_shutdown_state",
        "body": [
            "acxl_cmd_set_shutdown_state  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_shutdown_state extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_shutdown_state :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_shutdown_state"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_shutdown_state]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_shutdown_state); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_poison_list": {
        "prefix": "acxl_cmd_get_poison_list",
        "body": [
            "acxl_cmd_get_poison_list  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_poison_list extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_poison_list :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_poison_list"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_poison_list]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_poison_list); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_inject_poison": {
        "prefix": "acxl_cmd_inject_poison",
        "body": [
            "acxl_cmd_inject_poison  ${0:name_class};"
        ],
        "description": "class acxl_cmd_inject_poison extends acxl_device_cmd;\n"
    },
    "acxl_cmd_inject_poison :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_inject_poison"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_inject_poison]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_inject_poison); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_clear_poison": {
        "prefix": "acxl_cmd_clear_poison",
        "body": [
            "acxl_cmd_clear_poison  ${0:name_class};"
        ],
        "description": "class acxl_cmd_clear_poison extends acxl_device_cmd;\n"
    },
    "acxl_cmd_clear_poison :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_clear_poison"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_clear_poison]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_clear_poison); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_scan_media_cap": {
        "prefix": "acxl_cmd_get_scan_media_cap",
        "body": [
            "acxl_cmd_get_scan_media_cap  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_scan_media_cap extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_scan_media_cap :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_scan_media_cap"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_scan_media_cap]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_scan_media_cap); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_scan_media": {
        "prefix": "acxl_cmd_scan_media",
        "body": [
            "acxl_cmd_scan_media  ${0:name_class};"
        ],
        "description": "class acxl_cmd_scan_media extends acxl_device_cmd;\n"
    },
    "acxl_cmd_scan_media :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_scan_media"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_scan_media]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_scan_media); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_scan_media_results": {
        "prefix": "acxl_cmd_get_scan_media_results",
        "body": [
            "acxl_cmd_get_scan_media_results  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_scan_media_results extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_scan_media_results :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_scan_media_results"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_scan_media_results]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_scan_media_results); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_sanitize": {
        "prefix": "acxl_cmd_sanitize",
        "body": [
            "acxl_cmd_sanitize  ${0:name_class};"
        ],
        "description": "class acxl_cmd_sanitize extends acxl_device_cmd;\n"
    },
    "acxl_cmd_sanitize :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_sanitize"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_sanitize]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_sanitize); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_secure_erase": {
        "prefix": "acxl_cmd_secure_erase",
        "body": [
            "acxl_cmd_secure_erase  ${0:name_class};"
        ],
        "description": "class acxl_cmd_secure_erase extends acxl_device_cmd;\n"
    },
    "acxl_cmd_secure_erase :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_secure_erase"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_secure_erase]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_secure_erase); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_security_state": {
        "prefix": "acxl_cmd_get_security_state",
        "body": [
            "acxl_cmd_get_security_state  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_security_state extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_security_state :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_security_state"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_security_state]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_security_state); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_passphrase": {
        "prefix": "acxl_cmd_set_passphrase",
        "body": [
            "acxl_cmd_set_passphrase  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_passphrase extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_passphrase :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_passphrase"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_passphrase]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_passphrase); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_disable_passphrase": {
        "prefix": "acxl_cmd_disable_passphrase",
        "body": [
            "acxl_cmd_disable_passphrase  ${0:name_class};"
        ],
        "description": "class acxl_cmd_disable_passphrase extends acxl_device_cmd;\n"
    },
    "acxl_cmd_disable_passphrase :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_disable_passphrase"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_disable_passphrase]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_disable_passphrase); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_unlock": {
        "prefix": "acxl_cmd_unlock",
        "body": [
            "acxl_cmd_unlock  ${0:name_class};"
        ],
        "description": "class acxl_cmd_unlock extends acxl_device_cmd;\n"
    },
    "acxl_cmd_unlock :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_unlock"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_unlock]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_unlock); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_freeze_security_state": {
        "prefix": "acxl_cmd_freeze_security_state",
        "body": [
            "acxl_cmd_freeze_security_state  ${0:name_class};"
        ],
        "description": "class acxl_cmd_freeze_security_state extends acxl_device_cmd;\n"
    },
    "acxl_cmd_freeze_security_state :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_freeze_security_state"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_freeze_security_state]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_freeze_security_state); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_passphrase_secure_erase": {
        "prefix": "acxl_cmd_passphrase_secure_erase",
        "body": [
            "acxl_cmd_passphrase_secure_erase  ${0:name_class};"
        ],
        "description": "class acxl_cmd_passphrase_secure_erase extends acxl_device_cmd;\n"
    },
    "acxl_cmd_passphrase_secure_erase :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_passphrase_secure_erase"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_passphrase_secure_erase]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_passphrase_secure_erase); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_security_send": {
        "prefix": "acxl_cmd_security_send",
        "body": [
            "acxl_cmd_security_send  ${0:name_class};"
        ],
        "description": "class acxl_cmd_security_send extends acxl_device_cmd;\n"
    },
    "acxl_cmd_security_send :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_security_send"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_security_send]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_security_send); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_security_receive": {
        "prefix": "acxl_cmd_security_receive",
        "body": [
            "acxl_cmd_security_receive  ${0:name_class};"
        ],
        "description": "class acxl_cmd_security_receive extends acxl_device_cmd;\n"
    },
    "acxl_cmd_security_receive :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_security_receive"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_security_receive]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_security_receive); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_sld_qos_ctrl": {
        "prefix": "acxl_cmd_get_sld_qos_ctrl",
        "body": [
            "acxl_cmd_get_sld_qos_ctrl  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_sld_qos_ctrl extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_sld_qos_ctrl :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_sld_qos_ctrl"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_sld_qos_ctrl]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_sld_qos_ctrl); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_set_sld_qos_ctrl": {
        "prefix": "acxl_cmd_set_sld_qos_ctrl",
        "body": [
            "acxl_cmd_set_sld_qos_ctrl  ${0:name_class};"
        ],
        "description": "class acxl_cmd_set_sld_qos_ctrl extends acxl_device_cmd;\n"
    },
    "acxl_cmd_set_sld_qos_ctrl :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_set_sld_qos_ctrl"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_set_sld_qos_ctrl]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_set_sld_qos_ctrl); this.is_response = is_response; endfunction    "
    },
    "acxl_cmd_get_sld_qos_status": {
        "prefix": "acxl_cmd_get_sld_qos_status",
        "body": [
            "acxl_cmd_get_sld_qos_status  ${0:name_class};"
        ],
        "description": "class acxl_cmd_get_sld_qos_status extends acxl_device_cmd;\n"
    },
    "acxl_cmd_get_sld_qos_status :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cmd_get_sld_qos_status"
        ],
        "body": [
            "new(${1:name}, ${2:is_response});"
        ],
        "description": "[Class:acxl_cmd_get_sld_qos_status]\n     function new(string name=\"\",\n bit is_response=0); super.new(name,\n ACXL_DC_get_sld_qos_status); this.is_response = is_response; endfunction    "
    },
    "acxl_device_cmd": {
        "prefix": "acxl_device_cmd",
        "body": [
            "acxl_device_cmd  ${0:name_class};"
        ],
        "description": "class acxl_device_cmd extends apci_data_base;\n"
    },
    "acxl_device_cmd :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_device_cmd"
        ],
        "body": [
            "new(${1:name}, ${2:opcode});"
        ],
        "description": "[Class:acxl_device_cmd]\n     extern function new (string name=\"\",\n acxl_device_cmd_e opcode = ACXL_DC_get_log);    "
    },
    "acxl_device_cmd :: copy": {
        "prefix": [
            "copy",
            "function:copy -> acxl_device_cmd"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:acxl_device_cmd]\n     extern function acxl_device_cmd copy  (acxl_device_cmd to = null,\n int level = -1);    "
    },
    "acxl_device_cmd :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_device_cmd"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_device_cmd]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_device_cmd :: compare": {
        "prefix": [
            "compare",
            "function:compare -> acxl_device_cmd"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:acxl_device_cmd]\n     extern virtual function bit compare(acxl_device_cmd to,\n ref string diff);    "
    },
    "acxl_device_cmd :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> acxl_device_cmd"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:acxl_device_cmd]\n     extern virtual task wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "acxl_msg": {
        "prefix": "acxl_msg",
        "body": [
            "acxl_msg  ${0:name_class};"
        ],
        "description": "class acxl_msg extends apci_data_base;\n"
    },
    "acxl_msg :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_msg"
        ],
        "body": [
            "new(${1:name}, ${2:kind});"
        ],
        "description": "[Class:acxl_msg]\n     extern function new(string name= \"\",\n acxl_msg_type kind = ACXL_MSG_d2h_req);    "
    },
    "acxl_msg :: pre_randomize": {
        "prefix": [
            "pre_randomize",
            "function:pre_randomize -> acxl_msg"
        ],
        "body": [
            "pre_randomize(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function void pre_randomize(); endfunction    "
    },
    "acxl_msg :: copy": {
        "prefix": [
            "copy",
            "function:copy -> acxl_msg"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:acxl_msg]\n     extern function acxl_msg copy  (acxl_msg to = null,\n int level = -1);    "
    },
    "acxl_msg :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_msg"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_msg]\n     extern function string   sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_msg :: compare": {
        "prefix": [
            "compare",
            "function:compare -> acxl_msg"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:acxl_msg]\n     extern function bit compare(acxl_msg to,\n ref string diff);    "
    },
    "acxl_msg :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> acxl_msg"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function void post_randomize();    "
    },
    "acxl_msg :: is_d2h_req": {
        "prefix": [
            "is_d2h_req",
            "function:is_d2h_req -> acxl_msg"
        ],
        "body": [
            "is_d2h_req(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_d2h_req()    ; return kind == ACXL_MSG_d2h_req    ; endfunction    "
    },
    "acxl_msg :: is_d2h_rsp": {
        "prefix": [
            "is_d2h_rsp",
            "function:is_d2h_rsp -> acxl_msg"
        ],
        "body": [
            "is_d2h_rsp(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_d2h_rsp()    ; return kind == ACXL_MSG_d2h_rsp    ; endfunction    "
    },
    "acxl_msg :: is_d2h_data": {
        "prefix": [
            "is_d2h_data",
            "function:is_d2h_data -> acxl_msg"
        ],
        "body": [
            "is_d2h_data(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_d2h_data()   ; return kind == ACXL_MSG_d2h_data   ; endfunction    "
    },
    "acxl_msg :: is_h2d_req": {
        "prefix": [
            "is_h2d_req",
            "function:is_h2d_req -> acxl_msg"
        ],
        "body": [
            "is_h2d_req(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_h2d_req()    ; return kind == ACXL_MSG_h2d_req    ; endfunction    "
    },
    "acxl_msg :: is_h2d_rsp": {
        "prefix": [
            "is_h2d_rsp",
            "function:is_h2d_rsp -> acxl_msg"
        ],
        "body": [
            "is_h2d_rsp(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_h2d_rsp()    ; return kind == ACXL_MSG_h2d_rsp    ; endfunction    "
    },
    "acxl_msg :: is_h2d_data": {
        "prefix": [
            "is_h2d_data",
            "function:is_h2d_data -> acxl_msg"
        ],
        "body": [
            "is_h2d_data(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_h2d_data()   ; return kind == ACXL_MSG_h2d_data   ; endfunction    "
    },
    "acxl_msg :: is_m2s_req": {
        "prefix": [
            "is_m2s_req",
            "function:is_m2s_req -> acxl_msg"
        ],
        "body": [
            "is_m2s_req(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_req()    ; return kind == ACXL_MSG_m2s_req    ; endfunction    "
    },
    "acxl_msg :: is_m2s_reqdata": {
        "prefix": [
            "is_m2s_reqdata",
            "function:is_m2s_reqdata -> acxl_msg"
        ],
        "body": [
            "is_m2s_reqdata(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_reqdata(); return kind == ACXL_MSG_m2s_reqdata; endfunction    "
    },
    "acxl_msg :: is_s2m_ndr": {
        "prefix": [
            "is_s2m_ndr",
            "function:is_s2m_ndr -> acxl_msg"
        ],
        "body": [
            "is_s2m_ndr(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_s2m_ndr()    ; return kind == ACXL_MSG_s2m_ndr    ; endfunction    "
    },
    "acxl_msg :: is_s2m_drs": {
        "prefix": [
            "is_s2m_drs",
            "function:is_s2m_drs -> acxl_msg"
        ],
        "body": [
            "is_s2m_drs(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_s2m_drs()    ; return kind == ACXL_MSG_s2m_drs    ; endfunction    "
    },
    "acxl_msg :: is_d2h": {
        "prefix": [
            "is_d2h",
            "function:is_d2h -> acxl_msg"
        ],
        "body": [
            "is_d2h(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_d2h()        ; return kind inside {ACXL_MSG_d2h_req,\n ACXL_MSG_d2h_rsp,\n ACXL_MSG_d2h_data}; endfunction    "
    },
    "acxl_msg :: is_h2d": {
        "prefix": [
            "is_h2d",
            "function:is_h2d -> acxl_msg"
        ],
        "body": [
            "is_h2d(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_h2d()        ; return kind inside {ACXL_MSG_h2d_req,\n ACXL_MSG_h2d_rsp,\n ACXL_MSG_h2d_data}; endfunction    "
    },
    "acxl_msg :: is_m2s": {
        "prefix": [
            "is_m2s",
            "function:is_m2s -> acxl_msg"
        ],
        "body": [
            "is_m2s(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s()        ; return kind inside {ACXL_MSG_m2s_req,\n ACXL_MSG_m2s_reqdata}; endfunction    "
    },
    "acxl_msg :: is_s2m": {
        "prefix": [
            "is_s2m",
            "function:is_s2m -> acxl_msg"
        ],
        "body": [
            "is_s2m(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_s2m()        ; return kind inside {ACXL_MSG_s2m_ndr,\n ACXL_MSG_s2m_drs}; endfunction    "
    },
    "acxl_msg :: is_RdCurr": {
        "prefix": [
            "is_RdCurr",
            "function:is_RdCurr -> acxl_msg"
        ],
        "body": [
            "is_RdCurr(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_RdCurr()     ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_RdCurr; endfunction    "
    },
    "acxl_msg :: is_RdShared": {
        "prefix": [
            "is_RdShared",
            "function:is_RdShared -> acxl_msg"
        ],
        "body": [
            "is_RdShared(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_RdShared()   ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_RdShared; endfunction    "
    },
    "acxl_msg :: is_RdAny": {
        "prefix": [
            "is_RdAny",
            "function:is_RdAny -> acxl_msg"
        ],
        "body": [
            "is_RdAny(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_RdAny()      ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_RdAny; endfunction    "
    },
    "acxl_msg :: is_RdOwn": {
        "prefix": [
            "is_RdOwn",
            "function:is_RdOwn -> acxl_msg"
        ],
        "body": [
            "is_RdOwn(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_RdOwn()      ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_RdOwn; endfunction    "
    },
    "acxl_msg :: is_DirtyEvict": {
        "prefix": [
            "is_DirtyEvict",
            "function:is_DirtyEvict -> acxl_msg"
        ],
        "body": [
            "is_DirtyEvict(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_DirtyEvict();       return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_DirtyEvict; endfunction    "
    },
    "acxl_msg :: is_CleanEvict": {
        "prefix": [
            "is_CleanEvict",
            "function:is_CleanEvict -> acxl_msg"
        ],
        "body": [
            "is_CleanEvict(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_CleanEvict();       return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_CleanEvict; endfunction    "
    },
    "acxl_msg :: is_CleanEvictNoData": {
        "prefix": [
            "is_CleanEvictNoData",
            "function:is_CleanEvictNoData -> acxl_msg"
        ],
        "body": [
            "is_CleanEvictNoData(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_CleanEvictNoData(); return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_CleanEvictNoData; endfunction    "
    },
    "acxl_msg :: is_Evict": {
        "prefix": [
            "is_Evict",
            "function:is_Evict -> acxl_msg"
        ],
        "body": [
            "is_Evict(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_Evict()      ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode inside {ACXL_D2H_CleanEvict,\n ACXL_D2H_DirtyEvict,\n ACXL_D2H_CleanEvictNoData}; endfunction    "
    },
    "acxl_msg :: is_ItoMWr": {
        "prefix": [
            "is_ItoMWr",
            "function:is_ItoMWr -> acxl_msg"
        ],
        "body": [
            "is_ItoMWr(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_ItoMWr()     ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_ItoMWr; endfunction    "
    },
    "acxl_msg :: is_MemWr": {
        "prefix": [
            "is_MemWr",
            "function:is_MemWr -> acxl_msg"
        ],
        "body": [
            "is_MemWr(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_MemWr()      ; return kind == ACXL_MSG_d2h_req && u.d2h_req.opcode == ACXL_D2H_MemWr; endfunction    "
    },
    "acxl_msg :: is_m2s_MemRd": {
        "prefix": [
            "is_m2s_MemRd",
            "function:is_m2s_MemRd -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemRd(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemRd()    ; return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemRd; endfunction    "
    },
    "acxl_msg :: is_m2s_MemRdData": {
        "prefix": [
            "is_m2s_MemRdData",
            "function:is_m2s_MemRdData -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemRdData(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemRdData(); return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemRdData; endfunction    "
    },
    "acxl_msg :: is_m2s_MemInv": {
        "prefix": [
            "is_m2s_MemInv",
            "function:is_m2s_MemInv -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemInv(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemInv()   ; return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemInv; endfunction    "
    },
    "acxl_msg :: is_m2s_MemInvNT": {
        "prefix": [
            "is_m2s_MemInvNT",
            "function:is_m2s_MemInvNT -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemInvNT(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemInvNT() ; return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemInvNT; endfunction    "
    },
    "acxl_msg :: is_m2s_MemRdFwd": {
        "prefix": [
            "is_m2s_MemRdFwd",
            "function:is_m2s_MemRdFwd -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemRdFwd(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemRdFwd() ; return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemRdFwd; endfunction    "
    },
    "acxl_msg :: is_m2s_MemWrFwd": {
        "prefix": [
            "is_m2s_MemWrFwd",
            "function:is_m2s_MemWrFwd -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemWrFwd(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemWrFwd() ; return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemWrFwd; endfunction    "
    },
    "acxl_msg :: is_m2s_MemFwd": {
        "prefix": [
            "is_m2s_MemFwd",
            "function:is_m2s_MemFwd -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemFwd(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemFwd()   ; return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode inside {ACXL_M2S_MemWrFwd,\n ACXL_M2S_MemRdFwd}; endfunction    "
    },
    "acxl_msg :: is_m2s_MemSpecRd": {
        "prefix": [
            "is_m2s_MemSpecRd",
            "function:is_m2s_MemSpecRd -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemSpecRd(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemSpecRd(); return kind == ACXL_MSG_m2s_req && u.m2s_req.opcode == ACXL_M2S_MemSpecRd; endfunction    "
    },
    "acxl_msg :: is_m2s_MemWr": {
        "prefix": [
            "is_m2s_MemWr",
            "function:is_m2s_MemWr -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemWr(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemWr()    ; return kind == ACXL_MSG_m2s_reqdata && u.m2s_reqdata.opcode == ACXL_M2S_MemWr; endfunction    "
    },
    "acxl_msg :: is_m2s_MemWrPtl": {
        "prefix": [
            "is_m2s_MemWrPtl",
            "function:is_m2s_MemWrPtl -> acxl_msg"
        ],
        "body": [
            "is_m2s_MemWrPtl(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_m2s_MemWrPtl() ; return kind == ACXL_MSG_m2s_reqdata && u.m2s_reqdata.opcode == ACXL_M2S_MemWrPtl; endfunction    "
    },
    "acxl_msg :: is_s2m_Cmp": {
        "prefix": [
            "is_s2m_Cmp",
            "function:is_s2m_Cmp -> acxl_msg"
        ],
        "body": [
            "is_s2m_Cmp(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_s2m_Cmp() ; return kind == ACXL_MSG_s2m_ndr && u.s2m_ndr.opcode == ACXL_S2M_NDR_Cmp ; endfunction    "
    },
    "acxl_msg :: is_s2m_CmpS": {
        "prefix": [
            "is_s2m_CmpS",
            "function:is_s2m_CmpS -> acxl_msg"
        ],
        "body": [
            "is_s2m_CmpS(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_s2m_CmpS(); return kind == ACXL_MSG_s2m_ndr && u.s2m_ndr.opcode == ACXL_S2M_NDR_CmpS; endfunction    "
    },
    "acxl_msg :: is_s2m_CmpE": {
        "prefix": [
            "is_s2m_CmpE",
            "function:is_s2m_CmpE -> acxl_msg"
        ],
        "body": [
            "is_s2m_CmpE(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_s2m_CmpE(); return kind == ACXL_MSG_s2m_ndr && u.s2m_ndr.opcode == ACXL_S2M_NDR_CmpE; endfunction    "
    },
    "acxl_msg :: has_data": {
        "prefix": [
            "has_data",
            "function:has_data -> acxl_msg"
        ],
        "body": [
            "has_data(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit has_data();    "
    },
    "acxl_msg :: is_cxlCache": {
        "prefix": [
            "is_cxlCache",
            "function:is_cxlCache -> acxl_msg"
        ],
        "body": [
            "is_cxlCache(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_cxlCache()   ;    "
    },
    "acxl_msg :: is_cxlMem": {
        "prefix": [
            "is_cxlMem",
            "function:is_cxlMem -> acxl_msg"
        ],
        "body": [
            "is_cxlMem(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_cxlMem()   ;    "
    },
    "acxl_msg :: is_d2h_read": {
        "prefix": [
            "is_d2h_read",
            "function:is_d2h_read -> acxl_msg"
        ],
        "body": [
            "is_d2h_read(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_d2h_read();    "
    },
    "acxl_msg :: is_read0": {
        "prefix": [
            "is_read0",
            "function:is_read0 -> acxl_msg"
        ],
        "body": [
            "is_read0(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_read0();    "
    },
    "acxl_msg :: is_d2h_write": {
        "prefix": [
            "is_d2h_write",
            "function:is_d2h_write -> acxl_msg"
        ],
        "body": [
            "is_d2h_write(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_d2h_write();    "
    },
    "acxl_msg :: is_CacheFlushed": {
        "prefix": [
            "is_CacheFlushed",
            "function:is_CacheFlushed -> acxl_msg"
        ],
        "body": [
            "is_CacheFlushed(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_CacheFlushed();    "
    },
    "acxl_msg :: is_CLFlush": {
        "prefix": [
            "is_CLFlush",
            "function:is_CLFlush -> acxl_msg"
        ],
        "body": [
            "is_CLFlush(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_CLFlush();    "
    },
    "acxl_msg :: expect_WritePull": {
        "prefix": [
            "expect_WritePull",
            "function:expect_WritePull -> acxl_msg"
        ],
        "body": [
            "expect_WritePull(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit expect_WritePull();    "
    },
    "acxl_msg :: expect_ExtCmp": {
        "prefix": [
            "expect_ExtCmp",
            "function:expect_ExtCmp -> acxl_msg"
        ],
        "body": [
            "expect_ExtCmp(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit expect_ExtCmp();    "
    },
    "acxl_msg :: rsp_require_data": {
        "prefix": [
            "rsp_require_data",
            "function:rsp_require_data -> acxl_msg"
        ],
        "body": [
            "rsp_require_data(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit rsp_require_data();    "
    },
    "acxl_msg :: has_GO": {
        "prefix": [
            "has_GO",
            "function:has_GO -> acxl_msg"
        ],
        "body": [
            "has_GO(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit has_GO();    "
    },
    "acxl_msg :: has_Fast_GO": {
        "prefix": [
            "has_Fast_GO",
            "function:has_Fast_GO -> acxl_msg"
        ],
        "body": [
            "has_Fast_GO(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit has_Fast_GO();    "
    },
    "acxl_msg :: pull_data": {
        "prefix": [
            "pull_data",
            "function:pull_data -> acxl_msg"
        ],
        "body": [
            "pull_data(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit pull_data();    "
    },
    "acxl_msg :: pull_data_drop": {
        "prefix": [
            "pull_data_drop",
            "function:pull_data_drop -> acxl_msg"
        ],
        "body": [
            "pull_data_drop(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit pull_data_drop();    "
    },
    "acxl_msg :: can_use_memFwd": {
        "prefix": [
            "can_use_memFwd",
            "function:can_use_memFwd -> acxl_msg"
        ],
        "body": [
            "can_use_memFwd(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit can_use_memFwd();    "
    },
    "acxl_msg :: is_poisoned": {
        "prefix": [
            "is_poisoned",
            "function:is_poisoned -> acxl_msg"
        ],
        "body": [
            "is_poisoned(${0:});"
        ],
        "description": "[Class:acxl_msg]\n     function bit is_poisoned();    "
    },
    "acxl_msg :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> acxl_msg"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:acxl_msg]\n     extern virtual task wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "acxl_msg :: wait_sent": {
        "prefix": [
            "wait_sent",
            "task:wait_sent -> acxl_msg"
        ],
        "body": [
            "wait_sent(${1:entry}, ${2:timer}, ${3:msg});"
        ],
        "description": "[Class:acxl_msg]\n     extern virtual task wait_sent(string entry,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_device_base": {
        "prefix": "apci_device_base",
        "body": [
            "apci_device_base  ${0:name_class};"
        ],
        "description": "class apci_device_base extends avery_component;\n"
    },
    "apci_device_base :: post_transaction": {
        "prefix": [
            "post_transaction",
            "function:post_transaction -> apci_device_base"
        ],
        "body": [
            "post_transaction(${1:tr});"
        ],
        "description": "[Class:apci_device_base]\n     virtual function void post_transaction( apci_transaction  tr);    "
    },
    "apci_device_base :: post_tlp": {
        "prefix": [
            "post_tlp",
            "function:post_tlp -> apci_device_base"
        ],
        "body": [
            "post_tlp(${1:p});"
        ],
        "description": "[Class:apci_device_base]\n     virtual function void post_tlp( apci_tlp  p );    "
    },
    "apci_device_base :: new": {
        "prefix": [
            "new",
            "function:new -> apci_device_base"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent});"
        ],
        "description": "[Class:apci_device_base]\n     function new( string name,\n `avery_xvm_parent);    "
    },
    "apci_device_base :: build_phase": {
        "prefix": [
            "build_phase",
            "function:build_phase -> apci_device_base"
        ],
        "body": [
            "build_phase(${1:phase});"
        ],
        "description": "[Class:apci_device_base]\n     virtual function void build_phase(uvm_phase phase);    "
    },
    "apci_device_base :: run": {
        "prefix": [
            "run",
            "task:run -> apci_device_base"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:apci_device_base]\n     virtual task run();    "
    },
    "apci_device_base :: bus_enum_load_cfg": {
        "prefix": [
            "bus_enum_load_cfg",
            "function:bus_enum_load_cfg -> apci_device_base"
        ],
        "body": [
            "bus_enum_load_cfg(${1:phase}, ${2:csp}, ${3:pid}, ${4:fid});"
        ],
        "description": "[Class:apci_device_base]\n     virtual function void bus_enum_load_cfg(int phase,\n apci_cfg_space csp = null,\n int pid = 0,\n int fid = 0);    "
    },
    "apci_device_base :: bus_enum_load_db": {
        "prefix": [
            "bus_enum_load_db",
            "function:bus_enum_load_db -> apci_device_base"
        ],
        "body": [
            "bus_enum_load_db(${1:k2p});"
        ],
        "description": "[Class:apci_device_base]\n     virtual function void bus_enum_load_db(ref apci_bdf_t k2p      );    "
    },
    "apci_phy_msg_bus_cmd": {
        "prefix": "apci_phy_msg_bus_cmd",
        "body": [
            "apci_phy_msg_bus_cmd  ${0:name_class};"
        ],
        "description": "class apci_phy_msg_bus_cmd extends apci_data_base;\n"
    },
    "apci_phy_msg_bus_cmd :: new": {
        "prefix": [
            "new",
            "function:new -> apci_phy_msg_bus_cmd"
        ],
        "body": [
            "new(${1:kind});"
        ],
        "description": "[Class:apci_phy_msg_bus_cmd]\n     function new(`avery_strname apci_msg_bus_cmd_type kind = APCI_MSG_BUS_no_cmd);    "
    },
    "apci_phy_msg_bus_cmd :: is_wr": {
        "prefix": [
            "is_wr",
            "function:is_wr -> apci_phy_msg_bus_cmd"
        ],
        "body": [
            "is_wr(${0:});"
        ],
        "description": "[Class:apci_phy_msg_bus_cmd]\n     virtual function bit is_wr(); return kind inside {APCI_MSG_BUS_wr_committed,\n APCI_MSG_BUS_wr_uncommitted}; endfunction    "
    },
    "apci_phy_msg_bus_cmd :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_phy_msg_bus_cmd"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_phy_msg_bus_cmd]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_phy_msg_bus_cmd :: sprint_bytes": {
        "prefix": [
            "sprint_bytes",
            "function:sprint_bytes -> apci_phy_msg_bus_cmd"
        ],
        "body": [
            "sprint_bytes(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_phy_msg_bus_cmd]\n     extern virtual function string sprint_bytes(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_cache_callbacks": {
        "prefix": "acxl_cache_callbacks",
        "body": [
            "acxl_cache_callbacks  ${0:name_class};"
        ],
        "description": "class acxl_cache_callbacks;\n"
    },
    "acxl_cache_callbacks :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_cache_callbacks"
        ],
        "body": [
            "sprint(${1:verbosity});"
        ],
        "description": "[Class:acxl_cache_callbacks]\n     virtual function string sprint(int verbosity = 0);    "
    },
    "acxl_cacheline": {
        "prefix": "acxl_cacheline",
        "body": [
            "acxl_cacheline  ${0:name_class};"
        ],
        "description": "    The class for describing CXL Cachelines */\n    \nclass acxl_cacheline;\n"
    },
    "acxl_cacheline :: is_invalid": {
        "prefix": [
            "is_invalid",
            "function:is_invalid -> acxl_cacheline"
        ],
        "body": [
            "is_invalid(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_invalid()  ; return state inside {ACXL_CL_STATE_I}                                       ; endfunction    "
    },
    "acxl_cacheline :: is_shared": {
        "prefix": [
            "is_shared",
            "function:is_shared -> acxl_cacheline"
        ],
        "body": [
            "is_shared(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_shared()   ; return state inside {ACXL_CL_STATE_SC,\n ACXL_CL_STATE_SD}                    ; endfunction    "
    },
    "acxl_cacheline :: is_exclusive": {
        "prefix": [
            "is_exclusive",
            "function:is_exclusive -> acxl_cacheline"
        ],
        "body": [
            "is_exclusive(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_exclusive(); return state inside {ACXL_CL_STATE_UC,\n ACXL_CL_STATE_UCE,\n ACXL_CL_STATE_UD} ; endfunction    "
    },
    "acxl_cacheline :: is_modified": {
        "prefix": [
            "is_modified",
            "function:is_modified -> acxl_cacheline"
        ],
        "body": [
            "is_modified(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_modified() ; return state inside {ACXL_CL_STATE_SD,\n ACXL_CL_STATE_UD}                    ; endfunction    "
    },
    "acxl_cacheline :: is_clean": {
        "prefix": [
            "is_clean",
            "function:is_clean -> acxl_cacheline"
        ],
        "body": [
            "is_clean(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_clean()    ; return state inside {ACXL_CL_STATE_UC,\n ACXL_CL_STATE_UCE,\n ACXL_CL_STATE_SC} ; endfunction    "
    },
    "acxl_cacheline :: is_UC": {
        "prefix": [
            "is_UC",
            "function:is_UC -> acxl_cacheline"
        ],
        "body": [
            "is_UC(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_UC()       ; return state inside {ACXL_CL_STATE_UC,\n ACXL_CL_STATE_UCE}                   ; endfunction    "
    },
    "acxl_cacheline :: is_SC": {
        "prefix": [
            "is_SC",
            "function:is_SC -> acxl_cacheline"
        ],
        "body": [
            "is_SC(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     function bit is_SC()       ; return state inside {ACXL_CL_STATE_SC}; endfunction    "
    },
    "acxl_cacheline :: is_full_line": {
        "prefix": [
            "is_full_line",
            "function:is_full_line -> acxl_cacheline"
        ],
        "body": [
            "is_full_line(${0:});"
        ],
        "description": "[Class:acxl_cacheline]\n     virtual function bit is_full_line();    "
    },
    "acxl_cache": {
        "prefix": "acxl_cache",
        "body": [
            "acxl_cache  ${0:name_class};"
        ],
        "description": "class acxl_cache;\n"
    },
    "acxl_cache :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_cache"
        ],
        "body": [
            "new(${1:name}, ${2:agent});"
        ],
        "description": "[Class:acxl_cache]\n     extern function new(string name = \"acxl_cache\",\n acxl_requester agent);    "
    },
    "acxl_cache :: get_any_dirty_line": {
        "prefix": [
            "get_any_dirty_line",
            "function:get_any_dirty_line -> acxl_cache"
        ],
        "body": [
            "get_any_dirty_line(${0:});"
        ],
        "description": "[Class:acxl_cache]\n     extern virtual function acxl_cacheline get_any_dirty_line();    "
    },
    "acxl_cache :: evict_line": {
        "prefix": [
            "evict_line",
            "function:evict_line -> acxl_cache"
        ],
        "body": [
            "evict_line(${1:line}, ${2:dbg});"
        ],
        "description": "[Class:acxl_cache]\n     extern virtual function void evict_line(acxl_cacheline line,\n acxl_msg dbg=null);    "
    },
    "acxl_cache :: flush": {
        "prefix": [
            "flush",
            "function:flush -> acxl_cache"
        ],
        "body": [
            "flush(${1:dbg});"
        ],
        "description": "[Class:acxl_cache]\n     extern virtual function void flush(acxl_msg dbg=null);    "
    },
    "acxl_cache :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_cache"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_cache]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix=\"\");    "
    },
    "apci_genz_pkt": {
        "prefix": "apci_genz_pkt",
        "body": [
            "apci_genz_pkt  ${0:name_class};"
        ],
        "description": "class apci_genz_pkt extends apci_tlp;\n"
    },
    "acxl_fm_cmd": {
        "prefix": "acxl_fm_cmd",
        "body": [
            "acxl_fm_cmd  ${0:name_class};"
        ],
        "description": "class acxl_fm_cmd extends apci_data_base;\n"
    },
    "acxl_fm_cmd :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_fm_cmd"
        ],
        "body": [
            "new(${1:name}, ${2:category}, ${3:opcode});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     extern function new(        string            name=    \"\",\n        acxl_fm_cmd_cat_e category = ACXL_FM_CMD_CAT_req,\n        acxl_fm_cmd_e     opcode   = ACXL_FM_event_notif );    "
    },
    "acxl_fm_cmd :: pre_randomize": {
        "prefix": [
            "pre_randomize",
            "function:pre_randomize -> acxl_fm_cmd"
        ],
        "body": [
            "pre_randomize(${0:});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function void pre_randomize(); endfunction    "
    },
    "acxl_fm_cmd :: copy": {
        "prefix": [
            "copy",
            "function:copy -> acxl_fm_cmd"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     extern function acxl_fm_cmd copy  (acxl_fm_cmd to = null,\n int level = -1);    "
    },
    "acxl_fm_cmd :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_fm_cmd"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     extern function string   sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_fm_cmd :: compare": {
        "prefix": [
            "compare",
            "function:compare -> acxl_fm_cmd"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     extern function bit compare(acxl_fm_cmd to,\n ref string diff);    "
    },
    "acxl_fm_cmd :: post_randomize": {
        "prefix": [
            "post_randomize",
            "function:post_randomize -> acxl_fm_cmd"
        ],
        "body": [
            "post_randomize(${0:});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function void post_randomize();    "
    },
    "acxl_fm_cmd :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> acxl_fm_cmd"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     extern virtual task wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "acxl_fm_cmd :: is_request": {
        "prefix": [
            "is_request",
            "function:is_request -> acxl_fm_cmd"
        ],
        "body": [
            "is_request(${0:});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function bit is_request()    ; return category == ACXL_FM_CMD_CAT_req        ; endfunction    "
    },
    "acxl_fm_cmd :: is_response": {
        "prefix": [
            "is_response",
            "function:is_response -> acxl_fm_cmd"
        ],
        "body": [
            "is_response(${0:});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function bit is_response()   ; return category == ACXL_FM_CMD_CAT_rsp        ; endfunction    "
    },
    "acxl_fm_cmd :: is_event_notif": {
        "prefix": [
            "is_event_notif",
            "function:is_event_notif -> acxl_fm_cmd"
        ],
        "body": [
            "is_event_notif(${0:});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function bit is_event_notif(); return category == ACXL_FM_CMD_CAT_event_notif; endfunction    "
    },
    "acxl_fm_cmd :: setup_bind_vppb": {
        "prefix": [
            "setup_bind_vppb",
            "function:setup_bind_vppb -> acxl_fm_cmd"
        ],
        "body": [
            "setup_bind_vppb(${1:vcs_id}, ${2:vppb_id}, ${3:ppb_id}, ${4:ld_id});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function void setup_bind_vppb(int vcs_id,\n int vppb_id,\n int ppb_id,\n int ld_id=0);    "
    },
    "acxl_fm_cmd :: tunnel_cmd": {
        "prefix": [
            "tunnel_cmd",
            "function:tunnel_cmd -> acxl_fm_cmd"
        ],
        "body": [
            "tunnel_cmd(${1:ppb_id}, ${2:kid});"
        ],
        "description": "[Class:acxl_fm_cmd]\n     function void tunnel_cmd (int ppb_id,\n acxl_fm_cmd kid);    "
    },
    "acxl_fm_enum_vcs": {
        "prefix": "acxl_fm_enum_vcs",
        "body": [
            "acxl_fm_enum_vcs  ${0:name_class};"
        ],
        "description": "class acxl_fm_enum_vcs;\n"
    },
    "acxl_fm_enum_vcs :: unpack": {
        "prefix": [
            "unpack",
            "function:unpack -> acxl_fm_enum_vcs"
        ],
        "body": [
            "unpack(${1:m}, ${2:log}, ${3:bq});"
        ],
        "description": "[Class:acxl_fm_enum_vcs]\n     function bit unpack(acxl_fm_cmd m,\n apci_log log,\n ref bit       bq      );    "
    },
    "acxl_fm_enum_vcs :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_fm_enum_vcs"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_fm_enum_vcs]\n     function string sprint(int verbosity = 0,\n string prefix=\"\");    "
    },
    "acxl_fm_enum_ep": {
        "prefix": "acxl_fm_enum_ep",
        "body": [
            "acxl_fm_enum_ep  ${0:name_class};"
        ],
        "description": "class acxl_fm_enum_ep;\n"
    },
    "acxl_fm_enum_ep :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_fm_enum_ep"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_fm_enum_ep]\n     function string sprint(int verbosity = 0,\n string prefix=\"\");    "
    },
    "acxl_fm_enum_sw": {
        "prefix": "acxl_fm_enum_sw",
        "body": [
            "acxl_fm_enum_sw  ${0:name_class};"
        ],
        "description": "class acxl_fm_enum_sw extends apci_data_base;\n"
    },
    "acxl_fm_enum_sw :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_fm_enum_sw"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_fm_enum_sw]\n     function new(string name = \"acxl_fm_enum_sw\");    "
    },
    "acxl_fm_enum_sw :: find_unbinded_ld": {
        "prefix": [
            "find_unbinded_ld",
            "function:find_unbinded_ld -> acxl_fm_enum_sw"
        ],
        "body": [
            "find_unbinded_ld(${1:ep}, ${2:ld});"
        ],
        "description": "[Class:acxl_fm_enum_sw]\n     function void find_unbinded_ld(output acxl_fm_enum_ep ep,\n output int ld);    "
    },
    "acxl_fm_enum_sw :: set_binded": {
        "prefix": [
            "set_binded",
            "function:set_binded -> acxl_fm_enum_sw"
        ],
        "body": [
            "set_binded(${1:ep}, ${2:ld});"
        ],
        "description": "[Class:acxl_fm_enum_sw]\n     function void set_binded(acxl_fm_enum_ep ep,\n int ld);    "
    },
    "acxl_fm_enum_sw :: clear_binded": {
        "prefix": [
            "clear_binded",
            "function:clear_binded -> acxl_fm_enum_sw"
        ],
        "body": [
            "clear_binded(${1:ep}, ${2:ld});"
        ],
        "description": "[Class:acxl_fm_enum_sw]\n     function void clear_binded(acxl_fm_enum_ep ep,\n int ld);    "
    },
    "acxl_fm_enum_mgr": {
        "prefix": "acxl_fm_enum_mgr",
        "body": [
            "acxl_fm_enum_mgr  ${0:name_class};"
        ],
        "description": "class acxl_fm_enum_mgr extends apci_data_base;\n"
    },
    "acxl_fm_enum_mgr :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_fm_enum_mgr"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:acxl_fm_enum_mgr]\n     function new(string name = \"acxl_fm_enum_mgr\");    "
    },
    "apci_transaction": {
        "prefix": "apci_transaction",
        "body": [
            "apci_transaction  ${0:name_class};"
        ],
        "description": "class apci_transaction extends apci_data_base;\n"
    },
    "apci_transaction :: new": {
        "prefix": [
            "new",
            "function:new -> apci_transaction"
        ],
        "body": [
            "new(${1:kind}, ${2:is_write}, ${3:addr}, ${4:length});"
        ],
        "description": "[Class:apci_transaction]\n     function new( `avery_strname    apci_trans_type kind     = APCI_TRANS_mem,\n                  bit             is_write = 0,\n                  bit             addr     = 0,\n                  bit             length   = 0 );    "
    },
    "apci_transaction :: get_be": {
        "prefix": [
            "get_be",
            "function:get_be -> apci_transaction"
        ],
        "body": [
            "get_be(${1:dw_index});"
        ],
        "description": "[Class:apci_transaction]\n     function bit       get_be(int dw_index);    "
    },
    "apci_transaction :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_transaction"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_transaction]\n     extern virtual function string sprint (int verbosity = 0,\n string prefix=\"\");    "
    },
    "apci_transaction :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_transaction"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:apci_transaction]\n     extern function      apci_transaction copy(apci_transaction to = null);    "
    },
    "apci_transaction :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> apci_transaction"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:apci_transaction]\n     extern task          wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "apci_transaction :: wait_issued": {
        "prefix": [
            "wait_issued",
            "task:wait_issued -> apci_transaction"
        ],
        "body": [
            "wait_issued(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:apci_transaction]\n     extern task          wait_issued(time timer = 0,\n string msg = \"\");    "
    },
    "apci_transaction :: wait_enter_vc": {
        "prefix": [
            "wait_enter_vc",
            "task:wait_enter_vc -> apci_transaction"
        ],
        "body": [
            "wait_enter_vc(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:apci_transaction]\n     extern task          wait_enter_vc(time timer = 0,\n string msg = \"\");    "
    },
    "apci_transaction :: get_byte_addr": {
        "prefix": [
            "get_byte_addr",
            "function:get_byte_addr -> apci_transaction"
        ],
        "body": [
            "get_byte_addr(${0:});"
        ],
        "description": "[Class:apci_transaction]\n     extern function bit       get_byte_addr();    "
    },
    "apci_transaction :: get_func_num": {
        "prefix": [
            "get_func_num",
            "function:get_func_num -> apci_transaction"
        ],
        "body": [
            "get_func_num(${1:is_ari});"
        ],
        "description": "[Class:apci_transaction]\n     function bit       get_func_num(bit is_ari);    "
    },
    "apci_transaction :: get_dev_func_num": {
        "prefix": [
            "get_dev_func_num",
            "function:get_dev_func_num -> apci_transaction"
        ],
        "body": [
            "get_dev_func_num(${0:});"
        ],
        "description": "[Class:apci_transaction]\n     function bit       get_dev_func_num();    "
    },
    "apci_transaction :: annotate": {
        "prefix": [
            "annotate",
            "function:annotate -> apci_transaction"
        ],
        "body": [
            "annotate(${1:s});"
        ],
        "description": "[Class:apci_transaction]\n     extern virtual function void annotate(string s);    "
    },
    "apci_transaction :: get_addr": {
        "prefix": [
            "get_addr",
            "function:get_addr -> apci_transaction"
        ],
        "body": [
            "get_addr(${0:});"
        ],
        "description": "[Class:apci_transaction]\n     virtual function bit       get_addr();    "
    },
    "apci_transaction :: get_payload_dw": {
        "prefix": [
            "get_payload_dw",
            "function:get_payload_dw -> apci_transaction"
        ],
        "body": [
            "get_payload_dw(${1:dw_index});"
        ],
        "description": "[Class:apci_transaction]\n     function bit       get_payload_dw(int dw_index);    "
    },
    "apci_device_mgr": {
        "prefix": "apci_device_mgr",
        "body": [
            "apci_device_mgr  ${0:name_class};"
        ],
        "description": "class apci_device_mgr extends apci_data_base;\n"
    },
    "apci_device_mgr :: `avery_new_named": {
        "prefix": [
            "`avery_new_named",
            "function:`avery_new_named -> apci_device_mgr"
        ],
        "body": [
            "`avery_new_named(${1:bus_num});"
        ],
        "description": "[Class:apci_device_mgr]\n     extern function `avery_new_named(apci_bdf_t bus_num = 0);    "
    },
    "apci_device_mgr :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_device_mgr"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:apci_device_mgr]\n     extern function apci_device_mgr copy(apci_device_mgr to = null);    "
    },
    "apci_device_mgr :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_device_mgr"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_device_mgr]\n     extern function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_device_mgr :: wait_configured": {
        "prefix": [
            "wait_configured",
            "task:wait_configured -> apci_device_mgr"
        ],
        "body": [
            "wait_configured(${1:timer});"
        ],
        "description": "[Class:apci_device_mgr]\n     extern virtual task wait_configured(time timer = 0);    "
    },
    "apci_device_mgr :: is_ep": {
        "prefix": [
            "is_ep",
            "function:is_ep -> apci_device_mgr"
        ],
        "body": [
            "is_ep(${0:});"
        ],
        "description": "[Class:apci_device_mgr]\n     function bit is_ep(); return dev_type inside {APCI_DEVICE_ep,\n APCI_DEVICE_legacy_ep,\n APCI_PORT_rc_ie}; endfunction     "
    },
    "apci_device_mgr :: is_rc": {
        "prefix": [
            "is_rc",
            "function:is_rc -> apci_device_mgr"
        ],
        "body": [
            "is_rc(${0:});"
        ],
        "description": "[Class:apci_device_mgr]\n     function bit is_rc(); return dev_type == APCI_DEVICE_rc;                              endfunction     "
    },
    "apci_device_mgr :: is_sw": {
        "prefix": [
            "is_sw",
            "function:is_sw -> apci_device_mgr"
        ],
        "body": [
            "is_sw(${0:});"
        ],
        "description": "[Class:apci_device_mgr]\n     function bit is_sw(); return dev_type == APCI_DEVICE_sw;                              endfunction     "
    },
    "apci_device_mgr :: is_rciep": {
        "prefix": [
            "is_rciep",
            "function:is_rciep -> apci_device_mgr"
        ],
        "body": [
            "is_rciep(${0:});"
        ],
        "description": "[Class:apci_device_mgr]\n     function bit is_rciep();    "
    },
    "apci_eds_pkt": {
        "prefix": "apci_eds_pkt",
        "body": [
            "apci_eds_pkt  ${0:name_class};"
        ],
        "description": "class apci_eds_pkt extends apci_packet;\n"
    },
    "apci_eds_pkt :: new": {
        "prefix": [
            "new",
            "function:new -> apci_eds_pkt"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_eds_pkt]\n     extern function new(string name = \"apci_eds_pkt\");    "
    },
    "apci_eds_pkt :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_eds_pkt"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:apci_eds_pkt]\n     extern function apci_eds_pkt copy(apci_eds_pkt to = null);    "
    },
    "apci_eds_pkt :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_eds_pkt"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_eds_pkt]\n     extern function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_margin_param": {
        "prefix": "apci_margin_param",
        "body": [
            "apci_margin_param  ${0:name_class};"
        ],
        "description": "class apci_margin_param;\n"
    },
    "apci_margin_param :: is_margin_timing": {
        "prefix": [
            "is_margin_timing",
            "function:is_margin_timing -> apci_margin_param"
        ],
        "body": [
            "is_margin_timing(${0:});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function bit is_margin_timing (); return margin_condition inside {APCI_margin_timing_right,\n APCI_margin_timing_left }; endfunction    "
    },
    "apci_margin_param :: is_margin_voltage": {
        "prefix": [
            "is_margin_voltage",
            "function:is_margin_voltage -> apci_margin_param"
        ],
        "body": [
            "is_margin_voltage(${0:});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function bit is_margin_voltage(); return margin_condition inside {APCI_margin_voltage_up  ,\n APCI_margin_voltage_down}; endfunction    "
    },
    "apci_margin_param :: is_right_down": {
        "prefix": [
            "is_right_down",
            "function:is_right_down -> apci_margin_param"
        ],
        "body": [
            "is_right_down(${0:});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function bit is_right_down    (); return margin_condition inside {APCI_margin_timing_right,\n APCI_margin_voltage_down}; endfunction    "
    },
    "apci_margin_param :: is_left_up": {
        "prefix": [
            "is_left_up",
            "function:is_left_up -> apci_margin_param"
        ],
        "body": [
            "is_left_up(${0:});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function bit is_left_up       (); return !(is_right_down());                                                           endfunction    "
    },
    "apci_margin_param :: new": {
        "prefix": [
            "new",
            "function:new -> apci_margin_param"
        ],
        "body": [
            "new(${1:lane_no});"
        ],
        "description": "[Class:apci_margin_param]\n     function new(int lane_no = 0);    "
    },
    "apci_margin_param :: decode": {
        "prefix": [
            "decode",
            "function:decode -> apci_margin_param"
        ],
        "body": [
            "decode(${1:kind}, ${2:v}, ${3:log});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function void decode(apci_margin_type kind,\n bit       v,\n apci_log log);    "
    },
    "apci_margin_param :: encode_marginCtrlCapbilities": {
        "prefix": [
            "encode_marginCtrlCapbilities",
            "function:encode_marginCtrlCapbilities -> apci_margin_param"
        ],
        "body": [
            "encode_marginCtrlCapbilities(${0:});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function bit       encode_marginCtrlCapbilities();    "
    },
    "apci_margin_param :: check": {
        "prefix": [
            "check",
            "function:check -> apci_margin_param"
        ],
        "body": [
            "check(${1:log});"
        ],
        "description": "[Class:apci_margin_param]\n     virtual function bit check(apci_log log);    "
    },
    "apci_margin_param :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_margin_param"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_margin_param]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_cfg_info": {
        "prefix": "acxl_cfg_info",
        "body": [
            "acxl_cfg_info  ${0:name_class};"
        ],
        "description": "class acxl_cfg_info extends acxl_data_base;\n"
    },
    "apci_pif_wrapper": {
        "prefix": "apci_pif_wrapper",
        "body": [
            "apci_pif_wrapper  ${0:name_class};"
        ],
        "description": "class apci_pif_wrapper;\n"
    },
    "apci_pif_wrapper :: new": {
        "prefix": [
            "new",
            "function:new -> apci_pif_wrapper"
        ],
        "body": [
            "new(${1:pipe_ifs});"
        ],
        "description": "[Class:apci_pif_wrapper]\n     function new(virtual apci_pipe_intf pipe_ifs       = '{});    "
    },
    "apci_device": {
        "prefix": "apci_device",
        "body": [
            "apci_device  ${0:name_class};"
        ],
        "description": "class apci_device extends apci_device_base;\n"
    },
    "apci_device :: new": {
        "prefix": [
            "new",
            "function:new -> apci_device"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent}, ${3:dev_type}, ${4:n_ports});"
        ],
        "description": "[Class:apci_device]\n extern function new(       string name,\n       `avery_xvm_parent,\napci_device_type dev_type = APCI_DEVICE_unknown,\nint              n_ports  = 1);    "
    },
    "apci_device :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_device"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_device]\n extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_device :: build_phase": {
        "prefix": [
            "build_phase",
            "function:build_phase -> apci_device"
        ],
        "body": [
            "build_phase(${1:phase});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void build_phase(uvm_phase phase);    "
    },
    "apci_device :: connect_phase": {
        "prefix": [
            "connect_phase",
            "function:connect_phase -> apci_device"
        ],
        "body": [
            "connect_phase(${1:phase});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void connect_phase(uvm_phase phase);    "
    },
    "apci_device :: assign_vi": {
        "prefix": [
            "assign_vi",
            "function:assign_vi -> apci_device"
        ],
        "body": [
            "assign_vi(${1:port_id}, ${2:pipe_ifs}, ${3:pipe_ifs_start}, ${4:pipe_ifs_end});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void assign_vi (        int     port_id       ,\n        virtual apci_pipe_intf pipe_ifs      ,\n        int     pipe_ifs_start = 0,\n        int     pipe_ifs_end   = -1);    "
    },
    "apci_device :: configure": {
        "prefix": [
            "configure",
            "function:configure -> apci_device"
        ],
        "body": [
            "configure(${1:dev_type}, ${2:n_ports});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void configure(apci_device_type dev_type,\n int n_ports = -1);    "
    },
    "apci_device :: set": {
        "prefix": [
            "set",
            "function:set -> apci_device"
        ],
        "body": [
            "set(${1:entry}, ${2:value}, ${3:sub_entry});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void set(input string    entry,\ninput bit       value = 0,\ninput string    sub_entry = \"\");    "
    },
    "apci_device :: get": {
        "prefix": [
            "get",
            "function:get -> apci_device"
        ],
        "body": [
            "get(${1:entry}, ${2:sub_entry});"
        ],
        "description": "[Class:apci_device]\n extern virtual function bit       get(input string entry,\ninput string sub_entry = \"\");    "
    },
    "apci_device :: get_func_info": {
        "prefix": [
            "get_func_info",
            "function:get_func_info -> apci_device"
        ],
        "body": [
            "get_func_info(${1:bdf});"
        ],
        "description": "[Class:apci_device]\n extern virtual function apci_func_info get_func_info(apci_bdf_t bdf);    "
    },
    "apci_device :: bus_enum": {
        "prefix": [
            "bus_enum",
            "task:bus_enum -> apci_device"
        ],
        "body": [
            "bus_enum(${1:err});"
        ],
        "description": "[Class:apci_device]\n extern virtual task bus_enum(output bit err);    "
    },
    "apci_device :: bus_enum_revive": {
        "prefix": [
            "bus_enum_revive",
            "task:bus_enum_revive -> apci_device"
        ],
        "body": [
            "bus_enum_revive(${1:bdf}, ${2:err});"
        ],
        "description": "[Class:apci_device]\n extern virtual task bus_enum_revive(int bdf,\n output bit err);    "
    },
    "apci_device :: get_mem_ranges": {
        "prefix": [
            "get_mem_ranges",
            "function:get_mem_ranges -> apci_device"
        ],
        "body": [
            "get_mem_ranges(${1:ranges}, ${2:expansion_rom});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void get_mem_ranges(ref  apci_bar_t ranges      ,\n input bit expansion_rom = 1);    "
    },
    "apci_device :: get_host_mem_ranges": {
        "prefix": [
            "get_host_mem_ranges",
            "function:get_host_mem_ranges -> apci_device"
        ],
        "body": [
            "get_host_mem_ranges(${1:ranges});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void get_host_mem_ranges(ref  apci_addr_range_t ranges      );    "
    },
    "apci_device :: get_cxl_hdm_ranges": {
        "prefix": [
            "get_cxl_hdm_ranges",
            "function:get_cxl_hdm_ranges -> apci_device"
        ],
        "body": [
            "get_cxl_hdm_ranges(${1:ranges});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void get_cxl_hdm_ranges(ref  apci_addr_range_t ranges      );    "
    },
    "apci_device :: get_mem_model": {
        "prefix": [
            "get_mem_model",
            "function:get_mem_model -> apci_device"
        ],
        "body": [
            "get_mem_model(${1:addr}, ${2:n_dwords}, ${3:io_space});"
        ],
        "description": "[Class:apci_device]\n extern virtual function apci_mem_model get_mem_model(bit       addr,\n bit       n_dwords,\n bit io_space = 0);    "
    },
    "apci_device :: set_mem_dwords": {
        "prefix": [
            "set_mem_dwords",
            "function:set_mem_dwords -> apci_device"
        ],
        "body": [
            "set_mem_dwords(${1:addr}, ${2:va}, ${3:dbg}, ${4:writer}, ${5:first_be}, ${6:last_be});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void set_mem_dwords(input bit             addr,\nref   bit             va      ,\ninput string          dbg = \"\",\ninput avery_data_base writer = null,\ninput bit              first_be = 'hf,\n input bit              last_be  = 'hf    );    "
    },
    "apci_device :: get_mem_dwords": {
        "prefix": [
            "get_mem_dwords",
            "function:get_mem_dwords -> apci_device"
        ],
        "body": [
            "get_mem_dwords(${1:addr}, ${2:num_dw}, ${3:va});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void get_mem_dwords(input bit             addr,\ninput bit             num_dw,\nref   bit             va      );    "
    },
    "apci_device :: set_io_dwords": {
        "prefix": [
            "set_io_dwords",
            "function:set_io_dwords -> apci_device"
        ],
        "body": [
            "set_io_dwords(${1:addr}, ${2:va}, ${3:dbg}, ${4:writer});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void set_io_dwords(input bit             addr,\nref   bit             va      ,\ninput string          dbg = \"\",\ninput avery_data_base writer = null    );    "
    },
    "apci_device :: get_io_dwords": {
        "prefix": [
            "get_io_dwords",
            "function:get_io_dwords -> apci_device"
        ],
        "body": [
            "get_io_dwords(${1:addr}, ${2:num_dw}, ${3:va});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void get_io_dwords(input bit             addr,\ninput bit             num_dw,\nref   bit             va      );    "
    },
    "apci_device :: port_get_cfg_space": {
        "prefix": [
            "port_get_cfg_space",
            "function:port_get_cfg_space -> apci_device"
        ],
        "body": [
            "port_get_cfg_space(${1:port_id}, ${2:csps});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_get_cfg_space(input int            port_id = -1,\n       ref   apci_cfg_space csps      );    "
    },
    "apci_device :: alloc_vf_if_needed": {
        "prefix": [
            "alloc_vf_if_needed",
            "function:alloc_vf_if_needed -> apci_device"
        ],
        "body": [
            "alloc_vf_if_needed(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void alloc_vf_if_needed();    "
    },
    "apci_device :: post_m2p_cmd": {
        "prefix": [
            "post_m2p_cmd",
            "function:post_m2p_cmd -> apci_device"
        ],
        "body": [
            "post_m2p_cmd(${1:port_id}, ${2:lane_no}, ${3:entry}, ${4:address}, ${5:msg_data});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void post_m2p_cmd(input int       port_id,\ninput int lane_no,\ninput string entry,\ninput bit       address,\ninput bit        msg_data);    "
    },
    "apci_device :: port_set": {
        "prefix": [
            "port_set",
            "function:port_set -> apci_device"
        ],
        "body": [
            "port_set(${1:port_id}, ${2:entry}, ${3:value}, ${4:aux_value});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_set(input int       port_id,\ninput string    entry,\ninput longint   value     = -1,\ninput longint   aux_value = -1);    "
    },
    "apci_device :: port_set_lane": {
        "prefix": [
            "port_set_lane",
            "function:port_set_lane -> apci_device"
        ],
        "body": [
            "port_set_lane(${1:port_id}, ${2:lane_no}, ${3:entry}, ${4:value});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_set_lane(input int       port_id,\ninput int       lane_no,\ninput string    entry,\ninput longint   value = -1);    "
    },
    "apci_device :: port_set_tracker": {
        "prefix": [
            "port_set_tracker",
            "function:port_set_tracker -> apci_device"
        ],
        "body": [
            "port_set_tracker(${1:port_id}, ${2:entry}, ${3:enable}, ${4:file_name}, ${5:file_handle});"
        ],
        "description": "[Class:apci_device]\n extern function void port_set_tracker(input int     port_id,\ninput string  entry,\n  input bit     enable,\ninput string  file_name = \"\",\ninput int     file_handle = 0);    "
    },
    "apci_device :: port_set_obj": {
        "prefix": [
            "port_set_obj",
            "function:port_set_obj -> apci_device"
        ],
        "body": [
            "port_set_obj(${1:port_id}, ${2:entry}, ${3:obj});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_set_obj(input int       port_id,\ninput string    entry,\ninput avery_data_base obj);    "
    },
    "apci_device :: port_set_mm_handler": {
        "prefix": [
            "port_set_mm_handler",
            "function:port_set_mm_handler -> apci_device"
        ],
        "body": [
            "port_set_mm_handler(${1:port_id}, ${2:func_id}, ${3:bar_id}, ${4:mmh});"
        ],
        "description": "[Class:apci_device]\n extern function void port_set_mm_handler(input int             port_id,\ninput bit             func_id,\ninput bit             bar_id,\ninput apci_mm_handler mmh);    "
    },
    "apci_device :: port_set_ifc": {
        "prefix": [
            "port_set_ifc",
            "function:port_set_ifc -> apci_device"
        ],
        "body": [
            "port_set_ifc(${1:port_id}, ${2:vc_id}, ${3:fc_type}, ${4:value}, ${5:scale_factor});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_set_ifc(input int          port_id,\ninput byte         vc_id,\ninput apci_fc_type fc_type,\ninput int          value,\ninput int          scale_factor = -1    );    "
    },
    "apci_device :: port_set_ufc": {
        "prefix": [
            "port_set_ufc",
            "function:port_set_ufc -> apci_device"
        ],
        "body": [
            "port_set_ufc(${1:port_id}, ${2:vc_id}, ${3:fc_type}, ${4:enable}, ${5:threshold}, ${6:interval_in_ns});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_set_ufc(input int          port_id,\ninput byte         vc_id,\ninput apci_fc_type fc_type,\ninput bit          enable,\n   input int          threshold,\ninput int          interval_in_ns);    "
    },
    "apci_device :: port_get_fc": {
        "prefix": [
            "port_get_fc",
            "function:port_get_fc -> apci_device"
        ],
        "body": [
            "port_get_fc(${1:port_id}, ${2:vc_id}, ${3:init_crd_limit}, ${4:crd_limit}, ${5:crd_consumed}, ${6:init_crd_alloc}, ${7:crd_alloc}, ${8:crd_received});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_get_fc(input int              port_id,\ninput byte             vc_id,\noutput apci_flow_crd_t init_crd_limit,\n output apci_flow_crd_t crd_limit     ,\n output apci_flow_crd_t crd_consumed  ,\n output apci_flow_crd_t init_crd_alloc,\n output apci_flow_crd_t crd_alloc     ,\n output apci_flow_crd_t crd_received    );    "
    },
    "apci_device :: port_get_fc_scale_factor": {
        "prefix": [
            "port_get_fc_scale_factor",
            "function:port_get_fc_scale_factor -> apci_device"
        ],
        "body": [
            "port_get_fc_scale_factor(${1:port_id}, ${2:vc_id}, ${3:local_scale_factor}, ${4:peer_scale_factor});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void port_get_fc_scale_factor(input  intport_id,\n input  bytevc_id,\n   output bit       local_scale_factor      ,\n output bit       peer_scale_factor          );    "
    },
    "apci_device :: port_get": {
        "prefix": [
            "port_get",
            "function:port_get -> apci_device"
        ],
        "body": [
            "port_get(${1:port_id}, ${2:entry});"
        ],
        "description": "[Class:apci_device]\n extern virtual function bit       port_get(input int     port_id,\ninput string  entry);    "
    },
    "apci_device :: port_get_lane": {
        "prefix": [
            "port_get_lane",
            "function:port_get_lane -> apci_device"
        ],
        "body": [
            "port_get_lane(${1:port_id}, ${2:lane_no}, ${3:entry});"
        ],
        "description": "[Class:apci_device]\n extern virtual function bit       port_get_lane(input int     port_id,\ninput int     lane_no,\ninput string  entry);    "
    },
    "apci_device :: port_get_func_adaptor": {
        "prefix": [
            "port_get_func_adaptor",
            "function:port_get_func_adaptor -> apci_device"
        ],
        "body": [
            "port_get_func_adaptor(${1:port_id}, ${2:func_id});"
        ],
        "description": "[Class:apci_device]\n extern virtual function apci_func_adaptor port_get_func_adaptor(input int     port_id,\ninput int     func_id    );    "
    },
    "apci_device :: port_get_al_tl_if": {
        "prefix": [
            "port_get_al_tl_if",
            "function:port_get_al_tl_if -> apci_device"
        ],
        "body": [
            "port_get_al_tl_if(${1:port_id});"
        ],
        "description": "[Class:apci_device]\n extern virtual function apci_al_tl_if port_get_al_tl_if(input int     port_id    );    "
    },
    "apci_device :: port_get_dll_mac_if": {
        "prefix": [
            "port_get_dll_mac_if",
            "function:port_get_dll_mac_if -> apci_device"
        ],
        "body": [
            "port_get_dll_mac_if(${1:port_id});"
        ],
        "description": "[Class:apci_device]\n extern virtual function apci_dll_mac_if port_get_dll_mac_if(        input int     port_id    );    "
    },
    "apci_device :: phy_set": {
        "prefix": [
            "phy_set",
            "function:phy_set -> apci_device"
        ],
        "body": [
            "phy_set(${1:port_id}, ${2:lane_no}, ${3:entry}, ${4:value});"
        ],
        "description": "[Class:apci_device]\n extern function void phy_set(input intport_id,\ninput intlane_no,\ninput stringentry,\ninput longintvalue = -1);    "
    },
    "apci_device :: phy_release": {
        "prefix": [
            "phy_release",
            "function:phy_release -> apci_device"
        ],
        "body": [
            "phy_release(${1:port_id}, ${2:entry});"
        ],
        "description": "[Class:apci_device]\n extern function void phy_release(input int       port_id,\ninput string    entry);    "
    },
    "apci_device :: phy_get": {
        "prefix": [
            "phy_get",
            "function:phy_get -> apci_device"
        ],
        "body": [
            "phy_get(${1:port_id}, ${2:lane_no}, ${3:entry});"
        ],
        "description": "[Class:apci_device]\n extern virtual function bit       phy_get(input intport_id,\ninput intlane_no,\ninput stringentry);    "
    },
    "apci_device :: phy_wait_event": {
        "prefix": [
            "phy_wait_event",
            "task:phy_wait_event -> apci_device"
        ],
        "body": [
            "phy_wait_event(${1:port_id}, ${2:lane_no}, ${3:entry}, ${4:timer}, ${5:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task phy_wait_event(        int    port_id    ,\nint    lane_no  ,\n        string entry      ,\n        time   timer       = 0,\n        string timeout_msg = \"\" );    "
    },
    "apci_device :: collect_devices": {
        "prefix": [
            "collect_devices",
            "task:collect_devices -> apci_device"
        ],
        "body": [
            "collect_devices(${1:num}, ${2:mgrs}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task collect_devices(input  int             num,\noutput apci_device_mgr mgrs      ,\ninput  time            timer = 0,\ninput  string          timeout_msg = \"\");    "
    },
    "apci_device :: collect_local_bdfs": {
        "prefix": [
            "collect_local_bdfs",
            "function:collect_local_bdfs -> apci_device"
        ],
        "body": [
            "collect_local_bdfs(${1:bdfs});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void collect_local_bdfs(output apci_bdf_t  bdfs      );    "
    },
    "apci_device :: post_transaction": {
        "prefix": [
            "post_transaction",
            "function:post_transaction -> apci_device"
        ],
        "body": [
            "post_transaction(${1:tr});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void post_transaction( apci_transaction  tr);    "
    },
    "apci_device :: post_tlp": {
        "prefix": [
            "post_tlp",
            "function:post_tlp -> apci_device"
        ],
        "body": [
            "post_tlp(${1:p});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void post_tlp( apci_tlp  p );    "
    },
    "apci_device :: inject_pkt": {
        "prefix": [
            "inject_pkt",
            "function:inject_pkt -> apci_device"
        ],
        "body": [
            "inject_pkt(${1:where}, ${2:pkt}, ${3:is_front});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void inject_pkt(string      where,\napci_packet pkt,\nbit         is_front = 1    );    "
    },
    "apci_device :: inject_flit": {
        "prefix": [
            "inject_flit",
            "function:inject_flit -> apci_device"
        ],
        "body": [
            "inject_flit(${1:where}, ${2:flit}, ${3:is_front}, ${4:bypass_callback});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void inject_flit(string      where,\napci_flit   flit,\nbit         is_front = 1,\n        bit         bypass_callback = 0    );    "
    },
    "apci_device :: read_capability": {
        "prefix": [
            "read_capability",
            "task:read_capability -> apci_device"
        ],
        "body": [
            "read_capability(${1:bdf}, ${2:cap}, ${3:dword_offset}, ${4:err}, ${5:num_dwords}, ${6:timer}, ${7:first_be}, ${8:err_severity});"
        ],
        "description": "[Class:apci_device]\n extern virtual task read_capability(apci_bdf_t       bdf,\napci_capability  cap,\nbit              dword_offset,\noutput  bit      err,\ninput   int      num_dwords= 1,\n        input   time     timer = 0,\ninput   bit       first_be = 4'hf,\ninput   int      err_severity = 0);    "
    },
    "apci_device :: write_capability": {
        "prefix": [
            "write_capability",
            "task:write_capability -> apci_device"
        ],
        "body": [
            "write_capability(${1:bdf}, ${2:cap}, ${3:dword_offset}, ${4:err}, ${5:num_dwords}, ${6:timer}, ${7:first_be}, ${8:err_severity});"
        ],
        "description": "[Class:apci_device]\n extern virtual task write_capability(apci_bdf_t      bdf,\napci_capability cap,\nbit             dword_offset,\noutput  bit     err,\ninput   int     num_dwords= 1,\ninput   time    timer = 0,\n        input   bit       first_be = 4'hf,\ninput   int     err_severity = 0    );    "
    },
    "apci_device :: wait_irq": {
        "prefix": [
            "wait_irq",
            "task:wait_irq -> apci_device"
        ],
        "body": [
            "wait_irq(${1:irq}, ${2:timer}, ${3:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task wait_irq(        output apci_irq_t irq        ,\n        input  time       timer       = 0,\n        input  string     timeout_msg = \"\" );    "
    },
    "apci_device :: wait_event": {
        "prefix": [
            "wait_event",
            "task:wait_event -> apci_device"
        ],
        "body": [
            "wait_event(${1:entry}, ${2:timer}, ${3:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task wait_event(string entry,\ntime   timer = 0,\nstring timeout_msg = \"\");    "
    },
    "apci_device :: port_wait_event": {
        "prefix": [
            "port_wait_event",
            "task:port_wait_event -> apci_device"
        ],
        "body": [
            "port_wait_event(${1:port_id}, ${2:entry}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task port_wait_event(        int    port_id    ,\n        string entry      ,\n        time   timer       = 0,\n        string timeout_msg = \"\" );    "
    },
    "apci_device :: port_wait_ltssm": {
        "prefix": [
            "port_wait_ltssm",
            "task:port_wait_ltssm -> apci_device"
        ],
        "body": [
            "port_wait_ltssm(${1:port_id}, ${2:state}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task port_wait_ltssm(        int                port_id    ,\n        apci_ltssm_state_e state      ,\n        time               timer       = 0,\n        string             timeout_msg = \"\");    "
    },
    "apci_device :: wait_pkt_cb": {
        "prefix": [
            "wait_pkt_cb",
            "task:wait_pkt_cb -> apci_device"
        ],
        "body": [
            "wait_pkt_cb(${1:where}, ${2:pkt}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task wait_pkt_cb(input  string       where,\noutput apci_packet  pkt,\ninput time          timer = 0,\ninput string        timeout_msg = \"\");    "
    },
    "apci_device :: find_device_by_id": {
        "prefix": [
            "find_device_by_id",
            "function:find_device_by_id -> apci_device"
        ],
        "body": [
            "find_device_by_id(${1:pci_id}, ${2:fatal_if_not_found});"
        ],
        "description": "[Class:apci_device]\n extern virtual function apci_device_mgr find_device_by_id(    input int  pci_id = -1,\n    input bit fatal_if_not_found = 1);    "
    },
    "apci_device :: do_cold_reset": {
        "prefix": [
            "do_cold_reset",
            "task:do_cold_reset -> apci_device"
        ],
        "body": [
            "do_cold_reset(${1:hold_time_in_ns}, ${2:early_notification});"
        ],
        "description": "[Class:apci_device]\n extern virtual task do_cold_reset(time  hold_time_in_ns = 0,\n bit early_notification = 0);    "
    },
    "apci_device :: do_warm_reset": {
        "prefix": [
            "do_warm_reset",
            "task:do_warm_reset -> apci_device"
        ],
        "body": [
            "do_warm_reset(${1:hold_time_in_ns}, ${2:early_notification});"
        ],
        "description": "[Class:apci_device]\n extern virtual task do_warm_reset(time  hold_time_in_ns = 0,\n bit early_notification = 0);    "
    },
    "apci_device :: do_scramble": {
        "prefix": [
            "do_scramble",
            "function:do_scramble -> apci_device"
        ],
        "body": [
            "do_scramble(${1:is_8b10b}, ${2:data9}, ${3:lfsr});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void do_scramble(bit is_8b10b,\n inout bit       data9,\n inout bit       lfsr);    "
    },
    "apci_device :: set_all_bfms": {
        "prefix": [
            "set_all_bfms",
            "function:set_all_bfms -> apci_device"
        ],
        "body": [
            "set_all_bfms(${1:all_bfms});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void set_all_bfms(apci_device all_bfms      );    "
    },
    "apci_device :: init_ptm_req": {
        "prefix": [
            "init_ptm_req",
            "task:init_ptm_req -> apci_device"
        ],
        "body": [
            "init_ptm_req(${1:dialog_num}, ${2:abort_timeout});"
        ],
        "description": "[Class:apci_device]\n extern virtual task init_ptm_req(int dialog_num = 2,\n int abort_timeout = 1e9);    "
    },
    "apci_device :: msix_alloc_vectors": {
        "prefix": [
            "msix_alloc_vectors",
            "task:msix_alloc_vectors -> apci_device"
        ],
        "body": [
            "msix_alloc_vectors(${1:bdf}, ${2:vectors}, ${3:msg_addr}, ${4:msg_data}, ${5:err});"
        ],
        "description": "[Class:apci_device]\n extern virtual task msix_alloc_vectors(      apci_bdf_t  bdf,\nref   avery_u16   vectors      ,\ninput avery_u64   msg_addr = -1,\ninput avery_u33   msg_data = -1,\noutput bit        err);    "
    },
    "apci_device :: msi_alloc_vectors": {
        "prefix": [
            "msi_alloc_vectors",
            "task:msi_alloc_vectors -> apci_device"
        ],
        "body": [
            "msi_alloc_vectors(${1:bdf}, ${2:num_vec}, ${3:msg_addr}, ${4:msg_data}, ${5:err});"
        ],
        "description": "[Class:apci_device]\n extern virtual task msi_alloc_vectors(      apci_bdf_t  bdf,\n      int         num_vec  = 32,\ninput avery_u64   msg_addr = -1,\ninput avery_u33   msg_data = -1,\noutput bit        err);    "
    },
    "apci_device :: signal_interrupt": {
        "prefix": [
            "signal_interrupt",
            "task:signal_interrupt -> apci_device"
        ],
        "body": [
            "signal_interrupt(${1:port_id}, ${2:func_num}, ${3:kind}, ${4:vector}, ${5:err}, ${6:masked}, ${7:kind_signaled}, ${8:wait_issued});"
        ],
        "description": "[Class:apci_device]\n extern virtual task signal_interrupt(        input  int              port_id   ,\n        input  int              func_num  ,\n        input  apci_interrupt_e kind      ,\n        input  int              vector    ,\n        output bit              err       ,\n        output bit              masked    ,\noutput apci_interrupt_e kind_signaled,\ninput  bit              wait_issued = 0);    "
    },
    "apci_device :: ats_configure": {
        "prefix": [
            "ats_configure",
            "task:ats_configure -> apci_device"
        ],
        "body": [
            "ats_configure(${1:bdf}, ${2:stu}, ${3:mgr});"
        ],
        "description": "[Class:apci_device]\n extern virtual task ats_configure(apci_bdf_t bdf,\n bit       stu,\n output apci_atc_mgr mgr);    "
    },
    "apci_device :: ats_add_atpt_entry": {
        "prefix": [
            "ats_add_atpt_entry",
            "function:ats_add_atpt_entry -> apci_device"
        ],
        "body": [
            "ats_add_atpt_entry(${1:entry});"
        ],
        "description": "[Class:apci_device]\n extern function void ats_add_atpt_entry(apci_atpt_entry_t entry);    "
    },
    "apci_device :: ats_remove_atpt_entry": {
        "prefix": [
            "ats_remove_atpt_entry",
            "function:ats_remove_atpt_entry -> apci_device"
        ],
        "body": [
            "ats_remove_atpt_entry(${1:untranslated_addr}, ${2:bdf});"
        ],
        "description": "[Class:apci_device]\n extern function void ats_remove_atpt_entry(bit       untranslated_addr,\n apci_bdf_t bdf = 0);    "
    },
    "apci_device :: port_set_ide_key": {
        "prefix": [
            "port_set_ide_key",
            "function:port_set_ide_key -> apci_device"
        ],
        "body": [
            "port_set_ide_key(${1:port_id}, ${2:stream_id}, ${3:sub_stream}, ${4:is_tx}, ${5:key_set}, ${6:key_iv});"
        ],
        "description": "[Class:apci_device]\n extern function void port_set_ide_key(intport_id,\nbit      stream_id,\n bit      sub_stream,\n bitis_tx,\nintkey_set = -1,\n ref apci_ide_key_iv_t   key_iv);    "
    },
    "apci_device :: port_get_ide_key": {
        "prefix": [
            "port_get_ide_key",
            "function:port_get_ide_key -> apci_device"
        ],
        "body": [
            "port_get_ide_key(${1:port_id}, ${2:stream_id}, ${3:sub_stream}, ${4:is_tx}, ${5:index});"
        ],
        "description": "[Class:apci_device]\n extern function apci_ide_key_iv_t port_get_ide_key(        int                 port_id,\n        bit                  stream_id,\n         bit                  sub_stream,\n         bit                 is_tx,\n        int                 index = -1);     "
    },
    "apci_device :: port_set_spdm_key": {
        "prefix": [
            "port_set_spdm_key",
            "function:port_set_spdm_key -> apci_device"
        ],
        "body": [
            "port_set_spdm_key(${1:port_id}, ${2:key_iv});"
        ],
        "description": "[Class:apci_device]\n extern function void port_set_spdm_key(int port_id,\n apci_ide_key_iv_t key_iv = 0);    "
    },
    "apci_device :: init_ide": {
        "prefix": [
            "init_ide",
            "task:init_ide -> apci_device"
        ],
        "body": [
            "init_ide(${1:port_id}, ${2:finf}, ${3:id}, ${4:key_set});"
        ],
        "description": "[Class:apci_device]\n extern task init_ide(                                                                                                                                                 int             port_id,\n         apci_func_info  finf,\n        bit              id,\nbit        key_set = 0);    "
    },
    "apci_device :: port_wait_ide_state": {
        "prefix": [
            "port_wait_ide_state",
            "task:port_wait_ide_state -> apci_device"
        ],
        "body": [
            "port_wait_ide_state(${1:port_id}, ${2:stream_id}, ${3:sm_state}, ${4:timer}, ${5:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern task port_wait_ide_state(int port_id,\n int stream_id,\n apci_idessm_state_e sm_state,\n time timer = 0,\n string timeout_msg = \"\");    "
    },
    "apci_device :: set_mem_adaptor": {
        "prefix": [
            "set_mem_adaptor",
            "function:set_mem_adaptor -> apci_device"
        ],
        "body": [
            "set_mem_adaptor(${1:adaptor});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void set_mem_adaptor(        input apci_mem_adaptor adaptor);    "
    },
    "apci_device :: init_ccix_esm": {
        "prefix": [
            "init_ccix_esm",
            "task:init_ccix_esm -> apci_device"
        ],
        "body": [
            "init_ccix_esm(${1:port_id}, ${2:usp_bdf}, ${3:rate0}, ${4:rate1}, ${5:is_long_reach}, ${6:esm_err});"
        ],
        "description": "[Class:apci_device]\n extern virtual task init_ccix_esm(               int               port_id       = 0,\n               apci_bdf_t        usp_bdf      ,\n               bit                rate0         = APCI_ESM_16G,\n               bit                rate1         = APCI_ESM_25G,\n               bit               is_long_reach = 0,\n        output apci_esm_err_type esm_err       );    "
    },
    "apci_device :: my_report": {
        "prefix": [
            "my_report",
            "function:my_report -> apci_device"
        ],
        "body": [
            "my_report(${1:entry}, ${2:verbosity}, ${3:file});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void my_report(string entry,\n int verbosity = 0,\n int file = 0);    "
    },
    "apci_device :: append_callback": {
        "prefix": [
            "append_callback",
            "function:append_callback -> apci_device"
        ],
        "body": [
            "append_callback(${1:cb});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void append_callback(apci_callbacks_base cb);    "
    },
    "apci_device :: prepend_callback": {
        "prefix": [
            "prepend_callback",
            "function:prepend_callback -> apci_device"
        ],
        "body": [
            "prepend_callback(${1:cb});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void prepend_callback(apci_callbacks_base cb);    "
    },
    "apci_device :: unregister_callback": {
        "prefix": [
            "unregister_callback",
            "function:unregister_callback -> apci_device"
        ],
        "body": [
            "unregister_callback(${1:cb});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void unregister_callback(apci_callbacks_base cb);    "
    },
    "apci_device :: disable_lecroy_track_all": {
        "prefix": [
            "disable_lecroy_track_all",
            "function:disable_lecroy_track_all -> apci_device"
        ],
        "body": [
            "disable_lecroy_track_all(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void disable_lecroy_track_all();                                                                                                                    "
    },
    "apci_device :: disable_lecroy_track_tl": {
        "prefix": [
            "disable_lecroy_track_tl",
            "function:disable_lecroy_track_tl -> apci_device"
        ],
        "body": [
            "disable_lecroy_track_tl(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void disable_lecroy_track_tl();    "
    },
    "apci_device :: disable_lecroy_track_link": {
        "prefix": [
            "disable_lecroy_track_link",
            "function:disable_lecroy_track_link -> apci_device"
        ],
        "body": [
            "disable_lecroy_track_link(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void disable_lecroy_track_link();    "
    },
    "apci_device :: enable_lecroy_track_all": {
        "prefix": [
            "enable_lecroy_track_all",
            "function:enable_lecroy_track_all -> apci_device"
        ],
        "body": [
            "enable_lecroy_track_all(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void enable_lecroy_track_all();    "
    },
    "apci_device :: enable_lecroy_track_tl": {
        "prefix": [
            "enable_lecroy_track_tl",
            "function:enable_lecroy_track_tl -> apci_device"
        ],
        "body": [
            "enable_lecroy_track_tl(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void enable_lecroy_track_tl();    "
    },
    "apci_device :: enable_lecroy_track_link": {
        "prefix": [
            "enable_lecroy_track_link",
            "function:enable_lecroy_track_link -> apci_device"
        ],
        "body": [
            "enable_lecroy_track_link(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void enable_lecroy_track_link();    "
    },
    "apci_device :: cxl_port_set": {
        "prefix": [
            "cxl_port_set",
            "function:cxl_port_set -> apci_device"
        ],
        "body": [
            "cxl_port_set(${1:port_id}, ${2:entry}, ${3:value}, ${4:aux_value});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void cxl_port_set(input int       port_id,\ninput string    entry,\ninput longint   value     = -1,\ninput longint   aux_value = -1);    "
    },
    "apci_device :: cxl_port_add_ide_key": {
        "prefix": [
            "cxl_port_add_ide_key",
            "function:cxl_port_add_ide_key -> apci_device"
        ],
        "body": [
            "cxl_port_add_ide_key(${1:port_id}, ${2:is_tx}, ${3:key_set});"
        ],
        "description": "[Class:apci_device]\n extern function void cxl_port_add_ide_key(intport_id,\nbitis_tx,\nref apci_ide_key_iv_t  key_set);    "
    },
    "apci_device :: cxl_port_set_ifc": {
        "prefix": [
            "cxl_port_set_ifc",
            "function:cxl_port_set_ifc -> apci_device"
        ],
        "body": [
            "cxl_port_set_ifc(${1:port_id}, ${2:crd_type}, ${3:value});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void cxl_port_set_ifc(input int          port_id,\ninput acxl_fc_type crd_type,\ninput int          value);    "
    },
    "apci_device :: cxl_port_set_ufc": {
        "prefix": [
            "cxl_port_set_ufc",
            "function:cxl_port_set_ufc -> apci_device"
        ],
        "body": [
            "cxl_port_set_ufc(${1:port_id}, ${2:crd_type}, ${3:enable}, ${4:threshold});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void cxl_port_set_ufc(                                                                                                                          input int          port_id,\n            input acxl_fc_type crd_type,\n        input bit          enable,\n        input int          threshold);    "
    },
    "apci_device :: cxl_port_get_fc": {
        "prefix": [
            "cxl_port_get_fc",
            "function:cxl_port_get_fc -> apci_device"
        ],
        "body": [
            "cxl_port_get_fc(${1:port_id}, ${2:avail_tx_crd}, ${3:init_fc_alloc}, ${4:returnable_crd});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void cxl_port_get_fc(        input  int             port_id       ,\n        output acxl_flow_crd_t avail_tx_crd  ,\n        output acxl_flow_crd_t init_fc_alloc ,\n        output acxl_flow_crd_t returnable_crd);    "
    },
    "apci_device :: inject_cxl_msg": {
        "prefix": [
            "inject_cxl_msg",
            "function:inject_cxl_msg -> apci_device"
        ],
        "body": [
            "inject_cxl_msg(${1:where}, ${2:msg}, ${3:is_front}, ${4:bypass_callback});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void inject_cxl_msg(string      where,\nacxl_msg    msg,\nbit         is_front = 1,\nbit         bypass_callback = 0    );    "
    },
    "apci_device :: inject_cxl_flit": {
        "prefix": [
            "inject_cxl_flit",
            "function:inject_cxl_flit -> apci_device"
        ],
        "body": [
            "inject_cxl_flit(${1:where}, ${2:flit}, ${3:is_front}, ${4:bypass_callback});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void inject_cxl_flit(string      where,\nacxl_flit   flit,\nbit         is_front = 1,\nbit         bypass_callback = 0    );    "
    },
    "apci_device :: inject_cxl_intern_err": {
        "prefix": [
            "inject_cxl_intern_err",
            "function:inject_cxl_intern_err -> apci_device"
        ],
        "body": [
            "inject_cxl_intern_err(${1:err_type}, ${2:addr});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void inject_cxl_intern_err(acxl_ras_err_type_e  err_type,\nbit              addr    );    "
    },
    "apci_device :: port_wait_cxl_event": {
        "prefix": [
            "port_wait_cxl_event",
            "task:port_wait_cxl_event -> apci_device"
        ],
        "body": [
            "port_wait_cxl_event(${1:port_id}, ${2:entry}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual task port_wait_cxl_event(        int    port_id    ,\n        string entry      ,\n        time   timer       = 0,\n        string timeout_msg = \"\" );    "
    },
    "apci_device :: cxl_get_cacheline": {
        "prefix": [
            "cxl_get_cacheline",
            "function:cxl_get_cacheline -> apci_device"
        ],
        "body": [
            "cxl_get_cacheline(${1:addr});"
        ],
        "description": "[Class:apci_device]\n extern virtual function acxl_cacheline cxl_get_cacheline(bit       addr);    "
    },
    "apci_device :: cxl_get_cache": {
        "prefix": [
            "cxl_get_cache",
            "function:cxl_get_cache -> apci_device"
        ],
        "body": [
            "cxl_get_cache(${0:});"
        ],
        "description": "[Class:apci_device]\n extern virtual function acxl_cache cxl_get_cache();    "
    },
    "apci_device :: wait_cxl_msg_cb": {
        "prefix": [
            "wait_cxl_msg_cb",
            "task:wait_cxl_msg_cb -> apci_device"
        ],
        "body": [
            "wait_cxl_msg_cb(${1:where}, ${2:msg}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern task wait_cxl_msg_cb(input  string       where,\noutput acxl_msg     msg,\ninput time          timer = 0,\ninput string        timeout_msg = \"\");    "
    },
    "apci_device :: cxl_bkdoor_add_hdm": {
        "prefix": [
            "cxl_bkdoor_add_hdm",
            "function:cxl_bkdoor_add_hdm -> apci_device"
        ],
        "body": [
            "cxl_bkdoor_add_hdm(${1:port_id}, ${2:ranges}, ${3:bdf}, ${4:is_type3});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void cxl_bkdoor_add_hdm(        input int               port_id = 0,\n        input apci_addr_range_t ranges      ,\n        input apci_bdf_t        bdf = 0,\n        input bit               is_type3 = 0);    "
    },
    "apci_device :: cxl_bkdoor_set_bias": {
        "prefix": [
            "cxl_bkdoor_set_bias",
            "function:cxl_bkdoor_set_bias -> apci_device"
        ],
        "body": [
            "cxl_bkdoor_set_bias(${1:bdf}, ${2:hdm_addr}, ${3:bias_state});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void cxl_bkdoor_set_bias(        input int                bdf       ,\n        input bit                hdm_addr  ,\n        input acxl_meta0_value_e bias_state);    "
    },
    "apci_device :: port_wait_vlsm": {
        "prefix": [
            "port_wait_vlsm",
            "task:port_wait_vlsm -> apci_device"
        ],
        "body": [
            "port_wait_vlsm(${1:port_id}, ${2:vlsm_instance}, ${3:state}, ${4:timer}, ${5:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern task port_wait_vlsm(        int                port_id    ,\nint                vlsm_instance,\n        acxl_vlsm_state_e  state      ,\n        time               timer       = 0,\n        string             timeout_msg = \"\");    "
    },
    "apci_device :: port_wait_lrsm": {
        "prefix": [
            "port_wait_lrsm",
            "task:port_wait_lrsm -> apci_device"
        ],
        "body": [
            "port_wait_lrsm(${1:port_id}, ${2:state}, ${3:timer}, ${4:timeout_msg});"
        ],
        "description": "[Class:apci_device]\n extern task port_wait_lrsm(        int                port_id    ,\n        acxl_lrsm_e        state      ,\n        time               timer       = 0,\n        string             timeout_msg = \"\");    "
    },
    "apci_device :: post_cxl_tr": {
        "prefix": [
            "post_cxl_tr",
            "function:post_cxl_tr -> apci_device"
        ],
        "body": [
            "post_cxl_tr(${1:tr});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void post_cxl_tr( apci_transaction  tr);    "
    },
    "apci_device :: post_cxl_line_tr": {
        "prefix": [
            "post_cxl_line_tr",
            "function:post_cxl_line_tr -> apci_device"
        ],
        "body": [
            "post_cxl_line_tr(${1:tr});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void post_cxl_line_tr(acxl_line_tr tr);    "
    },
    "apci_device :: post_cxl_pm_msg": {
        "prefix": [
            "post_cxl_pm_msg",
            "function:post_cxl_pm_msg -> apci_device"
        ],
        "body": [
            "post_cxl_pm_msg(${1:msg});"
        ],
        "description": "[Class:apci_device]\n extern virtual function void post_cxl_pm_msg(acxl_pm_msg  msg);    "
    },
    "apci_device :: configure_doe": {
        "prefix": [
            "configure_doe",
            "task:configure_doe -> apci_device"
        ],
        "body": [
            "configure_doe(${1:finf}, ${2:doe_array}, ${3:err}, ${4:enable_interrupt});"
        ],
        "description": "[Class:apci_device]\n extern task configure_doe(apci_func_info finf,\n output apci_cap_doe doe_array      ,\n output bit err,\n input bit enable_interrupt=0);    "
    },
    "acxl_cxs_gasket": {
        "prefix": "acxl_cxs_gasket",
        "body": [
            "acxl_cxs_gasket  ${0:name_class};"
        ],
        "description": "class acxl_cxs_gasket extends acxl_cxs_gasket_base;\n"
    },
    "apci_packet": {
        "prefix": "apci_packet",
        "body": [
            "apci_packet  ${0:name_class};"
        ],
        "description": "class apci_packet extends apci_data_base;\n"
    },
    "apci_packet :: new": {
        "prefix": [
            "new",
            "function:new -> apci_packet"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_packet]\n     extern function new(string name = \"apci_packet\");    "
    },
    "apci_packet :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_packet"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:apci_packet]\n     extern function apci_packet copy(apci_packet to = null);    "
    },
    "apci_packet :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> apci_packet"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:apci_packet]\n     extern virtual task wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "apci_packet :: wait_sent": {
        "prefix": [
            "wait_sent",
            "task:wait_sent -> apci_packet"
        ],
        "body": [
            "wait_sent(${1:entry}, ${2:timer}, ${3:msg});"
        ],
        "description": "[Class:apci_packet]\n     extern virtual task wait_sent(string entry,\n time timer = 0,\n string msg = \"\");    "
    },
    "apci_packet :: rehash_link_crc": {
        "prefix": [
            "rehash_link_crc",
            "function:rehash_link_crc -> apci_packet"
        ],
        "body": [
            "rehash_link_crc(${0:});"
        ],
        "description": "[Class:apci_packet]\n     virtual function void rehash_link_crc();    "
    },
    "apci_packet :: rehash_ecrc": {
        "prefix": [
            "rehash_ecrc",
            "function:rehash_ecrc -> apci_packet"
        ],
        "body": [
            "rehash_ecrc(${0:});"
        ],
        "description": "[Class:apci_packet]\n     virtual function void rehash_ecrc();    "
    },
    "apci_packet :: is_tlp": {
        "prefix": [
            "is_tlp",
            "function:is_tlp -> apci_packet"
        ],
        "body": [
            "is_tlp(${0:});"
        ],
        "description": "[Class:apci_packet]\n     function is_tlp();  apci_tlp  p;    return $cast(p,\n this); endfunction    "
    },
    "apci_packet :: is_dllp": {
        "prefix": [
            "is_dllp",
            "function:is_dllp -> apci_packet"
        ],
        "body": [
            "is_dllp(${0:});"
        ],
        "description": "[Class:apci_packet]\n     function is_dllp(); apci_dllp p;    return $cast(p,\n this); endfunction    "
    },
    "apci_packet :: is_eds": {
        "prefix": [
            "is_eds",
            "function:is_eds -> apci_packet"
        ],
        "body": [
            "is_eds(${0:});"
        ],
        "description": "[Class:apci_packet]\n     function is_eds();  apci_eds_pkt p; return $cast(p,\n this); endfunction    "
    },
    "apci_packet :: get_parent_tr": {
        "prefix": [
            "get_parent_tr",
            "function:get_parent_tr -> apci_packet"
        ],
        "body": [
            "get_parent_tr(${0:});"
        ],
        "description": "[Class:apci_packet]\n     function apci_transaction get_parent_tr();    "
    },
    "apci_lpif_bridge": {
        "prefix": "apci_lpif_bridge",
        "body": [
            "apci_lpif_bridge  ${0:name_class};"
        ],
        "description": "class apci_lpif_bridge;\n"
    },
    "apci_lpif_bridge :: new": {
        "prefix": [
            "new",
            "function:new -> apci_lpif_bridge"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_lpif_bridge]\n extern function new(string name);    "
    },
    "apci_lpif_bridge :: connect": {
        "prefix": [
            "connect",
            "function:connect -> apci_lpif_bridge"
        ],
        "body": [
            "connect(${1:a_lpifs}, ${2:b_lpifs}, ${3:is_cm}, ${4:port_id}, ${5:lpif_index});"
        ],
        "description": "[Class:apci_lpif_bridge]\n extern function void connect(virtual apci_lpif a_lpifs      ,\n virtual apci_lpif b_lpifs      ,\n input bit is_cm = 0,\n input int port_id = 0,\n input int lpif_index);    "
    },
    "apci_lpif_bridge :: set": {
        "prefix": [
            "set",
            "function:set -> apci_lpif_bridge"
        ],
        "body": [
            "set(${1:entry}, ${2:value}, ${3:sub_entry});"
        ],
        "description": "[Class:apci_lpif_bridge]\n extern virtual function void set(input string    entry,\ninput bit       value = 0,\ninput string    sub_entry = \"\");    "
    },
    "apci_lpif_bridge :: wait_event": {
        "prefix": [
            "wait_event",
            "task:wait_event -> apci_lpif_bridge"
        ],
        "body": [
            "wait_event(${1:entry}, ${2:timer}, ${3:timeout_msg});"
        ],
        "description": "[Class:apci_lpif_bridge]\n extern virtual task wait_event(string entry,\ntime   timer = 0,\nstring timeout_msg = \"\");    "
    },
    "apci_cfg_space": {
        "prefix": "apci_cfg_space",
        "body": [
            "apci_cfg_space  ${0:name_class};"
        ],
        "description": "class apci_cfg_space extends avery_data_base;\n"
    },
    "apci_cfg_space :: new": {
        "prefix": [
            "new",
            "function:new -> apci_cfg_space"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:port_id}, ${4:func_num}, ${5:is_vf});"
        ],
        "description": "[Class:apci_cfg_space]\n     extern function new(string name,\n apci_log log,\n bit       port_id,\n bit       func_num,\n bit is_vf);    "
    },
    "apci_cfg_space :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_cfg_space"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_cfg_space]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_cfg_space :: is_rciep": {
        "prefix": [
            "is_rciep",
            "function:is_rciep -> apci_cfg_space"
        ],
        "body": [
            "is_rciep(${0:});"
        ],
        "description": "[Class:apci_cfg_space]\n     extern virtual function bit is_rciep();    "
    },
    "apci_cfg_space :: is_rcrb": {
        "prefix": [
            "is_rcrb",
            "function:is_rcrb -> apci_cfg_space"
        ],
        "body": [
            "is_rcrb(${0:});"
        ],
        "description": "[Class:apci_cfg_space]\n     extern virtual function bit is_rcrb();    "
    },
    "apci_cfg_space :: delete_optional_capabilities": {
        "prefix": [
            "delete_optional_capabilities",
            "function:delete_optional_capabilities -> apci_cfg_space"
        ],
        "body": [
            "delete_optional_capabilities(${0:});"
        ],
        "description": "[Class:apci_cfg_space]\n     virtual function void delete_optional_capabilities();    "
    },
    "avery_reg_field": {
        "prefix": "avery_reg_field",
        "body": [
            "avery_reg_field  ${0:name_class};"
        ],
        "description": "class avery_reg_field extends avery_data_base;\n"
    },
    "avery_reg_field :: new": {
        "prefix": [
            "new",
            "function:new -> avery_reg_field"
        ],
        "body": [
            "new(${1:name}, ${2:parent}, ${3:field_size}, ${4:lsb_loc}, ${5:default_val}, ${6:sticky}, ${7:acctype}, ${8:rand_default}, ${9:rand_sticky}, ${10:rand_acc}, ${11:is_static});"
        ],
        "description": "[Class:avery_reg_field]\n     function new(            string           name = \"avery_reg_field\",\n            avery_reg        parent = null,\n                  int              field_size,\n                     int              lsb_loc,\n                        avery_reg_val_t  default_val  = 0,\n            bit              sticky       = 0,\n            avery_reg_acc_e  acctype      = AVERY_REG_ACC_RsvdP,\n               bit              rand_default = 1,\n               bit              rand_sticky  = 1,\n               bit              rand_acc     = 1,\n               bit              is_static    = 0            );    "
    },
    "avery_reg_field :: set_v": {
        "prefix": [
            "set_v",
            "function:set_v -> avery_reg_field"
        ],
        "body": [
            "set_v(${1:v});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_v(avery_reg_val_t v);    "
    },
    "avery_reg_field :: set_dv": {
        "prefix": [
            "set_dv",
            "function:set_dv -> avery_reg_field"
        ],
        "body": [
            "set_dv(${1:dv});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_dv(avery_reg_val_t dv);    "
    },
    "avery_reg_field :: set_acctype": {
        "prefix": [
            "set_acctype",
            "function:set_acctype -> avery_reg_field"
        ],
        "body": [
            "set_acctype(${1:acctype});"
        ],
        "description": "[Class:avery_reg_field]\n     virtual function void set_acctype(avery_reg_acc_e acctype);    "
    },
    "avery_reg_field :: set_sticky": {
        "prefix": [
            "set_sticky",
            "function:set_sticky -> avery_reg_field"
        ],
        "body": [
            "set_sticky(${1:sticky});"
        ],
        "description": "[Class:avery_reg_field]\n     virtual function void set_sticky(bit sticky);    "
    },
    "avery_reg_field :: set_sticky_flr": {
        "prefix": [
            "set_sticky_flr",
            "function:set_sticky_flr -> avery_reg_field"
        ],
        "body": [
            "set_sticky_flr(${1:sticky_flr});"
        ],
        "description": "[Class:avery_reg_field]\n     virtual function void set_sticky_flr(bit sticky_flr);    "
    },
    "avery_reg_field :: set_lsb_loc": {
        "prefix": [
            "set_lsb_loc",
            "function:set_lsb_loc -> avery_reg_field"
        ],
        "body": [
            "set_lsb_loc(${1:lsb_loc});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_lsb_loc(int lsb_loc);    "
    },
    "avery_reg_field :: set_write_mask": {
        "prefix": [
            "set_write_mask",
            "function:set_write_mask -> avery_reg_field"
        ],
        "body": [
            "set_write_mask(${1:mask});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_write_mask(avery_reg_val_t mask);    "
    },
    "avery_reg_field :: get_write_mask": {
        "prefix": [
            "get_write_mask",
            "function:get_write_mask -> avery_reg_field"
        ],
        "body": [
            "get_write_mask(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function avery_reg_val_t get_write_mask();    "
    },
    "avery_reg_field :: get_field_size": {
        "prefix": [
            "get_field_size",
            "function:get_field_size -> avery_reg_field"
        ],
        "body": [
            "get_field_size(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function int get_field_size();    "
    },
    "avery_reg_field :: get_lsb_loc": {
        "prefix": [
            "get_lsb_loc",
            "function:get_lsb_loc -> avery_reg_field"
        ],
        "body": [
            "get_lsb_loc(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function int get_lsb_loc();    "
    },
    "avery_reg_field :: read_dw": {
        "prefix": [
            "read_dw",
            "function:read_dw -> avery_reg_field"
        ],
        "body": [
            "read_dw(${1:bit_offset}, ${2:bit_enable});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function avery_reg_val_t read_dw(int bit_offset,\n avery_u32 bit_enable = 'hffff_ffff);    "
    },
    "avery_reg_field :: write_dw": {
        "prefix": [
            "write_dw",
            "function:write_dw -> avery_reg_field"
        ],
        "body": [
            "write_dw(${1:bit_offset}, ${2:value}, ${3:bit_enable}, ${4:dbg});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void write_dw(                                    int       bit_offset,\n                                    avery_u32 value     ,\n                                    avery_u32 bit_enable='hffff_ffff,\n                                       string    dbg=\"\"     );    "
    },
    "avery_reg_field :: sprint_path": {
        "prefix": [
            "sprint_path",
            "function:sprint_path -> avery_reg_field"
        ],
        "body": [
            "sprint_path(${1:verbosity});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function string sprint_path(int verbosity = 0);    "
    },
    "avery_reg_field :: get_offset_dw": {
        "prefix": [
            "get_offset_dw",
            "function:get_offset_dw -> avery_reg_field"
        ],
        "body": [
            "get_offset_dw(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function bit       get_offset_dw();    "
    },
    "avery_reg_field :: get_offset": {
        "prefix": [
            "get_offset",
            "function:get_offset -> avery_reg_field"
        ],
        "body": [
            "get_offset(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function bit       get_offset();    "
    },
    "avery_reg_field :: set_shared": {
        "prefix": [
            "set_shared",
            "function:set_shared -> avery_reg_field"
        ],
        "body": [
            "set_shared(${1:shared});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_shared(avery_reg_field shared);    "
    },
    "avery_reg_field :: inverse": {
        "prefix": [
            "inverse",
            "function:inverse -> avery_reg_field"
        ],
        "body": [
            "inverse(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void inverse();    "
    },
    "avery_reg_field :: set_one": {
        "prefix": [
            "set_one",
            "function:set_one -> avery_reg_field"
        ],
        "body": [
            "set_one(${0:});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_one();    "
    },
    "avery_reg_field :: compare": {
        "prefix": [
            "compare",
            "function:compare -> avery_reg_field"
        ],
        "body": [
            "compare(${1:tgt});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function bit compare(avery_reg_field tgt);    "
    },
    "avery_reg_field :: set_print_verbosity": {
        "prefix": [
            "set_print_verbosity",
            "function:set_print_verbosity -> avery_reg_field"
        ],
        "body": [
            "set_print_verbosity(${1:v});"
        ],
        "description": "[Class:avery_reg_field]\n     extern virtual function void set_print_verbosity(int v);    "
    },
    "avery_reg": {
        "prefix": "avery_reg",
        "body": [
            "avery_reg  ${0:name_class};"
        ],
        "description": "class avery_reg extends avery_data_base; \n"
    },
    "avery_reg :: new": {
        "prefix": [
            "new",
            "function:new -> avery_reg"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:avery_reg]\n     function new(string name = \"avery_reg\");    "
    },
    "avery_reg :: get_size_dw": {
        "prefix": [
            "get_size_dw",
            "function:get_size_dw -> avery_reg"
        ],
        "body": [
            "get_size_dw(${0:});"
        ],
        "description": "[Class:avery_reg]\n     extern virtual function int get_size_dw();    "
    },
    "avery_reg :: get_size": {
        "prefix": [
            "get_size",
            "function:get_size -> avery_reg"
        ],
        "body": [
            "get_size(${0:});"
        ],
        "description": "[Class:avery_reg]\n     extern virtual function int get_size();    "
    },
    "avery_reg :: fread_dw": {
        "prefix": [
            "fread_dw",
            "function:fread_dw -> avery_reg"
        ],
        "body": [
            "fread_dw(${1:dw_offset}, ${2:byte_enable});"
        ],
        "description": "[Class:avery_reg]\n     extern virtual function avery_reg_val_t fread_dw( int      dw_offset  ,\n                                                      bit       byte_enable = 4'b1111 );    "
    },
    "avery_reg :: fwrite_dw": {
        "prefix": [
            "fwrite_dw",
            "function:fwrite_dw -> avery_reg"
        ],
        "body": [
            "fwrite_dw(${1:dw_offset}, ${2:value}, ${3:byte_enable}, ${4:modifier});"
        ],
        "description": "[Class:avery_reg]\n     extern virtual function void fwrite_dw( int             dw_offset  ,\n                                            avery_u32       value      ,\n                                            bit              byte_enable = 4'b1111,\n                                            avery_data_base modifier    = null );    "
    },
    "avery_reg :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> avery_reg"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:avery_reg]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "avery_reg :: configure": {
        "prefix": [
            "configure",
            "function:configure -> avery_reg"
        ],
        "body": [
            "configure(${1:n_dwords});"
        ],
        "description": "[Class:avery_reg]\n     extern function void configure(int n_dwords = 0);    "
    },
    "avery_reg :: get_dword": {
        "prefix": [
            "get_dword",
            "function:get_dword -> avery_reg"
        ],
        "body": [
            "get_dword(${1:dw_offset});"
        ],
        "description": "[Class:avery_reg]\n     extern function avery_reg_val_t get_dword(int dw_offset);    "
    },
    "avery_reg :: sprint_dword": {
        "prefix": [
            "sprint_dword",
            "function:sprint_dword -> avery_reg"
        ],
        "body": [
            "sprint_dword(${1:dw_offset}, ${2:verbosity});"
        ],
        "description": "[Class:avery_reg]\n     extern function string sprint_dword(int dw_offset,\n int verbosity= 0);    "
    },
    "avery_reg :: set_dword": {
        "prefix": [
            "set_dword",
            "function:set_dword -> avery_reg"
        ],
        "body": [
            "set_dword(${1:dw_offset}, ${2:value}, ${3:byte_enable}, ${4:modifier});"
        ],
        "description": "[Class:avery_reg]\n     extern virtual function void set_dword(            int             dw_offset  ,\n            avery_u32       value      ,\n            bit              byte_enable = 4'b1111,\n            avery_data_base modifier    = null );    "
    },
    "avery_reg :: create_dynamic_fields": {
        "prefix": [
            "create_dynamic_fields",
            "function:create_dynamic_fields -> avery_reg"
        ],
        "body": [
            "create_dynamic_fields(${0:});"
        ],
        "description": "[Class:avery_reg]\n     virtual function void create_dynamic_fields();    "
    },
    "avery_reg :: create_sec_dynamic_fields": {
        "prefix": [
            "create_sec_dynamic_fields",
            "function:create_sec_dynamic_fields -> avery_reg"
        ],
        "body": [
            "create_sec_dynamic_fields(${0:});"
        ],
        "description": "[Class:avery_reg]\n     virtual function void create_sec_dynamic_fields();                                                                                                                          "
    },
    "acxl_line_tr": {
        "prefix": "acxl_line_tr",
        "body": [
            "acxl_line_tr  ${0:name_class};"
        ],
        "description": "class acxl_line_tr extends apci_data_base;\n"
    },
    "acxl_line_tr :: new": {
        "prefix": [
            "new",
            "function:new -> acxl_line_tr"
        ],
        "body": [
            "new(${1:name}, ${2:kind});"
        ],
        "description": "[Class:acxl_line_tr]\n     extern function new(string name= \"\",\n acxl_line_tr_type kind = ACXL_LT_store);    "
    },
    "acxl_line_tr :: pre_randomize": {
        "prefix": [
            "pre_randomize",
            "function:pre_randomize -> acxl_line_tr"
        ],
        "body": [
            "pre_randomize(${0:});"
        ],
        "description": "[Class:acxl_line_tr]\n     function void pre_randomize(); endfunction    "
    },
    "acxl_line_tr :: copy": {
        "prefix": [
            "copy",
            "function:copy -> acxl_line_tr"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:acxl_line_tr]\n     extern function acxl_line_tr copy  (acxl_line_tr to = null,\n int level = -1);    "
    },
    "acxl_line_tr :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> acxl_line_tr"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:acxl_line_tr]\n     extern function string   sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "acxl_line_tr :: is_CacheFlushed": {
        "prefix": [
            "is_CacheFlushed",
            "function:is_CacheFlushed -> acxl_line_tr"
        ],
        "body": [
            "is_CacheFlushed(${0:});"
        ],
        "description": "[Class:acxl_line_tr]\n     virtual function bit is_CacheFlushed();     "
    },
    "acxl_line_tr :: is_store": {
        "prefix": [
            "is_store",
            "function:is_store -> acxl_line_tr"
        ],
        "body": [
            "is_store(${0:});"
        ],
        "description": "[Class:acxl_line_tr]\n     virtual function bit is_store();    "
    },
    "acxl_line_tr :: is_load": {
        "prefix": [
            "is_load",
            "function:is_load -> acxl_line_tr"
        ],
        "body": [
            "is_load(${0:});"
        ],
        "description": "[Class:acxl_line_tr]\n     virtual function bit is_load();    "
    },
    "acxl_line_tr :: wait_done": {
        "prefix": [
            "wait_done",
            "task:wait_done -> acxl_line_tr"
        ],
        "body": [
            "wait_done(${1:timer}, ${2:msg});"
        ],
        "description": "[Class:acxl_line_tr]\n     extern task          wait_done(time timer = 0,\n string msg = \"\");    "
    },
    "acxl_line_tr :: annotate": {
        "prefix": [
            "annotate",
            "function:annotate -> acxl_line_tr"
        ],
        "body": [
            "annotate(${1:s});"
        ],
        "description": "[Class:acxl_line_tr]\n     extern virtual function void annotate(string s);    "
    },
    "apci_mmio_reg": {
        "prefix": "apci_mmio_reg",
        "body": [
            "apci_mmio_reg  ${0:name_class};"
        ],
        "description": "class apci_mmio_reg extends avery_data_base;\n"
    },
    "apci_mmio_reg :: new": {
        "prefix": [
            "new",
            "function:new -> apci_mmio_reg"
        ],
        "body": [
            "new(${1:name}, ${2:log}, ${3:port_id}, ${4:func_num});"
        ],
        "description": "[Class:apci_mmio_reg]\n     extern function new(string name,\n apci_log log,\n bit       port_id,\n bit       func_num);    "
    },
    "apci_mmio_reg :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_mmio_reg"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_mmio_reg]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_mmio_reg :: delete_optional_capabilities": {
        "prefix": [
            "delete_optional_capabilities",
            "function:delete_optional_capabilities -> apci_mmio_reg"
        ],
        "body": [
            "delete_optional_capabilities(${0:});"
        ],
        "description": "[Class:apci_mmio_reg]\n     virtual function void delete_optional_capabilities();    "
    },
    "apci_mem_model": {
        "prefix": "apci_mem_model",
        "body": [
            "apci_mem_model  ${0:name_class};"
        ],
        "description": "class apci_mem_model;\n"
    },
    "apci_mem_model :: new": {
        "prefix": [
            "new",
            "function:new -> apci_mem_model"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:apci_mem_model]\n     function new(string name = \"apci_mem_model\",\n apci_log log);    "
    },
    "apci_mem_model :: read": {
        "prefix": [
            "read",
            "function:read -> apci_mem_model"
        ],
        "body": [
            "read(${1:offset}, ${2:byte_enable});"
        ],
        "description": "[Class:apci_mem_model]\n     extern virtual function bit       read(bit       offset,\n                                              bit        byte_enable = 4'b1111 );    "
    },
    "apci_mem_model :: write": {
        "prefix": [
            "write",
            "function:write -> apci_mem_model"
        ],
        "body": [
            "write(${1:offset}, ${2:byte_enable}, ${3:val}, ${4:dbg});"
        ],
        "description": "[Class:apci_mem_model]\n     extern virtual function void     write(bit       offset,\n                                              bit        byte_enable = 4'b1111,\n                                           bit       val,\n                                           avery_data_base dbg = null );    "
    },
    "apci_mem_model :: attach": {
        "prefix": [
            "attach",
            "function:attach -> apci_mem_model"
        ],
        "body": [
            "attach(${1:h});"
        ],
        "description": "[Class:apci_mem_model]\n     extern virtual function void attach(apci_mm_handler h);    "
    },
    "apci_mem_model :: detach": {
        "prefix": [
            "detach",
            "function:detach -> apci_mem_model"
        ],
        "body": [
            "detach(${1:h});"
        ],
        "description": "[Class:apci_mem_model]\n     extern virtual function void detach(apci_mm_handler h);    "
    },
    "avery_max": {
        "prefix": [
            "avery_max",
            "function:avery_max"
        ],
        "body": [
            "avery_max(${1:i}, ${2:j});"
        ],
        "description": "function automatic bit       avery_max(bit       i,\n bit       j);    "
    },
    "avery_min": {
        "prefix": [
            "avery_min",
            "function:avery_min"
        ],
        "body": [
            "avery_min(${1:i}, ${2:j});"
        ],
        "description": "function automatic bit       avery_min(bit       i,\n bit       j);    "
    },
    "avery_abs": {
        "prefix": [
            "avery_abs",
            "function:avery_abs"
        ],
        "body": [
            "avery_abs(${1:a});"
        ],
        "description": "function automatic bit       avery_abs(int a);    "
    },
    "avery_dw_boundary": {
        "prefix": [
            "avery_dw_boundary",
            "function:avery_dw_boundary"
        ],
        "body": [
            "avery_dw_boundary(${1:offset});"
        ],
        "description": "function avery_u32 avery_dw_boundary(avery_u32 offset);    "
    },
    "avery_round_to_dw": {
        "prefix": [
            "avery_round_to_dw",
            "function:avery_round_to_dw"
        ],
        "body": [
            "avery_round_to_dw(${1:num_bytes});"
        ],
        "description": "function automatic bit        avery_round_to_dw(bit       num_bytes);    "
    },
    "avery_pack_bytes": {
        "prefix": [
            "avery_pack_bytes",
            "function:avery_pack_bytes"
        ],
        "body": [
            "avery_pack_bytes(${1:from}, ${2:to}, ${3:num_bytes}, ${4:start_offset});"
        ],
        "description": "function automatic void avery_pack_bytes(        ref    bit        from      ,\n        output bit        to      ,\n        input  bit        num_bytes    = -1,\n             input  bit        start_offset = 0);    "
    },
    "avery_pack_bytes_arr": {
        "prefix": [
            "avery_pack_bytes_arr",
            "function:avery_pack_bytes_arr"
        ],
        "body": [
            "avery_pack_bytes_arr(${1:from}, ${2:to}, ${3:num_bytes}, ${4:start_offset});"
        ],
        "description": "function automatic void avery_pack_bytes_arr(        ref    bit        from      ,\n        ref    bit        to      ,\n        input  bit        num_bytes    = -1,\n             input  bit        start_offset = 0    );    "
    },
    "avery_q2a": {
        "prefix": [
            "avery_q2a",
            "function:avery_q2a"
        ],
        "body": [
            "avery_q2a(${1:from}, ${2:to});"
        ],
        "description": "function automatic void avery_q2a(ref bit       from      ,\n ref bit       to      );    "
    },
    "avery_dwords_to_bytes": {
        "prefix": [
            "avery_dwords_to_bytes",
            "function:avery_dwords_to_bytes"
        ],
        "body": [
            "avery_dwords_to_bytes(${1:dq}, ${2:bq});"
        ],
        "description": "function automatic void avery_dwords_to_bytes(ref bit       dq      ,\n ref bit       bq      );    "
    },
    "avery_bytes_to_dwords": {
        "prefix": [
            "avery_bytes_to_dwords",
            "function:avery_bytes_to_dwords"
        ],
        "body": [
            "avery_bytes_to_dwords(${1:bq}, ${2:dq});"
        ],
        "description": "function automatic void avery_bytes_to_dwords(ref bit       bq      ,\n ref bit       dq      );    "
    },
    "avery_ba2va": {
        "prefix": [
            "avery_ba2va",
            "function:avery_ba2va"
        ],
        "body": [
            "avery_ba2va(${1:ba}, ${2:da});"
        ],
        "description": "function automatic void avery_ba2va(ref bit       ba      ,\n ref bit       da      );    "
    },
    "avery_unpack_dwords": {
        "prefix": [
            "avery_unpack_dwords",
            "function:avery_unpack_dwords"
        ],
        "body": [
            "avery_unpack_dwords(${1:from}, ${2:to});"
        ],
        "description": "function automatic void avery_unpack_dwords(        ref  bit        from      ,\n           ref  bit        to      );    "
    },
    "avery_unpack_dwords_arr": {
        "prefix": [
            "avery_unpack_dwords_arr",
            "function:avery_unpack_dwords_arr"
        ],
        "body": [
            "avery_unpack_dwords_arr(${1:from}, ${2:to});"
        ],
        "description": "function automatic void avery_unpack_dwords_arr(        ref  bit        from      ,\n            ref  bit        to      );    "
    },
    "avery_va2ba": {
        "prefix": [
            "avery_va2ba",
            "function:avery_va2ba"
        ],
        "body": [
            "avery_va2ba(${1:from}, ${2:to});"
        ],
        "description": "function automatic void avery_va2ba (        ref  bit        from      ,\n            ref  bit        to      );    "
    },
    "avery_va2ba_be": {
        "prefix": [
            "avery_va2ba_be",
            "function:avery_va2ba_be"
        ],
        "body": [
            "avery_va2ba_be(${1:from}, ${2:to}, ${3:first_be}, ${4:last_be});"
        ],
        "description": "function automatic void avery_va2ba_be(        ref  bit        from      ,\n        ref  bit        to      ,\n        input bit        first_be,\n        input bit        last_be    );    "
    },
    "avery_align_addr": {
        "prefix": [
            "avery_align_addr",
            "function:avery_align_addr"
        ],
        "body": [
            "avery_align_addr(${1:addr}, ${2:n_bytes}, ${3:out_addr}, ${4:n_dwords});"
        ],
        "description": "function void avery_align_addr(        input  bit       addr,\n             input  bit       n_bytes,\n        output bit       out_addr,\n        output bit       n_dwords    );    "
    },
    "avery_get_device_id": {
        "prefix": [
            "avery_get_device_id",
            "function:avery_get_device_id"
        ],
        "body": [
            "avery_get_device_id(${0:});"
        ],
        "description": "function automatic avery_u32 avery_get_device_id();    "
    },
    "avery_get_data_id": {
        "prefix": [
            "avery_get_data_id",
            "function:avery_get_data_id"
        ],
        "body": [
            "avery_get_data_id(${0:});"
        ],
        "description": "function automatic avery_u32 avery_get_data_id();    "
    },
    "apqi_get_nvm_id": {
        "prefix": [
            "apqi_get_nvm_id",
            "function:apqi_get_nvm_id"
        ],
        "body": [
            "apqi_get_nvm_id(${0:});"
        ],
        "description": "function automatic avery_u32 apqi_get_nvm_id();    "
    },
    "avery_power_of_two": {
        "prefix": [
            "avery_power_of_two",
            "function:avery_power_of_two"
        ],
        "body": [
            "avery_power_of_two(${1:v});"
        ],
        "description": "function automatic int avery_power_of_two(bit       v);       "
    },
    "avery_is_power_of_two": {
        "prefix": [
            "avery_is_power_of_two",
            "function:avery_is_power_of_two"
        ],
        "body": [
            "avery_is_power_of_two(${1:v});"
        ],
        "description": "function bit avery_is_power_of_two(bit       v);    "
    },
    "avery_multiple_of": {
        "prefix": [
            "avery_multiple_of",
            "function:avery_multiple_of"
        ],
        "body": [
            "avery_multiple_of(${1:a}, ${2:b});"
        ],
        "description": "function automatic bit       avery_multiple_of(bit       a,\n bit       b);    "
    },
    "avery_round_up": {
        "prefix": [
            "avery_round_up",
            "function:avery_round_up"
        ],
        "body": [
            "avery_round_up(${1:a}, ${2:boundary});"
        ],
        "description": "function automatic bit       avery_round_up(bit       a,\n bit       boundary);    "
    },
    "avery_two_to_power_of": {
        "prefix": [
            "avery_two_to_power_of",
            "function:avery_two_to_power_of"
        ],
        "body": [
            "avery_two_to_power_of(${1:v});"
        ],
        "description": "function automatic bit       avery_two_to_power_of(bit       v);    "
    },
    "avery_multiple_check": {
        "prefix": [
            "avery_multiple_check",
            "function:avery_multiple_check"
        ],
        "body": [
            "avery_multiple_check(${1:a}, ${2:b});"
        ],
        "description": "function automatic bit avery_multiple_check(bit       a,\n bit       b);    "
    },
    "avery_is_multiple": {
        "prefix": [
            "avery_is_multiple",
            "function:avery_is_multiple"
        ],
        "body": [
            "avery_is_multiple(${1:a}, ${2:b});"
        ],
        "description": "function automatic bit avery_is_multiple(bit       a,\n bit       b);    "
    },
    "avery_distance_to_page": {
        "prefix": [
            "avery_distance_to_page",
            "function:avery_distance_to_page"
        ],
        "body": [
            "avery_distance_to_page(${1:page_size}, ${2:addr});"
        ],
        "description": "function avery_u64 avery_distance_to_page (avery_u64 page_size,\n avery_u64 addr);    "
    },
    "avery_offset_mask": {
        "prefix": [
            "avery_offset_mask",
            "function:avery_offset_mask"
        ],
        "body": [
            "avery_offset_mask(${1:page_size});"
        ],
        "description": "function bit       avery_offset_mask(bit       page_size);    "
    },
    "avery_page_mask": {
        "prefix": [
            "avery_page_mask",
            "function:avery_page_mask"
        ],
        "body": [
            "avery_page_mask(${1:page_size});"
        ],
        "description": "function bit       avery_page_mask(bit       page_size);    "
    },
    "avery_page_offset": {
        "prefix": [
            "avery_page_offset",
            "function:avery_page_offset"
        ],
        "body": [
            "avery_page_offset(${1:addr}, ${2:page_size});"
        ],
        "description": "function bit       avery_page_offset(bit       addr,\n bit       page_size);    "
    },
    "avery_page_align": {
        "prefix": [
            "avery_page_align",
            "function:avery_page_align"
        ],
        "body": [
            "avery_page_align(${1:addr}, ${2:page_size});"
        ],
        "description": "function bit       avery_page_align(bit       addr,\n bit       page_size);    "
    },
    "avery_random64": {
        "prefix": [
            "avery_random64",
            "function:avery_random64"
        ],
        "body": [
            "avery_random64(${1:a}, ${2:b});"
        ],
        "description": "function bit       avery_random64 (bit       a,\n bit       b);    "
    },
    "avery_print_dw_array": {
        "prefix": [
            "avery_print_dw_array",
            "function:avery_print_dw_array"
        ],
        "body": [
            "avery_print_dw_array(${1:da}, ${2:len}, ${3:prefix}, ${4:line_break});"
        ],
        "description": "function automatic string avery_print_dw_array(ref bit       da      ,\n input int len=16,\n string prefix=\"\",\n bit line_break=1);    "
    },
    "avery_print_dw_q": {
        "prefix": [
            "avery_print_dw_q",
            "function:avery_print_dw_q"
        ],
        "body": [
            "avery_print_dw_q(${1:dq}, ${2:len}, ${3:prefix}, ${4:line_break});"
        ],
        "description": "function automatic string avery_print_dw_q(ref bit       dq      ,\n input int len=16,\n string prefix=\"\",\n bit line_break=1);    "
    },
    "avery_print_u8": {
        "prefix": [
            "avery_print_u8",
            "function:avery_print_u8"
        ],
        "body": [
            "avery_print_u8(${1:b}, ${2:max}, ${3:prefix}, ${4:in_dword});"
        ],
        "description": "function automatic string avery_print_u8(ref bit       b      ,\n input bit       max = -1,\n string prefix=\"\",\n bit in_dword = 0);    "
    },
    "avery_print_bytes": {
        "prefix": [
            "avery_print_bytes",
            "function:avery_print_bytes"
        ],
        "body": [
            "avery_print_bytes(${1:b}, ${2:max}, ${3:prefix}, ${4:in_dword});"
        ],
        "description": "function automatic string avery_print_bytes(ref byte b      ,\n input bit       max = -1,\n string prefix=\"\",\n bit in_dword = 0);    "
    },
    "avery_swap_endian": {
        "prefix": [
            "avery_swap_endian",
            "function:avery_swap_endian"
        ],
        "body": [
            "avery_swap_endian(${1:v});"
        ],
        "description": "function bit       avery_swap_endian (bit       v);    "
    },
    "avery_dq_2_ba": {
        "prefix": [
            "avery_dq_2_ba",
            "function:avery_dq_2_ba"
        ],
        "body": [
            "avery_dq_2_ba(${1:from}, ${2:to});"
        ],
        "description": "function automatic void avery_dq_2_ba(        ref bit        from      ,\n        ref bit        to      );    "
    },
    "avery_hash_list": {
        "prefix": "avery_hash_list",
        "body": [
            "avery_hash_list  ${0:name_class};"
        ],
        "description": "class avery_hash_list #(type T = int, type TKEY = int);\n"
    },
    "avery_hash_list :: new": {
        "prefix": [
            "new",
            "function:new -> avery_hash_list"
        ],
        "body": [
            "new(${0:});"
        ],
        "description": "[Class:avery_hash_list]\n     function new();    "
    },
    "avery_hash_list :: push_back": {
        "prefix": [
            "push_back",
            "function:push_back -> avery_hash_list"
        ],
        "body": [
            "push_back(${1:key}, ${2:v});"
        ],
        "description": "[Class:avery_hash_list]\n     function void push_back(TKEY key,\n T v);    "
    },
    "avery_hash_list :: push_front": {
        "prefix": [
            "push_front",
            "function:push_front -> avery_hash_list"
        ],
        "body": [
            "push_front(${1:key}, ${2:v});"
        ],
        "description": "[Class:avery_hash_list]\n     function void push_front(TKEY key,\n T v);    "
    },
    "avery_hash_list :: lookup": {
        "prefix": [
            "lookup",
            "function:lookup -> avery_hash_list"
        ],
        "body": [
            "lookup(${1:key});"
        ],
        "description": "[Class:avery_hash_list]\n     function T lookup(TKEY key);    "
    },
    "avery_hash_list :: insert": {
        "prefix": [
            "insert",
            "function:insert -> avery_hash_list"
        ],
        "body": [
            "insert(${1:key}, ${2:v});"
        ],
        "description": "[Class:avery_hash_list]\n     function void insert(TKEY key,\n T v);    "
    },
    "avery_hash_list :: delete_all": {
        "prefix": [
            "delete_all",
            "function:delete_all -> avery_hash_list"
        ],
        "body": [
            "delete_all(${0:});"
        ],
        "description": "[Class:avery_hash_list]\n     function void delete_all();    "
    },
    "avery_hash_list :: delete": {
        "prefix": [
            "delete",
            "function:delete -> avery_hash_list"
        ],
        "body": [
            "delete(${1:key});"
        ],
        "description": "[Class:avery_hash_list]\n     function void delete(TKEY key);    "
    },
    "avery_assertion_item": {
        "prefix": "avery_assertion_item",
        "body": [
            "avery_assertion_item  ${0:name_class};"
        ],
        "description": "class avery_assertion_item;\n"
    },
    "avery_assertion_item :: new": {
        "prefix": [
            "new",
            "function:new -> avery_assertion_item"
        ],
        "body": [
            "new(${1:severity}, ${2:id}, ${3:des}, ${4:cvg_cnt});"
        ],
        "description": "[Class:avery_assertion_item]\n     function new(avery_severity severity,\n string id,\n string des,\n int cvg_cnt = 0);    "
    },
    "avery_assertion_item :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> avery_assertion_item"
        ],
        "body": [
            "sprint(${1:verbosity});"
        ],
        "description": "[Class:avery_assertion_item]\n     function string sprint(int verbosity = 0);    "
    },
    "avery_log_callbacks": {
        "prefix": "avery_log_callbacks",
        "body": [
            "avery_log_callbacks  ${0:name_class};"
        ],
        "description": "virtual class avery_log_callbacks;\n"
    },
    "avery_log_callbacks :: assertion_msg_cb": {
        "prefix": [
            "assertion_msg_cb",
            "function:assertion_msg_cb -> avery_log_callbacks"
        ],
        "body": [
            "assertion_msg_cb(${1:msg}, ${2:is_disable}, ${3:item});"
        ],
        "description": "[Class:avery_log_callbacks]\n     virtual function void assertion_msg_cb(                        input string msg,\n                        inout bit is_disable,\n                        ref avery_assertion_item item                    );    "
    },
    "avery_log_callbacks :: error_msg_cb": {
        "prefix": [
            "error_msg_cb",
            "function:error_msg_cb -> avery_log_callbacks"
        ],
        "body": [
            "error_msg_cb(${1:msg}, ${2:is_disable});"
        ],
        "description": "[Class:avery_log_callbacks]\n     virtual function void error_msg_cb(                        input string msg,\n                        inout bit is_disable                     );    "
    },
    "avery_log_callbacks :: fatal_msg_cb": {
        "prefix": [
            "fatal_msg_cb",
            "function:fatal_msg_cb -> avery_log_callbacks"
        ],
        "body": [
            "fatal_msg_cb(${1:msg}, ${2:is_disable});"
        ],
        "description": "[Class:avery_log_callbacks]\n     virtual function void fatal_msg_cb(                        input string msg,\n                        inout bit is_disable                    );    "
    },
    "avery_user_data": {
        "prefix": "avery_user_data",
        "body": [
            "avery_user_data  ${0:name_class};"
        ],
        "description": "class avery_user_data;\n"
    },
    "avery_data_base": {
        "prefix": "avery_data_base",
        "body": [
            "avery_data_base  ${0:name_class};"
        ],
        "description": "class avery_data_base\n    `ifdef AVERY_OVM\n        extends ovm_sequence_item\n    `elsif AVERY_UVM\n        extends uvm_sequence_item\n    `elsif AVERY_VMM\n        extends vmm_data\n    `endif\n    ;\n"
    },
    "avery_data_base :: new": {
        "prefix": [
            "new",
            "function:new -> avery_data_base"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:avery_data_base]\n     function new(string name = \"avery_data_base\");    "
    },
    "avery_data_base :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> avery_data_base"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:avery_data_base]\n     virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "avery_data_base :: copy": {
        "prefix": [
            "copy",
            "function:copy -> avery_data_base"
        ],
        "body": [
            "copy(${1:to});"
        ],
        "description": "[Class:avery_data_base]\n     function avery_data_base copy(avery_data_base to = null);    "
    },
    "avery_data_base :: sprint_user_str": {
        "prefix": [
            "sprint_user_str",
            "function:sprint_user_str -> avery_data_base"
        ],
        "body": [
            "sprint_user_str(${0:});"
        ],
        "description": "[Class:avery_data_base]\n     virtual function string sprint_user_str();    "
    },
    "avery_data_base :: replace_user_str": {
        "prefix": [
            "replace_user_str",
            "function:replace_user_str -> avery_data_base"
        ],
        "body": [
            "replace_user_str(${1:msg});"
        ],
        "description": "[Class:avery_data_base]\n     virtual function void replace_user_str(string msg);    "
    },
    "avery_data_base :: append_user_str": {
        "prefix": [
            "append_user_str",
            "function:append_user_str -> avery_data_base"
        ],
        "body": [
            "append_user_str(${1:msg});"
        ],
        "description": "[Class:avery_data_base]\n     virtual function void append_user_str(string msg);    "
    },
    "avery_pure_component": {
        "prefix": "avery_pure_component",
        "body": [
            "avery_pure_component  ${0:name_class};"
        ],
        "description": "class avery_pure_component\n    `ifdef AVERY_UVM\n        extends uvm_component\n    `endif\n    ;\n"
    },
    "avery_pure_component :: new": {
        "prefix": [
            "new",
            "function:new -> avery_pure_component"
        ],
        "body": [
            "new(${1:name}, ${2:`endif});"
        ],
        "description": "[Class:avery_pure_component]\n     function new(        string name,\n    `ifdef AVERY_UVM        uvm_component        parent = null    `else        avery_pure_component parent = null    `endif        );    "
    },
    "avery_component": {
        "prefix": "avery_component",
        "body": [
            "avery_component  ${0:name_class};"
        ],
        "description": "class avery_component\n    `ifdef AVERY_VMM\n        extends vmm_xactor\n    `elsif AVERY_OVM\n        extends ovm_driver #(avery_data_base)\n              `elsif AVERY_UVM\n        extends uvm_driver #(avery_data_base)\n              `else\n        extends avery_pure_component\n    `endif\n    ;\n"
    },
    "avery_component :: new": {
        "prefix": [
            "new",
            "function:new -> avery_component"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent});"
        ],
        "description": "[Class:avery_component]\n     function new( string   name,\n                  `avery_xvm_parent);    "
    },
    "avery_component :: get_name": {
        "prefix": [
            "get_name",
            "function:get_name -> avery_component"
        ],
        "body": [
            "get_name(${0:});"
        ],
        "description": "[Class:avery_component]\n     virtual function string get_name();    "
    },
    "avery_component :: check_result": {
        "prefix": [
            "check_result",
            "function:check_result -> avery_component"
        ],
        "body": [
            "check_result(${1:verbosity});"
        ],
        "description": "[Class:avery_component]\n     virtual function bit check_result( int verbosity = 0 );    "
    },
    "avery_component :: end_sim_cb": {
        "prefix": [
            "end_sim_cb",
            "task:end_sim_cb -> avery_component"
        ],
        "body": [
            "end_sim_cb(${1:msg});"
        ],
        "description": "[Class:avery_component]\n     virtual task end_sim_cb(string msg = \"\");    "
    },
    "avery_component :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> avery_component"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:avery_component]\n     virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "avery_component :: aprint": {
        "prefix": [
            "aprint",
            "function:aprint -> avery_component"
        ],
        "body": [
            "aprint(${1:file}, ${2:msg}, ${3:id});"
        ],
        "description": "[Class:avery_component]\n     virtual function void aprint(int file,\n ref string msg,\n input int id = 0);    "
    },
    "avery_component :: aprint_set_file": {
        "prefix": [
            "aprint_set_file",
            "function:aprint_set_file -> avery_component"
        ],
        "body": [
            "aprint_set_file(${1:file}, ${2:filename});"
        ],
        "description": "[Class:avery_component]\n     virtual function void aprint_set_file(int file,\n string filename);    "
    },
    "avery_qlayer_base": {
        "prefix": "avery_qlayer_base",
        "body": [
            "avery_qlayer_base  ${0:name_class};"
        ],
        "description": "class avery_qlayer_base extends avery_component;\n"
    },
    "avery_qlayer_base :: new": {
        "prefix": [
            "new",
            "function:new -> avery_qlayer_base"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent});"
        ],
        "description": "[Class:avery_qlayer_base]\n     function new(string name,\n `avery_xvm_parent);    "
    },
    "avery_mem_model": {
        "prefix": "avery_mem_model",
        "body": [
            "avery_mem_model  ${0:name_class};"
        ],
        "description": "class avery_mem_model #(type T = byte, type T2 = bit[63:0]);\n"
    },
    "avery_mem_model :: new": {
        "prefix": [
            "new",
            "function:new -> avery_mem_model"
        ],
        "body": [
            "new(${1:name}, ${2:log});"
        ],
        "description": "[Class:avery_mem_model]\n     function new(string name,\n avery_log log = null);    "
    },
    "avery_mem_model :: exists": {
        "prefix": [
            "exists",
            "function:exists -> avery_mem_model"
        ],
        "body": [
            "exists(${1:addr});"
        ],
        "description": "[Class:avery_mem_model]\n     function bit exists(T2 addr);    "
    },
    "avery_mem_model :: read": {
        "prefix": [
            "read",
            "function:read -> avery_mem_model"
        ],
        "body": [
            "read(${1:addr});"
        ],
        "description": "[Class:avery_mem_model]\n     function T read(T2 addr);                                                                                                                                                                     "
    },
    "avery_mem_model :: write": {
        "prefix": [
            "write",
            "function:write -> avery_mem_model"
        ],
        "body": [
            "write(${1:addr}, ${2:data2});"
        ],
        "description": "[Class:avery_mem_model]\n     function void write(T2 addr,\n T data2);    "
    },
    "avery_mem_model :: size": {
        "prefix": [
            "size",
            "function:size -> avery_mem_model"
        ],
        "body": [
            "size(${0:});"
        ],
        "description": "[Class:avery_mem_model]\n     function bit       size();    "
    },
    "avery_mem_model :: delete": {
        "prefix": [
            "delete",
            "function:delete -> avery_mem_model"
        ],
        "body": [
            "delete(${1:addr});"
        ],
        "description": "[Class:avery_mem_model]\n     function void delete(T2 addr);    "
    },
    "avery_mem_model :: delete_all": {
        "prefix": [
            "delete_all",
            "function:delete_all -> avery_mem_model"
        ],
        "body": [
            "delete_all(${0:});"
        ],
        "description": "[Class:avery_mem_model]\n     function void delete_all();    "
    },
    "avery_seq_base": {
        "prefix": "avery_seq_base",
        "body": [
            "avery_seq_base  ${0:name_class};"
        ],
        "description": "class avery_seq_base extends\n    `ifdef AVERY_UVM\n        uvm_sequence #(avery_data_base);\n"
    },
    "avery_seq_base :: run": {
        "prefix": [
            "run",
            "task:run -> avery_seq_base"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:avery_seq_base]\n     virtual task run();    "
    },
    "avery_log": {
        "prefix": "avery_log",
        "body": [
            "avery_log  ${0:name_class};"
        ],
        "description": "class avery_log extends avery_pure_component;\n"
    },
    "avery_log :: new": {
        "prefix": [
            "new",
            "function:new -> avery_log"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent});"
        ],
        "description": "[Class:avery_log]\n     extern function new(string name,\n `avery_xvm_parent);    "
    },
    "avery_log :: error": {
        "prefix": [
            "error",
            "function:error -> avery_log"
        ],
        "body": [
            "error(${1:msg}, ${2:f});"
        ],
        "description": "[Class:avery_log]\n     extern virtual function void error       (string msg = \"\",\n avery_data_base f=null);    "
    },
    "avery_log :: fatal": {
        "prefix": [
            "fatal",
            "function:fatal -> avery_log"
        ],
        "body": [
            "fatal(${1:msg}, ${2:msg2});"
        ],
        "description": "[Class:avery_log]\n     extern virtual function void fatal       (string msg,\n string msg2 = \"\");    "
    },
    "avery_log :: info": {
        "prefix": [
            "info",
            "function:info -> avery_log"
        ],
        "body": [
            "info(${1:msg}, ${2:line_breaks_prefix});"
        ],
        "description": "[Class:avery_log]\n     extern virtual function void info        (string msg=\"\",\n int line_breaks_prefix=0)             ;    "
    },
    "avery_log :: warn": {
        "prefix": [
            "warn",
            "function:warn -> avery_log"
        ],
        "body": [
            "warn(${1:msg});"
        ],
        "description": "[Class:avery_log]\n     extern virtual function void warn        (string msg=\"\");    "
    },
    "avery_log :: asst": {
        "prefix": [
            "asst",
            "function:asst -> avery_log"
        ],
        "body": [
            "asst(${1:idname}, ${2:msg}, ${3:f});"
        ],
        "description": "[Class:avery_log]\n     extern virtual function void asst        (string idname,\n string msg=\"\",\n avery_data_base f=null);    "
    },
    "avery_log :: usage": {
        "prefix": [
            "usage",
            "function:usage -> avery_log"
        ],
        "body": [
            "usage(${1:msg}, ${2:is_finish});"
        ],
        "description": "[Class:avery_log]\n     extern virtual function void usage       (string msg,\n int is_finish=1);    "
    },
    "avery_log :: trigger": {
        "prefix": [
            "trigger",
            "function:trigger -> avery_log"
        ],
        "body": [
            "trigger(${1:idname});"
        ],
        "description": "[Class:avery_log]\n     virtual function void trigger            (string idname);     "
    },
    "avery_log :: set_global_severity": {
        "prefix": [
            "set_global_severity",
            "function:set_global_severity -> avery_log"
        ],
        "body": [
            "set_global_severity(${1:idname}, ${2:v});"
        ],
        "description": "[Class:avery_log]\n     virtual function void set_global_severity(string idname,\n avery_severity v) ;    "
    },
    "avery_log :: set_severity": {
        "prefix": [
            "set_severity",
            "function:set_severity -> avery_log"
        ],
        "body": [
            "set_severity(${1:idname}, ${2:v});"
        ],
        "description": "[Class:avery_log]\n     virtual function void set_severity       (string idname,\n avery_severity v) ;    "
    },
    "avery_log :: is_fired": {
        "prefix": [
            "is_fired",
            "function:is_fired -> avery_log"
        ],
        "body": [
            "is_fired(${1:idname});"
        ],
        "description": "[Class:avery_log]\n     virtual function bit  is_fired           (string idname );    "
    },
    "avery_log :: coverage_rpt": {
        "prefix": [
            "coverage_rpt",
            "function:coverage_rpt -> avery_log"
        ],
        "body": [
            "coverage_rpt(${1:filename});"
        ],
        "description": "[Class:avery_log]\n     virtual function void coverage_rpt       (string filename=\"\");    "
    },
    "avery_log :: internal": {
        "prefix": [
            "internal",
            "function:internal -> avery_log"
        ],
        "body": [
            "internal(${1:msg}, ${2:is_abort}, ${3:f});"
        ],
        "description": "[Class:avery_log]\n     virtual function void internal           (string msg,\n bit is_abort = 1,\n avery_data_base f=null);    "
    },
    "avery_log :: intern": {
        "prefix": [
            "intern",
            "function:intern -> avery_log"
        ],
        "body": [
            "intern(${1:msg}, ${2:is_abort}, ${3:f});"
        ],
        "description": "[Class:avery_log]\n     virtual function void intern (string msg,\n bit is_abort = 1,\n avery_data_base f=null);    "
    },
    "avery_log :: debug": {
        "prefix": [
            "debug",
            "function:debug -> avery_log"
        ],
        "body": [
            "debug(${1:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void debug              (string msg);    "
    },
    "avery_log :: spec_error": {
        "prefix": [
            "spec_error",
            "function:spec_error -> avery_log"
        ],
        "body": [
            "spec_error(${1:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void spec_error(string msg);    "
    },
    "avery_log :: sdebug": {
        "prefix": [
            "sdebug",
            "function:sdebug -> avery_log"
        ],
        "body": [
            "sdebug(${1:scope}, ${2:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void sdebug(string scope,\n string msg);    "
    },
    "avery_log :: sinfo": {
        "prefix": [
            "sinfo",
            "function:sinfo -> avery_log"
        ],
        "body": [
            "sinfo(${1:scope}, ${2:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void sinfo(string scope,\n string msg);    "
    },
    "avery_log :: swarning": {
        "prefix": [
            "swarning",
            "function:swarning -> avery_log"
        ],
        "body": [
            "swarning(${1:scope}, ${2:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void swarning(string scope,\n string msg);    "
    },
    "avery_log :: serror": {
        "prefix": [
            "serror",
            "function:serror -> avery_log"
        ],
        "body": [
            "serror(${1:scope}, ${2:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void serror(string scope,\n string msg);    "
    },
    "avery_log :: susage": {
        "prefix": [
            "susage",
            "function:susage -> avery_log"
        ],
        "body": [
            "susage(${1:scope}, ${2:msg}, ${3:is_abort});"
        ],
        "description": "[Class:avery_log]\n     virtual function void susage(string scope,\n string msg,\n bit is_abort = 0);    "
    },
    "avery_log :: sstep": {
        "prefix": [
            "sstep",
            "function:sstep -> avery_log"
        ],
        "body": [
            "sstep(${1:scope}, ${2:msg});"
        ],
        "description": "[Class:avery_log]\n     virtual function void sstep(string scope,\n string msg);    "
    },
    "avery_log :: todo": {
        "prefix": [
            "todo",
            "function:todo -> avery_log"
        ],
        "body": [
            "todo(${1:msg}, ${2:is_finish});"
        ],
        "description": "[Class:avery_log]\n     function void todo( string msg,\n int is_finish = 0);    "
    },
    "avery_log :: runlog_is_stdout": {
        "prefix": [
            "runlog_is_stdout",
            "function:runlog_is_stdout -> avery_log"
        ],
        "body": [
            "runlog_is_stdout(${0:});"
        ],
        "description": "[Class:avery_log]\n     function bit runlog_is_stdout();    "
    },
    "avery_log :: append_callback": {
        "prefix": [
            "append_callback",
            "function:append_callback -> avery_log"
        ],
        "body": [
            "append_callback(${1:cb});"
        ],
        "description": "[Class:avery_log]\n     function void append_callback(input avery_log_callbacks cb);    "
    },
    "avery_ring": {
        "prefix": "avery_ring",
        "body": [
            "avery_ring  ${0:name_class};"
        ],
        "description": "class avery_ring #(type T = bit[63:0]) extends avery_data_base;\n"
    },
    "avery_ring :: new": {
        "prefix": [
            "new",
            "function:new -> avery_ring"
        ],
        "body": [
            "new(${1:id}, ${2:qsize}, ${3:entry_size}, ${4:base});"
        ],
        "description": "[Class:avery_ring]\n     extern function new(int id,\n int qsize,\n int entry_size,\n bit       base = 0);    "
    },
    "avery_ring :: peek": {
        "prefix": [
            "peek",
            "function:peek -> avery_ring"
        ],
        "body": [
            "peek(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function T peek();    "
    },
    "avery_ring :: push": {
        "prefix": [
            "push",
            "function:push -> avery_ring"
        ],
        "body": [
            "push(${1:v});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function void push (T v);    "
    },
    "avery_ring :: size": {
        "prefix": [
            "size",
            "function:size -> avery_ring"
        ],
        "body": [
            "size(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int size();    "
    },
    "avery_ring :: num_entries": {
        "prefix": [
            "num_entries",
            "function:num_entries -> avery_ring"
        ],
        "body": [
            "num_entries(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int num_entries();    "
    },
    "avery_ring :: num_unused_entries": {
        "prefix": [
            "num_unused_entries",
            "function:num_unused_entries -> avery_ring"
        ],
        "body": [
            "num_unused_entries(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int num_unused_entries();    "
    },
    "avery_ring :: delete": {
        "prefix": [
            "delete",
            "function:delete -> avery_ring"
        ],
        "body": [
            "delete(${1:i});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function void delete(int i);    "
    },
    "avery_ring :: delete_all": {
        "prefix": [
            "delete_all",
            "function:delete_all -> avery_ring"
        ],
        "body": [
            "delete_all(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function void delete_all();    "
    },
    "avery_ring :: is_full": {
        "prefix": [
            "is_full",
            "function:is_full -> avery_ring"
        ],
        "body": [
            "is_full(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit is_full();    "
    },
    "avery_ring :: is_empty": {
        "prefix": [
            "is_empty",
            "function:is_empty -> avery_ring"
        ],
        "body": [
            "is_empty(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit is_empty();    "
    },
    "avery_ring :: is_wrap": {
        "prefix": [
            "is_wrap",
            "function:is_wrap -> avery_ring"
        ],
        "body": [
            "is_wrap(${1:total}, ${2:num_wrapped});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit is_wrap(input int total,\n output int num_wrapped);    "
    },
    "avery_ring :: get_qsize": {
        "prefix": [
            "get_qsize",
            "function:get_qsize -> avery_ring"
        ],
        "body": [
            "get_qsize(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int get_qsize();    "
    },
    "avery_ring :: get_entry_size": {
        "prefix": [
            "get_entry_size",
            "function:get_entry_size -> avery_ring"
        ],
        "body": [
            "get_entry_size(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int get_entry_size();    "
    },
    "avery_ring :: get_entry_size_dw": {
        "prefix": [
            "get_entry_size_dw",
            "function:get_entry_size_dw -> avery_ring"
        ],
        "body": [
            "get_entry_size_dw(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int get_entry_size_dw();    "
    },
    "avery_ring :: get_tail": {
        "prefix": [
            "get_tail",
            "function:get_tail -> avery_ring"
        ],
        "body": [
            "get_tail(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_tail();    "
    },
    "avery_ring :: get_pi": {
        "prefix": [
            "get_pi",
            "function:get_pi -> avery_ring"
        ],
        "body": [
            "get_pi(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_pi();    "
    },
    "avery_ring :: get_head": {
        "prefix": [
            "get_head",
            "function:get_head -> avery_ring"
        ],
        "body": [
            "get_head(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_head();    "
    },
    "avery_ring :: get_ci": {
        "prefix": [
            "get_ci",
            "function:get_ci -> avery_ring"
        ],
        "body": [
            "get_ci(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_ci();    "
    },
    "avery_ring :: get_tail_addr": {
        "prefix": [
            "get_tail_addr",
            "function:get_tail_addr -> avery_ring"
        ],
        "body": [
            "get_tail_addr(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_tail_addr();    "
    },
    "avery_ring :: get_pi_addr": {
        "prefix": [
            "get_pi_addr",
            "function:get_pi_addr -> avery_ring"
        ],
        "body": [
            "get_pi_addr(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_pi_addr();    "
    },
    "avery_ring :: get_head_addr": {
        "prefix": [
            "get_head_addr",
            "function:get_head_addr -> avery_ring"
        ],
        "body": [
            "get_head_addr(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_head_addr();    "
    },
    "avery_ring :: get_ci_addr": {
        "prefix": [
            "get_ci_addr",
            "function:get_ci_addr -> avery_ring"
        ],
        "body": [
            "get_ci_addr(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_ci_addr();    "
    },
    "avery_ring :: get_base_addr": {
        "prefix": [
            "get_base_addr",
            "function:get_base_addr -> avery_ring"
        ],
        "body": [
            "get_base_addr(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function bit       get_base_addr();    "
    },
    "avery_ring :: wait_free_space": {
        "prefix": [
            "wait_free_space",
            "task:wait_free_space -> avery_ring"
        ],
        "body": [
            "wait_free_space(${1:num_free_entries});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual task wait_free_space(int num_free_entries = 1);    "
    },
    "avery_ring :: wait_size": {
        "prefix": [
            "wait_size",
            "task:wait_size -> avery_ring"
        ],
        "body": [
            "wait_size(${1:num_entries});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual task wait_size(int num_entries = 0);    "
    },
    "avery_ring :: head_diff": {
        "prefix": [
            "head_diff",
            "function:head_diff -> avery_ring"
        ],
        "body": [
            "head_diff(${1:new_head});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int head_diff(int new_head);    "
    },
    "avery_ring :: tail_diff": {
        "prefix": [
            "tail_diff",
            "function:tail_diff -> avery_ring"
        ],
        "body": [
            "tail_diff(${1:new_tail});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int tail_diff(int new_tail);    "
    },
    "avery_ring :: pointer_diff": {
        "prefix": [
            "pointer_diff",
            "function:pointer_diff -> avery_ring"
        ],
        "body": [
            "pointer_diff(${0:});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function int pointer_diff();    "
    },
    "avery_ring :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> avery_ring"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:avery_ring]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix=\"\");    "
    },
    "avery_ring :: pop": {
        "prefix": [
            "pop",
            "function:pop -> avery_ring"
        ],
        "body": [
            "pop(${0:});"
        ],
        "description": "[Class:avery_ring]\n     function T pop();    "
    },
    "avery_timer": {
        "prefix": "avery_timer",
        "body": [
            "avery_timer  ${0:name_class};"
        ],
        "description": "class avery_timer;\n"
    },
    "avery_timer :: new": {
        "prefix": [
            "new",
            "function:new -> avery_timer"
        ],
        "body": [
            "new(${1:log}, ${2:timeout}, ${3:min_timeout}, ${4:msg}, ${5:is_fatal});"
        ],
        "description": "[Class:avery_timer]\n     extern function new(            avery_log  log = null,\n             time       timeout,\n                       time       min_timeout = 0,\n               string     msg = \"\",\n            bit        is_fatal = 0        );    "
    },
    "avery_timer :: start": {
        "prefix": [
            "start",
            "task:start -> avery_timer"
        ],
        "body": [
            "start(${0:});"
        ],
        "description": "[Class:avery_timer]\n     extern virtual task          start();    "
    },
    "avery_timer :: restart": {
        "prefix": [
            "restart",
            "task:restart -> avery_timer"
        ],
        "body": [
            "restart(${0:});"
        ],
        "description": "[Class:avery_timer]\n     extern virtual task          restart();    "
    },
    "avery_timer :: stop": {
        "prefix": [
            "stop",
            "task:stop -> avery_timer"
        ],
        "body": [
            "stop(${0:});"
        ],
        "description": "[Class:avery_timer]\n     extern virtual task          stop();    "
    },
    "avery_timer :: set_timeout": {
        "prefix": [
            "set_timeout",
            "function:set_timeout -> avery_timer"
        ],
        "body": [
            "set_timeout(${1:t});"
        ],
        "description": "[Class:avery_timer]\n     extern virtual function void set_timeout(time t);       "
    },
    "avery_timer :: set_min_timeout": {
        "prefix": [
            "set_min_timeout",
            "function:set_min_timeout -> avery_timer"
        ],
        "body": [
            "set_min_timeout(${1:t});"
        ],
        "description": "[Class:avery_timer]\n     extern virtual function void set_min_timeout(time t);       "
    },
    "avery_param_log_base": {
        "prefix": "avery_param_log_base",
        "body": [
            "avery_param_log_base  ${0:name_class};"
        ],
        "description": "class avery_param_log_base extends avery_log;\n"
    },
    "avery_param_log_base :: new": {
        "prefix": [
            "new",
            "function:new -> avery_param_log_base"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent});"
        ],
        "description": "[Class:avery_param_log_base]\n     function new(string name = \"avery_param_log\",\n `avery_xvm_parent);    "
    },
    "avery_param_log_base :: merge_coverage": {
        "prefix": [
            "merge_coverage",
            "function:merge_coverage -> avery_param_log_base"
        ],
        "body": [
            "merge_coverage(${1:log_base_a});"
        ],
        "description": "[Class:avery_param_log_base]\n     virtual function void merge_coverage (avery_param_log_base log_base_a);     "
    },
    "avery_param_log": {
        "prefix": "avery_param_log",
        "body": [
            "avery_param_log  ${0:name_class};"
        ],
        "description": "class avery_param_log #(\n    parameter type debug_e     = avy_debug_e, \n                   chklist_e   = avy_chklist_id_e, \n                   assert_item = avery_assertion_item\n    ) extends avery_param_log_base;\n"
    },
    "avery_param_log :: new": {
        "prefix": [
            "new",
            "function:new -> avery_param_log"
        ],
        "body": [
            "new(${1:name}, ${2:`avery_xvm_parent}, ${3:product_name});"
        ],
        "description": "[Class:avery_param_log]\n     extern function new(string name,\n `avery_xvm_parent,\n string product_name = \"AVY\");    "
    },
    "avery_rw_data32": {
        "prefix": "avery_rw_data32",
        "body": [
            "avery_rw_data32  ${0:name_class};"
        ],
        "description": "class avery_rw_data32;\n"
    },
    "avery_rw_data32 :: new": {
        "prefix": [
            "new",
            "function:new -> avery_rw_data32"
        ],
        "body": [
            "new(${1:isw}, ${2:total2}, ${3:start2});"
        ],
        "description": "[Class:avery_rw_data32]\n     extern function new (        input int isw= -1,\n         input int total2= 1,\n        input bit        start2 = 0);    "
    },
    "avery_rw_data": {
        "prefix": "avery_rw_data",
        "body": [
            "avery_rw_data  ${0:name_class};"
        ],
        "description": "class avery_rw_data;\n"
    },
    "avery_rw_data :: new": {
        "prefix": [
            "new",
            "function:new -> avery_rw_data"
        ],
        "body": [
            "new(${1:isw}, ${2:total2}, ${3:start2}, ${4:is_dw2});"
        ],
        "description": "[Class:avery_rw_data]\n     extern function new (        input int isw= -1,\n         input int total2= 1,\n        input bit        start2 = 0,\n        input bit is_dw2= 0);    "
    },
    "apipe_msg_bus_transaction": {
        "prefix": "apipe_msg_bus_transaction",
        "body": [
            "apipe_msg_bus_transaction  ${0:name_class};"
        ],
        "description": "class apipe_msg_bus_transaction extends avery_data_base;\n"
    },
    "apci_sprint_fc": {
        "prefix": [
            "apci_sprint_fc",
            "function:apci_sprint_fc"
        ],
        "body": [
            "apci_sprint_fc(${1:fc});"
        ],
        "description": "function string apci_sprint_fc(apci_flow_crd_t fc);    "
    },
    "apci_sprint_atpt_entry": {
        "prefix": [
            "apci_sprint_atpt_entry",
            "function:apci_sprint_atpt_entry"
        ],
        "body": [
            "apci_sprint_atpt_entry(${1:e});"
        ],
        "description": "function string apci_sprint_atpt_entry(apci_atpt_entry_t e);    "
    },
    "apci_be_to_bit_mask": {
        "prefix": [
            "apci_be_to_bit_mask",
            "function:apci_be_to_bit_mask"
        ],
        "body": [
            "apci_be_to_bit_mask(${1:be});"
        ],
        "description": "function bit       apci_be_to_bit_mask(bit       be);    "
    },
    "apci_data_base": {
        "prefix": "apci_data_base",
        "body": [
            "apci_data_base  ${0:name_class};"
        ],
        "description": "class apci_data_base extends avery_data_base;\n"
    },
    "apci_data_base :: new": {
        "prefix": [
            "new",
            "function:new -> apci_data_base"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_data_base]\n     function new(string name = \"apci_data_base\");    "
    },
    "apci_data_base :: annotate": {
        "prefix": [
            "annotate",
            "function:annotate -> apci_data_base"
        ],
        "body": [
            "annotate(${1:s});"
        ],
        "description": "[Class:apci_data_base]\n     virtual function void annotate(string s);    "
    },
    "apci_callbacks_base": {
        "prefix": "apci_callbacks_base",
        "body": [
            "apci_callbacks_base  ${0:name_class};"
        ],
        "description": "class apci_callbacks_base;\n"
    },
    "apci_seq_base": {
        "prefix": "apci_seq_base",
        "body": [
            "apci_seq_base  ${0:name_class};"
        ],
        "description": "class apci_seq_base extends apci_data_base;\n"
    },
    "apci_seq_base :: run": {
        "prefix": [
            "run",
            "task:run -> apci_seq_base"
        ],
        "body": [
            "run(${0:});"
        ],
        "description": "[Class:apci_seq_base]\n     virtual task run();    "
    },
    "apci_mm_handler": {
        "prefix": "apci_mm_handler",
        "body": [
            "apci_mm_handler  ${0:name_class};"
        ],
        "description": "class apci_mm_handler extends apci_data_base;\n"
    },
    "apci_mm_handler :: new": {
        "prefix": [
            "new",
            "function:new -> apci_mm_handler"
        ],
        "body": [
            "new(${1:name});"
        ],
        "description": "[Class:apci_mm_handler]\n     function new(string name = \"apci_mm_handler\");    "
    },
    "apci_mm_handler :: write_dw": {
        "prefix": [
            "write_dw",
            "function:write_dw -> apci_mm_handler"
        ],
        "body": [
            "write_dw(${1:offset}, ${2:v}, ${3:byte_enable});"
        ],
        "description": "[Class:apci_mm_handler]\n     virtual function void write_dw(bit       offset,\n bit       v,\n bit       byte_enable);    "
    },
    "apci_mm_handler :: read_dw": {
        "prefix": [
            "read_dw",
            "function:read_dw -> apci_mm_handler"
        ],
        "body": [
            "read_dw(${1:offset}, ${2:byte_enable});"
        ],
        "description": "[Class:apci_mm_handler]\n     virtual function bit       read_dw(bit       offset,\n bit       byte_enable);    "
    },
    "apci_mm_handler :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_mm_handler"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_mm_handler]\n     virtual function string sprint(int verbosity=0,\n string prefix=\"\");    "
    },
    "apci_mm_handler :: sanity_check": {
        "prefix": [
            "sanity_check",
            "function:sanity_check -> apci_mm_handler"
        ],
        "body": [
            "sanity_check(${1:log});"
        ],
        "description": "[Class:apci_mm_handler]\n     virtual function void sanity_check(apci_log log);    "
    },
    "apci_mm_handler :: get_size_dw": {
        "prefix": [
            "get_size_dw",
            "function:get_size_dw -> apci_mm_handler"
        ],
        "body": [
            "get_size_dw(${0:});"
        ],
        "description": "[Class:apci_mm_handler]\n     virtual function int get_size_dw();    "
    },
    "apci_mmh_list": {
        "prefix": "apci_mmh_list",
        "body": [
            "apci_mmh_list  ${0:name_class};"
        ],
        "description": "class apci_mmh_list;\n"
    },
    "apci_mmh_list :: new": {
        "prefix": [
            "new",
            "function:new -> apci_mmh_list"
        ],
        "body": [
            "new(${1:port_id}, ${2:func_id}, ${3:bar_id}, ${4:log});"
        ],
        "description": "[Class:apci_mmh_list]\n     function new(int port_id,\n int func_id,\n int bar_id,\n apci_log log);    "
    },
    "apci_mmh_list :: delete": {
        "prefix": [
            "delete",
            "function:delete -> apci_mmh_list"
        ],
        "body": [
            "delete(${1:h});"
        ],
        "description": "[Class:apci_mmh_list]\n     function void delete(apci_mm_handler h);    "
    },
    "apci_mmh_list :: check_overlap": {
        "prefix": [
            "check_overlap",
            "function:check_overlap -> apci_mmh_list"
        ],
        "body": [
            "check_overlap(${1:msg});"
        ],
        "description": "[Class:apci_mmh_list]\n     function void check_overlap(string msg = \"\");    "
    },
    "apci_mmh_list :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_mmh_list"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_mmh_list]\n     virtual function string sprint(int verbosity = 0,\n string prefix=\"\");    "
    },
    "apci_statistics": {
        "prefix": "apci_statistics",
        "body": [
            "apci_statistics  ${0:name_class};"
        ],
        "description": "class apci_statistics;\n"
    },
    "apci_statistics :: new": {
        "prefix": [
            "new",
            "function:new -> apci_statistics"
        ],
        "body": [
            "new(${1:port_id}, ${2:is_tx});"
        ],
        "description": "[Class:apci_statistics]\n     function new(int port_id,\n bit is_tx);    "
    },
    "apci_tx_sym_uvm_port": {
        "prefix": "apci_tx_sym_uvm_port",
        "body": [
            "apci_tx_sym_uvm_port  ${0:name_class};"
        ],
        "description": "class apci_tx_sym_uvm_port;\n"
    },
    "apci_tx_sym_uvm_port :: set": {
        "prefix": [
            "set",
            "function:set -> apci_tx_sym_uvm_port"
        ],
        "body": [
            "set(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:raw});"
        ],
        "description": "[Class:apci_tx_sym_uvm_port]\n     function void set( apci_device    bfm,\n       int      port_id,\n       int      logic_lane_num,\n       apci_raw_sym_t raw );    "
    },
    "apci_rx_sym_uvm_port": {
        "prefix": "apci_rx_sym_uvm_port",
        "body": [
            "apci_rx_sym_uvm_port  ${0:name_class};"
        ],
        "description": "class apci_rx_sym_uvm_port;\n"
    },
    "apci_rx_sym_uvm_port :: set": {
        "prefix": [
            "set",
            "function:set -> apci_rx_sym_uvm_port"
        ],
        "body": [
            "set(${1:bfm}, ${2:port_id}, ${3:logic_lane_num}, ${4:sym}, ${5:os_type}, ${6:os_index});"
        ],
        "description": "[Class:apci_rx_sym_uvm_port]\n     function void set( apci_device  bfm    ,\n        int    port_id    ,\n        int    logic_lane_num  ,\n        bit          sym    ,\n        apci_os_type os_type    ,\n        bit          os_index     );    "
    },
    "apci_tx_os_uvm_port": {
        "prefix": "apci_tx_os_uvm_port",
        "body": [
            "apci_tx_os_uvm_port  ${0:name_class};"
        ],
        "description": "class apci_tx_os_uvm_port;\n"
    },
    "apci_tx_os_uvm_port :: set": {
        "prefix": [
            "set",
            "function:set -> apci_tx_os_uvm_port"
        ],
        "body": [
            "set(${1:bfm}, ${2:port_id}, ${3:active_oses}, ${4:inactive_oses});"
        ],
        "description": "[Class:apci_tx_os_uvm_port]\n     function void set( apci_device    bfm,\n       int      port_id,\n       apci_os      active_oses      ,\n       apci_os      inactive_oses         );    "
    },
    "apci_rx_os_uvm_port": {
        "prefix": "apci_rx_os_uvm_port",
        "body": [
            "apci_rx_os_uvm_port  ${0:name_class};"
        ],
        "description": "class apci_rx_os_uvm_port;\n"
    },
    "apci_rx_os_uvm_port :: set": {
        "prefix": [
            "set",
            "function:set -> apci_rx_os_uvm_port"
        ],
        "body": [
            "set(${1:bfm}, ${2:logic_lane_num}, ${3:os});"
        ],
        "description": "[Class:apci_rx_os_uvm_port]\n     function void set( apci_device    bfm,\n       int      logic_lane_num    ,\n        apci_os        os);    "
    },
    "apci_mem_adaptor": {
        "prefix": "apci_mem_adaptor",
        "body": [
            "apci_mem_adaptor  ${0:name_class};"
        ],
        "description": "class apci_mem_adaptor;\n"
    },
    "apci_mem_adaptor :: write_mem_line": {
        "prefix": [
            "write_mem_line",
            "task:write_mem_line -> apci_mem_adaptor"
        ],
        "body": [
            "write_mem_line(${1:addr}, ${2:byte_enable}, ${3:bytes}, ${4:src});"
        ],
        "description": "[Class:apci_mem_adaptor]\n     virtual task write_mem_line(            input bit               addr        ,\n            input bit               byte_enable ,\n    ref   bit               bytes           ,\n    input avery_data_base   src = null       );    "
    },
    "apci_mem_adaptor :: read_mem_line": {
        "prefix": [
            "read_mem_line",
            "task:read_mem_line -> apci_mem_adaptor"
        ],
        "body": [
            "read_mem_line(${1:addr}, ${2:bytes}, ${3:src});"
        ],
        "description": "[Class:apci_mem_adaptor]\n     virtual task read_mem_line(    input bit               addr        ,\n    ref   bit               bytes           ,\n    input avery_data_base   src = null );    "
    },
    "apci_mem_adaptor :: write_noncoh_mem": {
        "prefix": [
            "write_noncoh_mem",
            "task:write_noncoh_mem -> apci_mem_adaptor"
        ],
        "body": [
            "write_noncoh_mem(${1:addr}, ${2:first_be}, ${3:last_be}, ${4:va}, ${5:src});"
        ],
        "description": "[Class:apci_mem_adaptor]\n     virtual task write_noncoh_mem(    input bit             addr       ,\n    input bit              first_be   ,\n    input bit              last_be    ,\n    ref   bit             va             ,\n    input avery_data_base src         );    "
    },
    "apci_mem_adaptor :: read_noncoh_mem": {
        "prefix": [
            "read_noncoh_mem",
            "task:read_noncoh_mem -> apci_mem_adaptor"
        ],
        "body": [
            "read_noncoh_mem(${1:addr}, ${2:ndw}, ${3:first_be}, ${4:last_be}, ${5:va}, ${6:src});"
        ],
        "description": "[Class:apci_mem_adaptor]\n     virtual task read_noncoh_mem(    input bit             addr    ,\n    input bit             ndw     ,\n    input bit              first_be,\n    input bit              last_be ,\n    ref   bit             va      ,\n    input avery_data_base src);    "
    },
    "apci_lpif_gasket_base": {
        "prefix": "apci_lpif_gasket_base",
        "body": [
            "apci_lpif_gasket_base  ${0:name_class};"
        ],
        "description": "class apci_lpif_gasket_base;\n"
    },
    "apci_lpif_gasket_base :: send_over_lpif": {
        "prefix": [
            "send_over_lpif",
            "function:send_over_lpif -> apci_lpif_gasket_base"
        ],
        "body": [
            "send_over_lpif(${1:d});"
        ],
        "description": "[Class:apci_lpif_gasket_base]\n     virtual function void send_over_lpif(apci_data_base d);    "
    },
    "shall": {
        "prefix": "shall",
        "body": [
            "shall  ${0:name_class};"
        ],
        "description": "\tlog.intern($psprintf(\"acxl_lpif_gasket_base: extended class shall be used\")); \n"
    },
    "shall :: wait_from_lpif": {
        "prefix": [
            "wait_from_lpif",
            "task:wait_from_lpif -> shall"
        ],
        "body": [
            "wait_from_lpif(${1:d});"
        ],
        "description": "[Class:shall]\n     virtual task wait_from_lpif(output apci_data_base d);    "
    },
    "shall :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> shall"
        ],
        "body": [
            "sprint(${0:});"
        ],
        "description": "[Class:shall]\n     virtual function string sprint();    "
    },
    "apci_os": {
        "prefix": "apci_os",
        "body": [
            "apci_os  ${0:name_class};"
        ],
        "description": "class apci_os extends apci_packet;\n"
    },
    "apci_os :: new": {
        "prefix": [
            "new",
            "function:new -> apci_os"
        ],
        "body": [
            "new(${1:kind}, ${2:is_8b10b}, ${3:link_speed});"
        ],
        "description": "[Class:apci_os]\n     extern function new (`avery_strname  apci_os_type kind = APCI_OS_unknown,\n bit is_8b10b = 1,\n int link_speed = 1);    "
    },
    "apci_os :: copy": {
        "prefix": [
            "copy",
            "function:copy -> apci_os"
        ],
        "body": [
            "copy(${1:to}, ${2:level});"
        ],
        "description": "[Class:apci_os]\n     extern function apci_os copy(apci_os to = null,\n int level = -1);    "
    },
    "apci_os :: is_ts": {
        "prefix": [
            "is_ts",
            "function:is_ts -> apci_os"
        ],
        "body": [
            "is_ts(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_ts()            ; return kind inside {APCI_OS_ts1,\n APCI_OS_ts2}      ; endfunction    "
    },
    "apci_os :: is_ts1": {
        "prefix": [
            "is_ts1",
            "function:is_ts1 -> apci_os"
        ],
        "body": [
            "is_ts1(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_ts1()           ; return kind == APCI_OS_ts1                         ; endfunction    "
    },
    "apci_os :: is_ts2": {
        "prefix": [
            "is_ts2",
            "function:is_ts2 -> apci_os"
        ],
        "body": [
            "is_ts2(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_ts2()           ; return kind == APCI_OS_ts2                         ; endfunction    "
    },
    "apci_os :: is_ts0": {
        "prefix": [
            "is_ts0",
            "function:is_ts0 -> apci_os"
        ],
        "body": [
            "is_ts0(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_ts0()           ; return kind == APCI_OS_ts0                         ; endfunction    "
    },
    "apci_os :: is_skp": {
        "prefix": [
            "is_skp",
            "function:is_skp -> apci_os"
        ],
        "body": [
            "is_skp(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_skp()           ; return kind inside {APCI_OS_skp,\n APCI_OS_ctrl_skp} ; endfunction    "
    },
    "apci_os :: is_ctrl_skp": {
        "prefix": [
            "is_ctrl_skp",
            "function:is_ctrl_skp -> apci_os"
        ],
        "body": [
            "is_ctrl_skp(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_ctrl_skp()      ; return kind == APCI_OS_ctrl_skp                    ; endfunction    "
    },
    "apci_os :: is_ei": {
        "prefix": [
            "is_ei",
            "function:is_ei -> apci_os"
        ],
        "body": [
            "is_ei(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_ei()            ; return kind == APCI_OS_ei                          ; endfunction    "
    },
    "apci_os :: is_eie": {
        "prefix": [
            "is_eie",
            "function:is_eie -> apci_os"
        ],
        "body": [
            "is_eie(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_eie()           ; return kind inside {APCI_OS_eie,\n APCI_OS_ccix_eie} ; endfunction    "
    },
    "apci_os :: is_fts": {
        "prefix": [
            "is_fts",
            "function:is_fts -> apci_os"
        ],
        "body": [
            "is_fts(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_fts()           ; return kind == APCI_OS_fts                         ; endfunction    "
    },
    "apci_os :: is_compliance": {
        "prefix": [
            "is_compliance",
            "function:is_compliance -> apci_os"
        ],
        "body": [
            "is_compliance(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_compliance()    ; return kind == APCI_OS_compliance                  ; endfunction    "
    },
    "apci_os :: is_mod_compliance": {
        "prefix": [
            "is_mod_compliance",
            "function:is_mod_compliance -> apci_os"
        ],
        "body": [
            "is_mod_compliance(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_mod_compliance(); return kind == APCI_OS_mod_compliance              ; endfunction    "
    },
    "apci_os :: is_lidl": {
        "prefix": [
            "is_lidl",
            "function:is_lidl -> apci_os"
        ],
        "body": [
            "is_lidl(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_lidl()          ; return kind == APCI_OS_lidl                        ; endfunction    "
    },
    "apci_os :: is_sds": {
        "prefix": [
            "is_sds",
            "function:is_sds -> apci_os"
        ],
        "body": [
            "is_sds(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_sds()           ; return kind == APCI_OS_sds                         ; endfunction    "
    },
    "apci_os :: is_user": {
        "prefix": [
            "is_user",
            "function:is_user -> apci_os"
        ],
        "body": [
            "is_user(${0:});"
        ],
        "description": "[Class:apci_os]\n     function bit is_user()          ; return kind == APCI_OS_user                        ; endfunction    "
    },
    "apci_os :: compare": {
        "prefix": [
            "compare",
            "function:compare -> apci_os"
        ],
        "body": [
            "compare(${1:to}, ${2:diff});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit compare(apci_os to,\n output string diff);    "
    },
    "apci_os :: get_length": {
        "prefix": [
            "get_length",
            "function:get_length -> apci_os"
        ],
        "body": [
            "get_length(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function int get_length();    "
    },
    "apci_os :: sprint": {
        "prefix": [
            "sprint",
            "function:sprint -> apci_os"
        ],
        "body": [
            "sprint(${1:verbosity}, ${2:prefix});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function string sprint(int verbosity = 0,\n string prefix = \"\");    "
    },
    "apci_os :: is_std_ts2": {
        "prefix": [
            "is_std_ts2",
            "function:is_std_ts2 -> apci_os"
        ],
        "body": [
            "is_std_ts2(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_std_ts2();    "
    },
    "apci_os :: is_eq_ts2": {
        "prefix": [
            "is_eq_ts2",
            "function:is_eq_ts2 -> apci_os"
        ],
        "body": [
            "is_eq_ts2(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_eq_ts2();    "
    },
    "apci_os :: is_eq_ts2_8b10b": {
        "prefix": [
            "is_eq_ts2_8b10b",
            "function:is_eq_ts2_8b10b -> apci_os"
        ],
        "body": [
            "is_eq_ts2_8b10b(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_eq_ts2_8b10b();    "
    },
    "apci_os :: is_eq_ts2_128b": {
        "prefix": [
            "is_eq_ts2_128b",
            "function:is_eq_ts2_128b -> apci_os"
        ],
        "body": [
            "is_eq_ts2_128b(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_eq_ts2_128b();    "
    },
    "apci_os :: is_eq_ts1": {
        "prefix": [
            "is_eq_ts1",
            "function:is_eq_ts1 -> apci_os"
        ],
        "body": [
            "is_eq_ts1(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_eq_ts1();    "
    },
    "apci_os :: is_mod_ts": {
        "prefix": [
            "is_mod_ts",
            "function:is_mod_ts -> apci_os"
        ],
        "body": [
            "is_mod_ts(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_mod_ts();    "
    },
    "apci_os :: is_mod_ts1": {
        "prefix": [
            "is_mod_ts1",
            "function:is_mod_ts1 -> apci_os"
        ],
        "body": [
            "is_mod_ts1(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_mod_ts1();    "
    },
    "apci_os :: is_mod_ts2": {
        "prefix": [
            "is_mod_ts2",
            "function:is_mod_ts2 -> apci_os"
        ],
        "body": [
            "is_mod_ts2(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_mod_ts2();    "
    },
    "apci_os :: is_compliance_step1_128b": {
        "prefix": [
            "is_compliance_step1_128b",
            "function:is_compliance_step1_128b -> apci_os"
        ],
        "body": [
            "is_compliance_step1_128b(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_compliance_step1_128b();    "
    },
    "apci_os :: is_compliance_step2_128b": {
        "prefix": [
            "is_compliance_step2_128b",
            "function:is_compliance_step2_128b -> apci_os"
        ],
        "body": [
            "is_compliance_step2_128b(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_compliance_step2_128b();    "
    },
    "apci_os :: is_compliance_step3_128b": {
        "prefix": [
            "is_compliance_step3_128b",
            "function:is_compliance_step3_128b -> apci_os"
        ],
        "body": [
            "is_compliance_step3_128b(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_compliance_step3_128b();    "
    },
    "apci_os :: is_8b10b_mod_compliance_with_delay": {
        "prefix": [
            "is_8b10b_mod_compliance_with_delay",
            "function:is_8b10b_mod_compliance_with_delay -> apci_os"
        ],
        "body": [
            "is_8b10b_mod_compliance_with_delay(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit is_8b10b_mod_compliance_with_delay();    "
    },
    "apci_os :: rehash_parity": {
        "prefix": [
            "rehash_parity",
            "function:rehash_parity -> apci_os"
        ],
        "body": [
            "rehash_parity(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void rehash_parity();    "
    },
    "apci_os :: rehash_margin": {
        "prefix": [
            "rehash_margin",
            "function:rehash_margin -> apci_os"
        ],
        "body": [
            "rehash_margin(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void rehash_margin();    "
    },
    "apci_os :: make_cp_8b10b": {
        "prefix": [
            "make_cp_8b10b",
            "function:make_cp_8b10b -> apci_os"
        ],
        "body": [
            "make_cp_8b10b(${1:with_delay}, ${2:err_status});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void make_cp_8b10b(bit with_delay,\n bit       err_status);    "
    },
    "apci_os :: make_cp_128b": {
        "prefix": [
            "make_cp_128b",
            "function:make_cp_128b -> apci_os"
        ],
        "body": [
            "make_cp_128b(${1:step}, ${2:lane_no}, ${3:tx_preset});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void make_cp_128b(byte step,\n byte lane_no,\n bit       tx_preset);     "
    },
    "apci_os :: make_cp_1b1b": {
        "prefix": [
            "make_cp_1b1b",
            "function:make_cp_1b1b -> apci_os"
        ],
        "body": [
            "make_cp_1b1b(${1:step}, ${2:lane_no});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void make_cp_1b1b(byte step,\n byte lane_no);    "
    },
    "apci_os :: rehash_gen6_ts": {
        "prefix": [
            "rehash_gen6_ts",
            "function:rehash_gen6_ts -> apci_os"
        ],
        "body": [
            "rehash_gen6_ts(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void rehash_gen6_ts();    "
    },
    "apci_os :: mod_ec": {
        "prefix": [
            "mod_ec",
            "function:mod_ec -> apci_os"
        ],
        "body": [
            "mod_ec(${1:ec});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function void mod_ec(bit       ec);    "
    },
    "apci_os :: get_ec": {
        "prefix": [
            "get_ec",
            "function:get_ec -> apci_os"
        ],
        "body": [
            "get_ec(${0:});"
        ],
        "description": "[Class:apci_os]\n     extern virtual function bit       get_ec();    "
    },
    "uvm_raise_objection": {
        "prefix": [
            "uvm_raise_objection",
            "function:uvm_raise_objection"
        ],
        "body": [
            "uvm_raise_objection(${0:});"
        ],
        "description": "    local function void uvm_raise_objection();    "
    },
    "uvm_drop_objection": {
        "prefix": [
            "uvm_drop_objection",
            "function:uvm_drop_objection"
        ],
        "body": [
            "uvm_drop_objection(${0:});"
        ],
        "description": "    local function void uvm_drop_objection();    "
    }
}